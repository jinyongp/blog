<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pattern on jinyongp.dev</title><link>https://jinyongp.dev/tags/pattern/</link><description>Recent content in pattern on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Tue, Aug 01 03:32:29 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/tags/pattern/feed.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Delegate Pattern</title><link>https://jinyongp.dev/posts/uikit/1/</link><pubDate>Tue, Aug 01 03:32:29 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/uikit/1/</guid><description>&lt;h2 id="introduce-delegate-pattern" class="flex items-center gap-3">Introduce Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#introduce-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>UIKit에서는 여러가지 UI 관련 View를 제공합니다. 이 중에선 동작에 필요한 세부 구현은 숨겨진 채로 특정 상황이 발생했을 때만 ViewController에게 데이터를 전달하는 UIView가 있습니다.&lt;/p>
&lt;p>예를 들어 &lt;code>UITextField&lt;/code>의 경우, 사용자가 입력창을 눌렀을 때 OS에게 키보드를 열 것을 명령하며 사용자가 입력한 값을 &lt;code>UITextField&lt;/code>에 전달하는 동작이 구현되어 있을 것입니다. 하지만 ViewController에선 이러한 세부 동작은 알 필요 없이 특정 상황이 발생했을 때만 데이터를 전달 받아 이용하면 됩니다.&lt;/p>
&lt;p>UIkit에서는 이렇게 세부 구현은 숨긴 채로 특정 상황이 발생했음을 알리거나 동작의 제어를 위임하기 위해 Delegate Pattern을 활용하고 있습니다. &lt;code>UITextField&lt;/code>는 &lt;code>UITextFieldDelegate&lt;/code> 프로토콜을 통해 이를 구현하고 있으며, 이를 채택한 ViewController는 다음의 메서드를 구현하여 데이터를 전달받고 동작을 제어할 수 있습니다.&lt;/p>
&lt;p>&lt;code>UITextFieldDelegate&lt;/code>를 채택하여 구현할 수 있는 메서드 목록은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4">
&lt;pre>&lt;code>// 편집을 시작할 때 호출합니다. Bool 값을 반환하여 편집을 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldBeginEditing(_:) -&amp;gt; Bool
// 편집이 시작된 직후 호출됩니다.
optional func textFieldDidBeginEditing(_:)
// 편집이 종료될 때 호출됩니다. Bool 값을 반환하여 편집을 중지할지 여부를 결정할 수 있습니다.
optional func textFieldShouldEndEditing(_:) -&amp;gt; Bool
// 편집이 종료된 직후 호출됩니다.
optional func textFieldDidEndEditing(_:)
// 텍스트 필드의 문자열이 변경될 때 호출됩니다. Bool 값을 반환하여 변경을 허용할지 여부를 결정할 수 있습니다.
optional func textField(_:shouldChangeCharactersIn:replacementString:) -&amp;gt; Bool
// 텍스트 필드의 선택 영역이 변경될 때 호출됩니다.
optional func textFieldDidChangeSelection(_:)
// 텍스트를 삭제할 때 호출됩니다. Bool 값을 반환하여 삭제를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldClear(_:) -&amp;gt; Bool
// 텍스트 필드의 리턴 키가 눌렸을 때 호출됩니다. Bool 값을 반환하여 리턴 키를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldReturn(_:) -&amp;gt; Bool&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>&lt;code>optional&lt;/code> 키워드로 정의되어 있으니 ViewController는 이 중에서 필요한 메서드만 구현하면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>정의한 메서드가 호출되려면 &lt;code>UITextField&lt;/code> 인스턴스의 &lt;code>delegate&lt;/code> 프로퍼티에 ViewController를 할당해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4">
&lt;pre>&lt;code>final class ViewController: UIViewController {
private let textField = UITextField()
override func viewDidLoad() {
super.viewDidLoad()
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
// ...
}
func textFieldDidBeginEditing(_ textField: UITextField) {
// ...
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이런 식으로 Delegate Pattern을 통해 동작의 제어권을 위임받을 수 있습니다.&lt;/p>
&lt;h2 id="understand-delegate-pattern" class="flex items-center gap-3">Understand Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#understand-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>그렇다면 Delegate Pattern은 어떤 식으로 동작하기에 다른 객체에게 동작의 제어권을 위임할 수 있는걸까요? 간단한 &lt;code>Delegate&lt;/code> 프로토콜을 구현하여 동작을 확인해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4">
&lt;pre>&lt;code>protocol UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool
func textFieldDidBeginEditing(_ textField: UITextField)
}
class UITextField {
var delegate: UITextFieldDelegate?
func userTextFieldTapped() {
guard let delegate else { return }
if delegate.textFieldShouldBeginEditing(self) {
// OS에게 키보드 열기 요청
delegate.textFieldDidBeginEditing(self)
}
}
}
class ViewController {
let textField = UITextField()
func viewDidLoad() {
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
print(#function)
return true
}
func textFieldDidBeginEditing(_ textField: UITextField) {
print(#function)
}
}
let controller = ViewController()
controller.viewDidLoad()
controller.textField.userTextFieldTapped()
// output:
// textFieldShouldBeginEditing(_:)
// textFieldDidBeginEditing(_:)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>소스 코드가 공개되어 있지 않으므로 정확한 세부 구현은 알 수 없으나 Delegate 패턴을 활용한 내부 모습은 대략 위와 비슷할 것으로 추정합니다.&lt;/p>
&lt;p>&lt;code>UITextField&lt;/code>의 경우 외부로부터 주입 받은 &lt;code>delegate&lt;/code> 객체를 통해 &lt;code>textFieldShouldBeginEditing&lt;/code>를 호출하여 동작의 제어권을 위임한 모습입니다. &lt;code>textFieldShouldBeginEditing&lt;/code>에서 &lt;code>false&lt;/code>를 반환하면 &lt;code>textFieldDidBeginEditing&lt;/code>는 호출되지 않을 것입니다.&lt;/p>
&lt;p>이러한 원리를 응용하여 Custom Delegate를 추가할 수 있습니다. &lt;a
class="underline-lsre"
href="https://jinyongp.dev/learn/nbcamp/5#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>Delegate Pattern 적용하기&lt;/a
>&lt;/p></description></item></channel></rss>