<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nbcamp on jinyongp.dev</title><link>https://jinyongp.dev/tags/nbcamp/</link><description>Recent content in nbcamp on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Fri, Aug 11 06:52:27 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/tags/nbcamp/feed.xml" rel="self" type="application/rss+xml"/><item><title>[내배캠] UIKit 기초 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/5/</link><pubDate>Fri, Aug 11 06:52:27 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/5/</guid><description>&lt;p>2023년 7월 31일부터 8월 11일까지 UIKit의 기초적인 내용을 학습하고 간단한 ToDo App을 만들어보았습니다.&lt;/p>
&lt;p>기본으로 제공되는 강의도 있었지만 프로젝트를 진행하기에 내용이 그리 충분치 않았기에 별도의 강의를 수강하면서 과제를 수행하였습니다. &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨&lt;/a
> 과정을 어느 정도 수강하면 무료로 제공해주는 &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8-%ec%95%b1%eb%a7%8c%eb%93%a4%ea%b8%b0"
target="_blank" rel="noopener noreferrer nofollow"
>15개 앱을 만들면서 근본원리부터 배우는 UIKit&lt;/a
> 강의를 병행하였습니다. 프로젝트의 요구 조건을 충족하기 위해 필요한 몇몇 지식을 습득했습니다.&lt;/p>
&lt;ul>
&lt;li>UIKit의 기본적인 구조와 사용법&lt;/li>
&lt;li>리스트를 표시하는 방법 (UITableView)&lt;/li>
&lt;li>페이지 간 이동 및 데이터 전달 방법 (Segue)&lt;/li>
&lt;li>Alert 표시 및 사용자로부터 입력 받는 방법 (UIAlertController)&lt;/li>
&lt;/ul>
&lt;h3 id="project-structure" class="flex items-center gap-3">Project Structure &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#project-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;pre>&lt;code class="language-text">TodoApp/
├── LaunchScreen.storyboard
├── Main.storyboard
├── Models/
│ └── TodoItem.swift
├── Services/
│ └── TodoService.swift
├── Views/
│ ├── ViewController.swift
│ ├── CompletesViewController.swift
│ └── TodoTableViewCell.swift
├── Info.plist
├── AppDelegate.swift
└── SceneDelegate.swift
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Views&lt;/code>: UI를 담당하는 클래스를 가집니다.&lt;/li>
&lt;li>&lt;code>Models&lt;/code>: 데이터 모델 구조체를 가집니다.&lt;/li>
&lt;li>&lt;code>Services&lt;/code>: 데이터를 관리하는 비즈니스 로직을 담은 클래스를 가집니다&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="storyboard" class="flex items-center gap-3">Storyboard &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#storyboard"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;img src="https://jinyongp.dev/image/learn/nbcamp/5/storyboard.png" alt="Storyboard">&lt;/p>
&lt;div class="flex gap-5 justify-center">
&lt;img class="shadow-md !rounded-2xl" src="https://jinyongp.dev/image/learn/nbcamp/5/main-page.png" width="23%" alt="Main Page">
&lt;img class="shadow-md !rounded-2xl" src="https://jinyongp.dev/image/learn/nbcamp/5/completes-page.png" width="23%" alt="Completes Page">
&lt;img class="shadow-md !rounded-2xl" src="https://jinyongp.dev/image/learn/nbcamp/5/add-new-item.png" width="23%" alt="Completes Page">
&lt;img class="shadow-md !rounded-2xl" src="https://jinyongp.dev/image/learn/nbcamp/5/edit-item.png" width="23%" alt="Completes Page">
&lt;/div>
&lt;h3 id="implementation" class="flex items-center gap-3">Implementation &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#implementation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="todoitem" class="flex items-center gap-3">TodoItem &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#todoitem"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;pre>&lt;code class="language-swift">final class TodoItem {
var id: String
var content: String
var createdAt: UInt
var completedAt: UInt?
var completed: Bool { completedAt != nil }
init(content: String) {
self.id = UUID().uuidString
self.content = content
self.createdAt = UInt(Date().timeIntervalSince1970)
}
}
&lt;/code>&lt;/pre>
&lt;p>배열에서 인스턴스를 가져오는 과정에서 값의 복사가 아닌 참조를 가져오길 원했습니다. 그런 이유로 &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>를 사용했고, 상속할 여지가 없으므로 &lt;code>final&lt;/code> 키워드를 붙여 Dynamic Dispatch 대신 Static Dispatch 방식을 채택하였습니다.&lt;/p>
&lt;h4 id="todoservice" class="flex items-center gap-3">TodoService &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#todoservice"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;pre>&lt;code class="language-swift">final class TodoService {
static var shared: TodoService = .init()
private init() {}
private(set) var items: [TodoItem] = [
TodoItem(content: &amp;quot;New를 눌러 새로운 항목을 추가해보세요!&amp;quot;),
TodoItem(content: &amp;quot;여기를 눌러 할 일 내용을 변경해보세요!&amp;quot;),
TodoItem(content: &amp;quot;체크박스를 눌러 할 일을 완료해보세요!&amp;quot;),
TodoItem(content: &amp;quot;Completes를 눌러 완료 내역을 확인하세요!&amp;quot;),
]
func add(content: String) {
items.append(TodoItem(content: content))
}
func update(index: Int, content: String) {
items[index].content = content
}
func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>TodoService&lt;/code>의 경우, 대부분의 &lt;code>Views&lt;/code>에서 사용될 예정이므로 하나의 &lt;code>Items&lt;/code>만 생성되어야 함을 보장하기 위해 Singleton 패턴을 적용하였습니다.&lt;/p>
&lt;h4 id="viewcontroller" class="flex items-center gap-3">ViewController &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#viewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>&lt;code>ViewController&lt;/code>의 경우 Main Page의 View와 Logic을 담당합니다. UI 관련 로직은 생략했습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">final class ViewController: UIViewController {
@IBOutlet weak var titleLabel: UILabel!
@IBOutlet weak var tableView: UITableView!
@IBOutlet weak var newButton: UIButton!
@IBOutlet weak var completesButton: UIButton!
private var todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { !$0.completed } }
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
func initializeUI() {
// ...
}
@IBAction func newButtonTapped(_ sender: UIButton) {
// ...
}
}
extension ViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;TodoCell&amp;quot;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let index = indexPath.row
let item = items[index]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { [weak self] cell in
guard let self else { return }
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
cell.onLabelTapped = { [weak self] label in
guard let self else { return }
let alert = UIAlertController(title: &amp;quot;Edit Todo Item&amp;quot;, message: nil, preferredStyle: .alert)
let confirmAction = UIAlertAction(title: &amp;quot;Edit&amp;quot;, style: .default) { [weak alert] _ in
let text = alert?.textFields?[0].text ?? &amp;quot;&amp;quot;
if text.isEmpty { return }
label.text = text
self.todoService.update(index: index, content: text)
}
let cancelAction = UIAlertAction(title: &amp;quot;Cancel&amp;quot;, style: .cancel) { _ in
self.dismiss(animated: true)
}
alert.addTextField { $0.placeholder = label.text }
alert.addAction(confirmAction)
alert.addAction(cancelAction)
self.present(alert, animated: true)
}
return cell
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>UITableViewDataSource&lt;/code>를 채택하여 TableView를 그리기 위해 필요한 최소 메서드를 구현하였습니다. 완료하지 않은 할 일 목록만 가져와서 표시하고 있습니다. &lt;code>TodoTableViewCell&lt;/code>에 데이터를 전달하고 어떠한 이벤트가 발생했을 때 실행할 함수를 클로저로 전달하고 있습니다. Delegate Pattern을 활용할 수 있겠지만, 단순하게 클로저를 전달하는 방법으로 구현하였습니다.&lt;/p>
&lt;p>완료 버튼을 눌렀을 땐 애니메이션과 함께 목록에서 제거하도록 작성하였고, 라벨을 눌렀을 땐 Alert을 띄워 내용을 수정할 수 있도록 작성하였습니다.&lt;/p>
&lt;h3 id="todotableviewcell" class="flex items-center gap-3">TodoTableViewCell &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#todotableviewcell"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;pre>&lt;code class="language-swift">final class TodoTableViewCell: UITableViewCell {
@IBOutlet weak var todoLabel: UILabel!
@IBOutlet weak var completeButton: UIButton!
var onCompleted: ((_: TodoTableViewCell) -&amp;gt; Void)?
var onLabelTapped: ((_: UILabel) -&amp;gt; Void)?
var completed: Bool = false {
didSet {
completeButton.isSelected = completed
let attributedText = NSMutableAttributedString(string: todoLabel.text!)
if completed {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.5, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
} else {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: [] as [Any], range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.0, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
}
todoLabel.attributedText = attributedText
}
}
override func didMoveToSuperview() {
initializeUI()
}
private func initializeUI() {
setupGesture()
}
private func setupGesture() {
let tapGesture = UITapGestureRecognizer(target: self, action: #selector(labelTapped))
todoLabel.isUserInteractionEnabled = true
todoLabel.addGestureRecognizer(tapGesture)
}
@objc
func labelTapped() {
onLabelTapped?(todoLabel)
}
@IBAction func doneButtonTapped(_ sender: UIButton) {
onCompleted?(self)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>TodoTableViewCell&lt;/code>은 완료 여부를 뜻하는 &lt;code>completed&lt;/code>을 감시자 속성으로 가지고 있어, &lt;code>completed&lt;/code>가 변경됨에 따라 라벨에 &lt;code>strikethrough&lt;/code> 스타일을 추가/제거합니다.&lt;/p>
&lt;p>라벨에 Touch Action을 등록하기 위해서 &lt;code>UITapGestureRecognizer&lt;/code>를 추가하였습니다.&lt;/p>
&lt;h3 id="completesviewcontroller" class="flex items-center gap-3">CompletesViewController &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#completesviewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>메인 페이지에서 &lt;code>completes&lt;/code> 버튼을 누르면 해당 페이지를 표시합니다. 버튼에 직접 등록하는 Segue 방식으로 연결하였습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">final class CompletesViewController: UIViewController {
@IBOutlet weak var tableView: UITableView!
private let todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { $0.completed } }
var onDismissed: (() -&amp;gt; Void)?
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
onDismissed?()
}
func initializeUI() {
tableView.backgroundView = {
let label = UILabel()
label.text = &amp;quot;Complete Your Todo!&amp;quot;
label.textAlignment = .center
label.textColor = .gray
return label
}()
}
}
extension CompletesViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
UIView.animate(withDuration: 0.2) {
tableView.backgroundView?.layer.opacity = self.items.count &amp;gt; 0 ? 0.0 : 1.0
}
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;TodoCell&amp;quot;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let item = items[indexPath.row]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { cell in
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
return cell
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>CompletesViewController&lt;/code>에서도 &lt;code>UITableView&lt;/code>를 사용하므로 &lt;code>ViewController&lt;/code>와 동일한 방식으로 구현하였습니다. 완료 버튼을 눌러 완료를 취소할 수 있도록 하였습니다. 완료를 취소한 후, 변경 내용이 메인 페이지에도 반영되어야 하므로 페이지가 닫힐 때 호출할 &lt;code>onDismissed&lt;/code> 클로저를 추가하였습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;quot;CompletesVC&amp;quot; {
if let vc = segue.destination as? CompletesViewController {
vc.onDismissed = {
self.tableView.reloadData()
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>CompletesViewController&lt;/code> 객체에 클로저를 전달하기 위해 &lt;code>ViewController&lt;/code>에 &lt;code>prepare&lt;/code> 메서드를 구현하였습니다. &lt;code>onDismissed&lt;/code>가 호출되면 메인 페이지의 &lt;code>tableView&lt;/code>를 갱신합니다.&lt;/p>
&lt;h5 id="delegate-패턴-적용" class="flex items-center gap-3">Delegate 패턴 적용 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h5>&lt;p>클로저 전달 방식 대신 Delegate 패턴을 적용해보았습니다. &lt;code>onDismissed&lt;/code> 클로저를 전달하는 대신 &lt;code>CompletesViewControllerDelegate&lt;/code> 프로토콜을 정의하여 &lt;code>onDismissed&lt;/code> 메서드 동작을 위임하도록 해보았습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">@objc protocol CompletesViewControllerDelegate {
@objc optional func onDismissed()
}
final class CompletesViewController: UIViewController {
var delegate: CompletesViewControllerDelegate?
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
delegate?.onDismissed?()
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;quot;CompletesVC&amp;quot; {
if let vc = segue.destination as? CompletesViewController {
vc.delegate = self
}
}
}
}
extension ViewController: CompletesViewControllerDelegate {
func onDismissed() {
tableView.reloadData()
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>ViewController&lt;/code>가 &lt;code>prepare&lt;/code> 메서드에서 &lt;code>delegate&lt;/code> 인스턴스를 전달하고, &lt;code>CompletesViewControllerDelegate&lt;/code>를 채택하여 &lt;code>tableView&lt;/code>를 갱신하도록 작성했습니다. 위와 동일하게 동작함을 확인할 수 있습니다.&lt;/p>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="1-객체의-속성-변경이-반영되지-않는-문제" class="flex items-center gap-3">1. 객체의 속성 변경이 반영되지 않는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#1-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%86%8d%ec%84%b1-%eb%b3%80%ea%b2%bd%ec%9d%b4-%eb%b0%98%ec%98%81%eb%90%98%ec%a7%80-%ec%95%8a%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>&lt;code>TodoService&lt;/code>에서 &lt;code>TodoItem&lt;/code>의 속성을 변경할 때 제대로 변경되지 않는 문제가 있었습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}
&lt;/code>&lt;/pre>
&lt;p>원인은 &lt;code>TodoItem&lt;/code>이 &lt;code>struct&lt;/code> 키워드로 선언되어 있어, &lt;code>first&lt;/code>를 통해 찾은 값을 &lt;code>item&lt;/code> 변수에 할당하는 과정에서 값의 복사가 발생하여 복사된 값의 속성을 변경하더라도 원본 값이 변경되지 않는 문제였습니다. &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>로 선언하는 방식으로 문제를 해결했습니다.&lt;/p>
&lt;h4 id="2-unknown-class-_viewcontroller-in-interface-builder-file-에러" class="flex items-center gap-3">2. Unknown class _ViewController in Interface Builder file. 에러 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2-unknown-class-_viewcontroller-in-interface-builder-file-%ec%97%90%eb%9f%ac"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>여러 ViewController를 생성하는 과정에서 xcode의 버그로 인해 Module이 제대로 설정되지 않아 발생한 문제였습니다.&lt;/p>
&lt;img class="!my-0 !mx-auto md:!ml-4 md:w-1/3 md:float-right" src="https://jinyongp.dev/image/learn/nbcamp/5/unknown-class-error.png" alt="Unknown Class Error">
&lt;p>Storyboard에서 문제가 발생하는 ViewController를 선택한 뒤, 우측 Inspector Pane의 Identifier Inspector에서 Custom Class 항목의 Module이 None인지 확인합니다. None이라면 프로젝트 이름으로 변경한 뒤 Inherit Module From Target을 활성화합니다.&lt;/p>
&lt;p>참고: &lt;a
class="underline-lsre"
href="https://points.tistory.com/10"
target="_blank" rel="noopener noreferrer nofollow"
>[iOS] Unknown class _ViewController in Interface Builder file.&lt;/a
>&lt;/p>
&lt;h3 id="retrospective" class="flex items-center gap-3">Retrospective &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#retrospective"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>UIKit로 개발하면서 여태까지 해왔던 웹 개발과 많은 비교를 하게 되었습니다. UIKit으로 개발하는 건 웹 개발로 비유를 하자면 HTML, CSS 없이 JavaScript로만 모든 UI와 Style을 작성하는 것과 비슷했습니다. 웹에서 HTML과 CSS 그리고 JavaScript가 분리되어 있다는 게 굉장한 장점이구나 다시 한번 느끼게 되었습니다. UIKit의 경우 모든 내용을 선언형이 아닌 명령형으로 작성해야 하기 때문에 각 역할에 맞게 적절하게 코드를 분리하기 위한 노력이 필요함을 절실히 깨달았습니다.&lt;/p>
&lt;p>Storyboard와 코드를 연동하여 작성되어야 하는 부분이 있기 때문에 코드가 실행되는데 눈에 보이는 부분보단 이렇게 동작할 것이다 추론해야 하는 경우가 많았고 에러가 발생해도 추적하기가 굉장히 어려워서 개발 경험이 그리 좋지 않았습니다. 아무래도 UIKit의 대부분이 Objective-C로 작성되어 있어 해당 내용을 알아야만 에러 내용을 통해 원인을 유추할 수 있는 것도 한몫 하다보니 어려웠던 듯 싶습니다. 협업 관점에서 보나 디버깅 관점에서 보나 웬만하면 Storyboard 방식보단 코드 방식의 개발이 더 유리하지 않을까 생각했습니다.&lt;/p></description></item><item><title>[내배캠] Swift 기초 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/3/</link><pubDate>Wed, Jul 19 04:26:26 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/3/</guid><description>&lt;p>본 캠프가 시작되고 2주차가 되었습니다.&lt;/p>
&lt;p>이번 주차에선 Swift를 학습하고 간단한 연산 기능을 제공하는 계산기를 만들어 보는 과제를 수행했습니다.&lt;/p>
&lt;p>캠프에서는 자기주도적 학습 방식을 추구하기 때문에 주어지는 학습 자료 외에도 스스로 조사하고 학습해야 합니다.
주어지는 학습자료만으로는 깊게 학습할 수 없었기에 공식 문서와 다른 강의를 병행하며 부족한 부분을 채워야 합니다.&lt;/p>
&lt;p>저는 캠프 참여 이전에 이러한 부분을 인지하고 있었으므로 자세한 문법이나 이론 관련한 내용은 &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨&lt;/a
> 과정을 병행하며 보충했습니다.&lt;/p>
&lt;p>과제를 수행하기에 충분한 문법과 이론을 학습했고, 이를 기반으로 CLI에서 실행할 수 있는 간단한 계산기 툴을 작성했습니다.&lt;/p>
&lt;h3 id="requirements" class="flex items-center gap-3">Requirements &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#requirements"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>1단계: 덧셈, 뺄셈, 곱셈, 나눗셈 연산 기능을 제공하는 Calculator 클래스 구현&lt;/li>
&lt;li>2단계: 1단계에서 구현한 Calculator 클래스를에 나머지 연산 기능 추가&lt;/li>
&lt;li>3단계: 각 연산을 개별 연산 클래스로 분리하고 Calculator와 연결 (feat. 단일 책임 원칙)&lt;/li>
&lt;li>4단계: 연산 클래스를 추상화한 추상 클래스 작성 (feat. 결합도, 의존성 역전 원칙)&lt;/li>
&lt;/ul>
&lt;h3 id="directory-structure" class="flex items-center gap-3">Directory Structure &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#directory-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;pre>&lt;code class="language-text">.
├── Sources/
│ ├── Operators/
│ │ ├── AddOperator.swift
│ │ ├── SubOperator.swift
│ │ ├── MulOperator.swift
│ │ ├── DivOperator.swift
│ │ ├── ModOperator.swift
│ │ └── Operator.swift
│ ├── Calculator.swift
│ └── main.swift
├── Package.swift
└── README.md
&lt;/code>&lt;/pre>
&lt;h3 id="implementation" class="flex items-center gap-3">Implementation &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#implementation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="setup" class="flex items-center gap-3">Setup &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#setup"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>과제에서는 단순히 연산 후 출력하는 걸 요구하고 있지만, 저는 &lt;code>readLine&lt;/code> 함수를 활용하여 사용자로부터 입력을 받아 계속 연산이 가능하도록 구현했습니다.&lt;/p>
&lt;p>실행 가능한 파일로 작성하기 위해 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>를 참고하여 프로젝트를 생성했습니다.&lt;/p>
&lt;pre>&lt;code class="language-sh">$ swift package init --type executable
&lt;/code>&lt;/pre>
&lt;p>위 명령어를 실행하면 현재 위치한 폴더에 &lt;code>Package.swift&lt;/code> 파일을 생성합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">// swift-tools-version: 5.8
// The swift-tools-version declares the minimum version of Swift required to build this package.
import PackageDescription
let package = Package(
name: &amp;quot;calculator-cli&amp;quot;,
targets: [
// Targets are the basic building blocks of a package, defining a module or a test suite.,
// Targets can depend on other targets in this package and products from dependencies.
.executableTarget(
name: &amp;quot;calc&amp;quot;,
path: &amp;quot;Sources&amp;quot;
),
]
)
&lt;/code>&lt;/pre>
&lt;p>이 파일에서 프로젝트에 대한 의존성 관리 및 빌드 설정 등을 할 수 있습니다.&lt;/p>
&lt;p>&lt;code>Sources&lt;/code> 폴더에 &lt;code>main.swift&lt;/code> 또한 생성되므로 &lt;code>swift run&lt;/code> 명령어를 실행하여 프로젝트를 실행할 수 있습니다.&lt;/p>
&lt;h4 id="impl-operator-protocol" class="flex items-center gap-3">Impl Operator protocol &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#impl-operator-protocol"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>각 연산에 대한 클래스의 명세를 정하기 위해 &lt;code>Operator&lt;/code> 프로토콜을 작성했습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}
&lt;/code>&lt;/pre>
&lt;p>이를 토대로 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 클래스를 작성했습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">class AddOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand {
return lhs + rhs
}
}
&lt;/code>&lt;/pre>
&lt;p>여기서 &lt;code>lhs + rhs&lt;/code> 에서 &lt;code>Binary operator '+' cannot be applied to two 'Operand' operands&lt;/code> 에러가 발생합니다. &lt;code>Operand&lt;/code> 타입이 덧셈 기능을 제공하는지 모르기 때문입니다.&lt;/p>
&lt;p>이를 해결하려면 &lt;code>Operand&lt;/code> 타입이 연산 가능한 타입만 올 수 있도록 제약을 걸 필요가 있습니다. &lt;code>Calculable&lt;/code> 프로토콜을 추가하여 이를 준수하는 타입만 올 수 있도록 제약을 걸었습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Operator {
func operate&amp;lt;Operand: Calculable&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}
protocol Calculable {
static func +(lhs: Self, rhs: Self) -&amp;gt; Self
static func -(lhs: Self, rhs: Self) -&amp;gt; Self
static func *(lhs: Self, rhs: Self) -&amp;gt; Self
static func /(lhs: Self, rhs: Self) -&amp;gt; Self
static func %(lhs: Self, rhs: Self) -&amp;gt; Self
}
extension Int: Calculable {}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Calculable&lt;/code> 프로토콜을 추가하고 &lt;code>Int&lt;/code> 타입이 이를 준수하도록 확장(extension)했습니다.&lt;/p>
&lt;p>하지만, 위와 같은 방식으로 &lt;code>Double&lt;/code> 타입을 확장했을 때, &lt;code>Type 'Double' does not conform to protocol 'Calculable'&lt;/code> 에러가 발생합니다. 실수 타입인 &lt;code>Double&lt;/code>은 나머지 연산에 대한 동작이 정의되어 있지 않기 때문입니다. 단순히 정수 타입으로 동작하도록 확장해줍니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">extension Double: Calculable {
static func %(lhs: Self, rhs: Self) -&amp;gt; Self {
return Double(Int(lhs) % Int(rhs))
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-swift">class ModOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand where Operand : Calculable {
return lhs % rhs
}
}
&lt;/code>&lt;/pre>
&lt;p>이로써 나머지 연산에 대해서도 &lt;code>Double&lt;/code> 타입을 사용할 수 있게 되었고, &lt;code>Operator&lt;/code> 프로토콜을 준수하는 &lt;code>ModOperator&lt;/code> 클래스를 작성할 수 있게 되었습니다. (SPR. 단일 책임 원칙)&lt;/p>
&lt;h4 id="impl-calculator-class" class="flex items-center gap-3">Impl Calculator class &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#impl-calculator-class"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>작성한 연산자를 언제든 사용할 수 있는 형태로 하여 Dictionary 형태로 외부에서 주입할 수 있도록 작성했습니다.&lt;/p>
&lt;p>&lt;code>_result&lt;/code>는 여태까지 연산한 결과를 갖고 있는 저장 프로퍼티이고, &lt;code>calculate&lt;/code> 메서드를 호출하여 연산을 수행합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">import Foundation
class Calculator&amp;lt;T: Calculable&amp;gt; {
private var _result: T
private var _operators: [String: Operator]
init(defaultValue: T? = nil, operators: [String: Operator] = [:]) {
_result = defaultValue ?? Calculator.zero()
_operators = operators
}
var result: T { _result }
var operators: [String] { Array(_operators.keys) }
@discardableResult
func calculate(_ operand: T, name: String) -&amp;gt; T {
guard let operation = _operators[name] else { return _result }
_result = operation.operate(_result, operand)
return _result
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-swift">let calculator = Calculator&amp;lt;Double&amp;gt;(
operators: [
&amp;quot;+&amp;quot;: AddOperator(),
&amp;quot;-&amp;quot;: SubOperator(),
&amp;quot;*&amp;quot;: MulOperator(),
&amp;quot;/&amp;quot;: DivOperator(),
&amp;quot;%&amp;quot;: ModOperator(),
]
)
calculator.calculate(10, name: &amp;quot;+&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>이로써 &lt;code>Calculator&lt;/code>는 구체적인 클래스가 아닌 추상화된 프로토콜에 의존합니다. (DIP. 의존성 역전 원칙)&lt;/p>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="1-0으로-초기화할-때-제네릭-타입으로-변환할-수-없는-문제" class="flex items-center gap-3">1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#1-0%ec%9c%bc%eb%a1%9c-%ec%b4%88%ea%b8%b0%ed%99%94%ed%95%a0-%eb%95%8c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%eb%b3%80%ed%99%98%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>계산기이니 &lt;code>clear&lt;/code> 메서드를 작성했고, 이는 결과를 0으로 초기화하는 단순한 작업을 수행합니다. &lt;code>Int&lt;/code> 타입은 0으로 초기화하는 반면에 &lt;code>Double&lt;/code>은 0.0으로 초기화해야 했기 때문입니다. 제네릭 타입으로부터 이를 확인할 수 있는 방법은 없었지만, 0과 0.0 이외에 경우는 없다고 가정하고 nullish coalescing operator를 사용하여 해결했습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">private static func zero() -&amp;gt; T {
return 0 as? T ?? 0.0 as! T
}
&lt;/code>&lt;/pre>
&lt;h4 id="2-첫-문자를-제외한-문자열-가져오기" class="flex items-center gap-3">2. 첫 문자를 제외한 문자열 가져오기 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2-%ec%b2%ab-%eb%ac%b8%ec%9e%90%eb%a5%bc-%ec%a0%9c%ec%99%b8%ed%95%9c-%eb%ac%b8%ec%9e%90%ec%97%b4-%ea%b0%80%ec%a0%b8%ec%98%a4%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>Swift에서 문자열을 조작하기란 다른 언어에 비해 번거로운 점이 많았습니다&amp;hellip; index 또한 단순히 숫자가 아니라 String.Index를 생성하여 전달해야했고, 주어진 Index로부터 어느정도 떨어졌는지하는 방식으로 문자열을 가져와야했습니다.&lt;/p>
&lt;p>첫 문자를 제외하고 문자열을 가져오려면 다음 방식으로 가져와야 합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">let input: String = &amp;quot;Hello, World!&amp;quot;
input[input.index(input.startIndex, offsetBy: 1)...] // ello, World!
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>&lt;code>input.index&lt;/code> 메서드를 호출하여 &lt;code>String.Index&lt;/code> 타입의 인덱스를 생성합니다. 이때, &lt;code>input.startIndex&lt;/code>를 기준으로 &lt;code>offsetBy&lt;/code> 만큼 떨어진 인덱스를 생성합니다.&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/partialrangefrom"
target="_blank" rel="noopener noreferrer nofollow"
>PartialRangeFrom&lt;/a
> 문법을 활용하여 해당 인덱스부터 문자열을 가져옵니다.&lt;/li>
&lt;/ol>
&lt;p>나중에 알게된 내용인데 단순하게 &lt;code>dropFirst&lt;/code> 메서드를 활용해도 됩니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">input.dropFirst() // ello, World!
&lt;/code>&lt;/pre>
&lt;p>문자열 관련 메서드는 대개 &lt;code>Self.SubSequence&lt;/code> 타입을 반환합니다. 잘라낸 문자열을 저장하기 위헤 새로운 메모리 공간을 할당하는 것이 아닌 기존의 문자열에서 필요한 부분에 직접 접근하기 때문입니다. 따라서, 문자열로서 사용하고 싶다면 &lt;code>String&lt;/code>으로 변환해야 합니다.&lt;/p>
&lt;h3 id="retrospective" class="flex items-center gap-3">Retrospective &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#retrospective"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>객체 지향 프로그래밍의 5대 원칙 중 단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)을 적용하여 계산기를 구현해보았습니다. 원칙을 적용해보기 위해 프로토콜로 명세를 작성하고 이를 준수하는 클래스는 작성하는 작업을 진행하면서 코드의 중복을 제거하고 확정성 높은 프로그램을 작성할 수 있었습니다.&lt;/p>
&lt;p>앞으로 이외에도 적용할 수 있는 원칙을 찾아보고 적합한 디자인 패턴 및 기법을 추가로 학습하여 적용해보려고 합니다.&lt;/p></description></item><item><title>[내배캠] 첫번째 팀 프로젝트</title><link>https://jinyongp.dev/learn/nbcamp/2/</link><pubDate>Wed, Jul 19 01:27:06 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/2/</guid><description>&lt;p>사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다.&lt;/p>
&lt;p>4일간 진행한 프로젝트로 목적은 앱 개발 전반의 과정을 익히기 위함이지만, 보다 팀원분들과의 소통과 협업 관점에 비중으로 두고 프로젝트를 진행하였습니다.&lt;/p>
&lt;p>프로젝트의 주제는 팀과 팀원의 소개를 담은 앱을 작성하는 것으로, 각자 자신의 소개를 담은 상세 페이지를 작성하고 합치기로 결정하였습니다.
저는 상세 페이지와 더불어 메인 페이지와 각 상세 페이지에서 쓰일 댓글 관리 서비스를 맡았습니다.&lt;/p>
&lt;p>그 중에서도 댓글 관리 서비스를 어떻게 구현했는지 정리해보고자 합니다.&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/nbcamp/introduce-e1if"
target="_blank" rel="noopener noreferrer nofollow"
>프로젝트 저장소&lt;/a
>&lt;/p>
&lt;h2 id="의존성-주입을-위해-인터페이스-적용하기" class="flex items-center gap-3">의존성 주입을 위해 인터페이스 적용하기 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a3%bc%ec%9e%85%ec%9d%84-%ec%9c%84%ed%95%b4-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%ec%a0%81%ec%9a%a9%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>사전캠프에서도 다뤘지만, Service 단에서 &lt;code>shared_preferences&lt;/code>를 사용하기 위해 서비스 파일 내에서 직접 불러와서 사용해주는 방식이 아니라 &lt;code>main.dart&lt;/code>에서 &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수를 주입해주는 방식으로 구현했었습니다.&lt;/p>
&lt;p>허나, 아래처럼 &lt;code>save&lt;/code> 혹은 &lt;code>load&lt;/code> 둘 다 구현해야하는 걸 강제할 수 없었습니다. 또한, &lt;code>shared_preferences&lt;/code>외에 다른 걸로 변경할 때도 번거롭습니다&lt;/p>
&lt;pre>&lt;code class="language-ts">void main() async {
WidgetsFlutterBinding.ensureInitialized();
SharedPreferences pref await SharedPreferences.getInstance();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; MemoService(
save: (String payload) async =&amp;gt; await pref.setString(&amp;quot;memo&amp;quot;, payload),
// load: () async =&amp;gt; pref.getString(&amp;quot;memo&amp;quot;), // 에러를 발생시키지 않음
),
),
],
child: const MyApp(),
));
}
&lt;/code>&lt;/pre>
&lt;p>이를 해결하기 위해 &lt;code>IO&lt;/code> 인터페이스를 구현했습니다.&lt;/p>
&lt;pre>&lt;code class="language-ts">abstract class IO {
Future&amp;lt;void&amp;gt; save(String payload);
Future&amp;lt;String?&amp;gt; load();
}
&lt;/code>&lt;/pre>
&lt;p>dart에서는 인터페이스를 생성하기 위해 &lt;code>abstract class&lt;/code> 키워드를 사용해야 합니다. &lt;code>IO&lt;/code> 인터페이스는 &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수에 대한 명세를 제공합니다. 이를 &lt;code>CommentService&lt;/code>에 적용합니다.&lt;/p>
&lt;pre>&lt;code class="language-ts">class CommentService extends ChangeNotifier {
final Map&amp;lt;String, List&amp;lt;Comment&amp;gt;&amp;gt; _comments = {};
IO? io;
CommentService({this.io}) {
//
}
...
}
&lt;/code>&lt;/pre>
&lt;p>이제 &lt;code>io&lt;/code> 인스턴스를 외부에서 주입해줄 수 있습니다. &lt;code>shared_preferences&lt;/code>를 사용할 예정이므로 &lt;code>SharedPreferencesIO&lt;/code> 클래스를 생성합니다.&lt;/p>
&lt;pre>&lt;code class="language-tsx">class SharedPreferencesIO implements IO {
late Future&amp;lt;SharedPreferences&amp;gt; pref;
SharedPreferencesIO() {
pref = SharedPreferences.getInstance();
}
@override
Future&amp;lt;String?&amp;gt; load() {
return pref.then((pref) =&amp;gt; pref.getString('comments'));
}
@override
Future&amp;lt;void&amp;gt; save(String payload) async {
pref.then((pref) =&amp;gt; pref.setString('comments', payload));
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-ts">void main() async {
WidgetsFlutterBinding.ensureInitialized();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; CommentService(
io: SharedPreferencesIO(),
),
),
],
child: MainApp(),
));
}
&lt;/code>&lt;/pre>
&lt;p>구현한 &lt;code>SharedPreferencesIO&lt;/code> 클래스를 &lt;code>main.dart&lt;/code>에서 &lt;code>CommentService&lt;/code>에 주입해줍니다.&lt;/p>
&lt;p>이로써, &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 모두 구현해야 함을 강제할 수 있게 되었고, &lt;code>IO&lt;/code> 인터페이스를 상속하는 클래스를 여러 개 추가하여 상황에 따라 교체할 수 있어 확장성을 높였습니다.&lt;/p>
&lt;h2 id="데이터-송수신-로직-추상화하기" class="flex items-center gap-3">데이터 송수신 로직 추상화하기 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%86%a1%ec%88%98%ec%8b%a0-%eb%a1%9c%ec%a7%81-%ec%b6%94%ec%83%81%ed%99%94%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;code>CommentService&lt;/code>에서 내부적으로 데이터를 저장하고 불러오는 &lt;code>_save&lt;/code>와 &lt;code>_load&lt;/code> 함수가 있었습니다.&lt;/p>
&lt;pre>&lt;code class="language-ts">Future&amp;lt;void&amp;gt; _save() {
if (save == null) return Future.value();
String payload = jsonEncode(_memos.map((m) =&amp;gt; m.toJson()).toList());
return save!(payload);
}
Future&amp;lt;void&amp;gt; _load() async {
if (load == null) return;
String? payload = await load!();
if (payload == null) return;
_memos.clear();
_memos.addAll(jsonDecode(payload).map((e) =&amp;gt; Memo.fromJson(e)));
}
&lt;/code>&lt;/pre>
&lt;p>여기서 데이터를 String 타입의 payload로 만들거나, 반대로 payload를 데이터로 변환하는 작업을 수행했었습니다.
언뜻보면 null 체크를 하고 종료하는 부분이나 payload를 처리하는 부분은 중복된 부분이기에 별도의 함수로 분리하고 싶었습니다.&lt;/p>
&lt;p>그래서 &lt;code>DataHandler&lt;/code> 추상 클래스르 작성하였습니다.&lt;/p>
&lt;pre>&lt;code class="language-ts">mixin DataHandler {
IO? io;
Future&amp;lt;void&amp;gt; import(String payload);
Future&amp;lt;String&amp;gt; export();
Future&amp;lt;void&amp;gt; save() async {
if (io == null) return Future.value();
var payload = await export();
io?.save(payload);
}
Future&amp;lt;void&amp;gt; load() async {
if (io == null) return Future.value();
var payload = await io!.load();
if (payload == null) return;
import(payload);
}
}
&lt;/code>&lt;/pre>
&lt;p>dart에서 mixin을 활용하여 추상 클래스를 작성할 수 있습니다.
&lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수는 이미 구현되어 있어 동일한 작업을 수행하지만, &lt;code>import&lt;/code>와 &lt;code>export&lt;/code> 함수는 재정의가 필요합니다. 이를 &lt;code>CommentService&lt;/code>에 적용합니다.&lt;/p>
&lt;pre>&lt;code class="language-ts">class UseState {
final List&amp;lt;Comment&amp;gt; comments;
final void Function(List&amp;lt;Comment&amp;gt; Function()) setState;
UseState({
required this.comments,
required this.setState,
});
}
class CommentService extends ChangeNotifier with DataHandler {
final Map&amp;lt;String, List&amp;lt;Comment&amp;gt;&amp;gt; _comments = {};
CommentService({IO? io}) {
this.io = io;
try {
load().then((_) =&amp;gt; notifyListeners());
} catch (error) {
// ignore
}
}
UseState useState(String name) {
return UseState(
comments: List.unmodifiable(_comments[name] ?? []),
setState: (newComments) {
_comments[name] = newComments();
notifyListeners();
save();
},
);
}
@override
Future&amp;lt;void&amp;gt; import(String payload) async {
jsonDecode(payload).forEach((key, values) {
if (values is! List) return;
_comments[key] = values.map((value) =&amp;gt; Comment.fromJson(value)).toList();
});
}
@override
Future&amp;lt;String&amp;gt; export() async {
return jsonEncode(
_comments.map(
(key, values) =&amp;gt; MapEntry(
key,
values.map((comment) =&amp;gt; comment.toJson()).toList(),
),
),
);
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>mixin&lt;/code>을 상속하기 위해선 &lt;code>with&lt;/code> 키워드를 사용해야 합니다. &lt;code>DataHandler&lt;/code>를 상속하면서 &lt;code>CommentService&lt;/code>에서 구현해야 하는 함수들을 재정의합니다.
&lt;code>import&lt;/code>와 &lt;code>export&lt;/code> 함수는 단순히 JSON 형태의 stringify와 parse 작업을 수행합니다. 이로써 상속을 통해 중복 코드를 제거하고 함수의 역할을 분리할 수 있었습니다.&lt;/p></description></item><item><title>[내배캠] 사전캠프</title><link>https://jinyongp.dev/learn/nbcamp/1/</link><pubDate>Tue, Jun 27 11:16:56 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/1/</guid><description>&lt;h2 id="2023년-06월-30일" class="flex items-center gap-3">2023년 06월 30일 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2023%eb%85%84-06%ec%9b%94-30%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>5주차 강의는 HTTP API 요청 방법을 익혔습니다. 다음주는 광고 붙이는건데&amp;hellip; 이번이 마지막일 듯 하네요.&lt;/p>
&lt;h3 id="requesting-network-data" class="flex items-center gap-3">Requesting Network Data &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#requesting-network-data"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>HttpClient로는 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/dio"
target="_blank" rel="noopener noreferrer nofollow"
>dio&lt;/a
> 패키지를 활용했습니다. &lt;br>
책 정보를 불러올 수 있는 Google API를 활용하여 Watcha Pedia 서비스를 구현했습니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">// main.dart
void main() async {
late SharedPreferences pref;
if (!kIsWeb) {
WidgetsFlutterBinding.ensureInitialized();
pref = await SharedPreferences.getInstance();
}
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; BookService(
get: &amp;lt;T&amp;gt;(String query) async {
String url =
'https://www.googleapis.com/books/v1/volumes?q=$query&amp;amp;startIndex=0&amp;amp;maxResults=40';
Response res = await Dio().get(url);
if (res.statusCode != 200) {
throw Exception('http.get error: statusCode= ${res.statusCode}');
}
return res.data['items'];
},
save: (String payload) =&amp;gt; pref.setString('likedBooks', payload),
load: () =&amp;gt; pref.getString('likedBooks'),
),
),
],
child: const MainApp(),
));
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-jsx">// services/book.dart
final Future&amp;lt;T&amp;gt; Function&amp;lt;T&amp;gt;(String url) get;
final FutureOr Function(String payload)? save;
final FutureOr Function()? load;
BookService({required this.get, this.save, this.load}) {
_load().then((_) =&amp;gt; notifyListeners());
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>BookService&lt;/code> 클래스에서 책 정보를 가져오는 함수(&lt;code>get&lt;/code>)와 정보를 저장(&lt;code>save&lt;/code>)하고 불러오는(&lt;code>load&lt;/code>) 함수를 주입할 수 있도록 구현했습니다.&lt;/p>
&lt;h3 id="webview-page" class="flex items-center gap-3">WebView Page &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#webview-page"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>앱 상에서 외부 웹 링크 페이지를 띄우기 위해선 &lt;code>webview_flutter&lt;/code> 패키지를 사용해야 합니다. &lt;br>
책 목록에서 책을 클릭하면 해당 책의 정보를 보여주는 페이지를 띄웁니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">// screens/webview.dart
class WebViewScreen extends StatelessWidget {
WebViewScreen({
super.key,
required this.url,
});
String url;
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
backgroundColor: Colors.grey,
title: Text(url),
),
body: WebView(initialUrl: url),
);
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-jsx">// widgets/book_tile.dart
onTap: () {
Navigator.push(
context,
MaterialPageRoute(
builder: (_) =&amp;gt; WebViewScreen(
url: book.previewLink.replaceFirst('http:', 'https:')),
),
);
},
&lt;/code>&lt;/pre>
&lt;h3 id="watcha-pedia" class="flex items-center gap-3">Watcha Pedia &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#watcha-pedia"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=7a51cd7685929c94d82ca0b707f69516&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>| Dartpad에서 &lt;code>Image.network&lt;/code> 불러오기가 안 되는 문제가 있습니다. &lt;br>
| &lt;code>dio&lt;/code>가 동작하지 않아, &lt;code>http&lt;/code> 모듈로 대체했습니다. &lt;br>
| webview가 동작하지 않습니다.&lt;/p>
&lt;h3 id="project-structure" class="flex items-center gap-3">Project Structure &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#project-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Dartpad에서는 확인할 수 없지만, 프로젝트 구조에 대해 고민해보았습니다.&lt;/p>
&lt;ul>
&lt;li>screens: 화면&lt;/li>
&lt;li>models: 데이터 모델 (자료구조)&lt;/li>
&lt;li>services: 서비스 (비즈니스 로직)&lt;/li>
&lt;li>widgets: 위젯 (컴포넌트)&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-txt">lib/
├── models/
│ └── book.dart
├── screens/
│ ├── home.dart
│ ├── like.dart
│ ├── search.dart
│ └── webview.dart
├── services/
│ └── book.dart
├── widgets/
│ └── book_tile.dart
└── main.dart
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="2023년-06월-29일" class="flex items-center gap-3">2023년 06월 29일 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2023%eb%85%84-06%ec%9b%94-29%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>오늘은 심플한 메모앱을 만들면서 CRUD 기능 구현과 함께 상태 관리 패키지인 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/provider"
target="_blank" rel="noopener noreferrer nofollow"
>Provider&lt;/a
> 그리고 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/shared_preferences"
target="_blank" rel="noopener noreferrer nofollow"
>shared_preferences&lt;/a
>를 이용하여 데이터를 기기에 저장하여 앱을 종료 후 다시 열어도 정보가 유지되도록 기능을 구현했습니다.&lt;/p>
&lt;p>flutter의 패키지는 &lt;a
class="underline-lsre"
href="https://pub.dev/"
target="_blank" rel="noopener noreferrer nofollow"
>pub.dev&lt;/a
>에서 조회할 수 있습니다. 패키지를 설치하기 위해서도 &lt;code>flutter pub&lt;/code> 명령어를 사용합니다.&lt;/p>
&lt;pre>&lt;code class="language-sh">$ flutter pub add provider shared_preferences
&lt;/code>&lt;/pre>
&lt;h3 id="provider" class="flex items-center gap-3">Provider &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#provider"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Provider는 flutter의 상태 관리 패키지로 전역에서 데이터를 쥐고 제어할 수 있는 서비스를 관리해줍니다. &lt;code>Memo&lt;/code> 클래스와 함께 &lt;code>MemoService&lt;/code>를 추가해보았습니다. &lt;code>MemoService&lt;/code>는 메모 목록을 관리하고 CRUD 기능을 제공합니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">// lib/services/memo.dart
class Memo {
Memo({ required this.content });
String content;
}
class MemoService extends ChangeNotifier {
List&amp;lt;Memo&amp;gt; memos = [];
void create(String content) { ... }
void update(int index, String content) { ... }
void delete(int index) { ... }
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>main.dart&lt;/code>의 &lt;code>runApp&lt;/code>에 Provider를 통해 &lt;code>MemoService&lt;/code>를 등록해야 합니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">// lib/main.dart
void main() {
runApp(
MultipleProvider(
providers: [
ChangeNotifierProvider(create: (_) =&amp;gt; MemoService()),
],
child: const MyApp(),
),
);
}
&lt;/code>&lt;/pre>
&lt;p>이제 위젯트리 전체를 &lt;code>Consumer&amp;lt;MemoService&amp;gt;&lt;/code>로 감싸주면 &lt;code>MemoService&lt;/code> 내에서 &lt;code>notifyListeners()&lt;/code>가 호출될 때마다 전체 화면을 다시 그립니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">Widget build(BuildContext context) {
return Consumer&amp;lt;MemoService&amp;gt;(builder: (context, memoService, child) {
return Scaffold(
...
)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Consumer&lt;/code>는 전체 화면을 다시 그리지만, 화면 리렌더링 없이 &lt;code>MemoService&lt;/code>의 인스턴스를 가져오고 싶다면, &lt;code>context.read&amp;lt;MemoService&amp;gt;()&lt;/code>를 통해 가져올 수 있습니다.&lt;/p>
&lt;h3 id="shared_preferences" class="flex items-center gap-3">shared_preferences &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#shared_preferences"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;code>SharedPreferences&lt;/code>는 앱을 껐다 켜도 데이터를 유지할 수 있는 기능을 제공합니다. 다만 &lt;code>SharedPreferences&lt;/code>와 같이 데이터를 유지해줄 수 있는 방법은 다양하므로 언제든 교체할 수 있도록 외부에서 주입해주는 방식으로 구현했습니다.&lt;/p>
&lt;p>&lt;code>MemoService&lt;/code>에 데이터를 저장하고 불러오는 함수를 매개변수를 받을 수 있게끔 추가합니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">class MemoService extends ChangeNotifier {
final List&amp;lt;Memo&amp;gt; _memos = [];
final Future&amp;lt;void&amp;gt; Function(String payload)? save;
final Future&amp;lt;String?&amp;gt; Function()? load;
MemoService({
this.save,
this.load,
}) {
...
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>main.dart&lt;/code>에서 &lt;code>SharedPreferences&lt;/code>의 인스턴스를 생성한 후 데이터를 저장하고 불러오는 함수를 전달합니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">void main() async {
WidgetsFlutterBinding.ensureInitialized();
SharedPreferences pref = await SharedPreferences.getInstance();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; MemoService(
save: (String payload) async =&amp;gt; await pref.setString(&amp;quot;memo&amp;quot;, payload),
load: () async =&amp;gt; pref.getString(&amp;quot;memo&amp;quot;),
),
),
],
child: const MyApp(),
));
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>MemoService&lt;/code>에서 이를 적절하게 저장하고 불러올 때 호출합니다.&lt;/p>
&lt;pre>&lt;code class="language-jsx">String payload = jsonEncode(_memos.map((m) =&amp;gt; m.toJson()).toList());
return save!(payload);
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-jsx">String? payload = await load!();
if (payload == null) return;
_memos.clear();
_memos.addAll(jsonDecode(payload).map((e) =&amp;gt; Memo.fromJson(e)));
&lt;/code>&lt;/pre>
&lt;p>이로써 데이터를 항시 유지할 수 있고, 언제든 &lt;code>main.dart&lt;/code>만 수정하여 데이터 유지 방식을 변경할 수 있습니다.&lt;/p>
&lt;h3 id="my-memo" class="flex items-center gap-3">My Memo &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#my-memo"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=beb656ed3cd6059afac59277a1d6ade8&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>구현한 앱은 다음의 기능을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>하단 &lt;code>+&lt;/code> 아이콘을 눌러 새로운 메모를 생성할 수 있습니다. (메모 작성 페이지로 이동합니다.)&lt;/li>
&lt;li>아무런 내용을 작성하지 않는다면 메모가 추가되지 않습니다.&lt;/li>
&lt;li>내용을 추가하고 뒤로 가기 버튼을 누르면 새로운 메모가 추가됩니다.&lt;/li>
&lt;li>메모를 클릭하여 내용을 수정할 수 있습니다.&lt;/li>
&lt;li>메모를 클릭하고 쓰레기통 아이콘을 눌러 삭제할 수 있습니다.&lt;/li>
&lt;li>변경일 내림차순으로 정렬됩니다. (가장 최근에 변경된 메모가 상단에 위치합니다.)&lt;/li>
&lt;li>고정한 메모를 상단으로 올립니다.&lt;/li>
&lt;li>메모 목록은 앱을 종료 후 재시작해도 유지됩니다.&lt;/li>
&lt;/ul>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://stackoverflow.com/a/69671156"
target="_blank" rel="noopener noreferrer nofollow"
>shared_preferences 때문에 프로젝트가 실행되지 않을 때 대처법&lt;/a
>&lt;/li>
&lt;li>&lt;code>SharedPreferences&lt;/code>의 인스턴스 변수를 전역에서 관리하는 것이 아닌, 데이터를 저장하고 불러오는 함수를 &lt;code>MemoService&lt;/code>에 주입하는 방식으로 리팩토링했습니다. (강의에선 아마 콜백함수에 대한 내용을 학습하지 않았으므로 전역에서 관리하도록 구현하신 것 같습니다.)&lt;/li>
&lt;li>웹에서는 &lt;code>SharedPreferences&lt;/code>의 인스턴스를 생성할 수 없습니다. &lt;code>shared_preferences_web&lt;/code>이 포함되어 있다는데 왜 동작을 안 하는지는 모르겠네요&amp;hellip; &lt;code>import 'package:flutter/foundation.dart' show kIsWeb;&lt;/code>를 불러와서 웹 환경이 아닐 때만 인스턴스를 생성하도록 수정했습니다.&lt;/li>
&lt;li>날짜 포맷팅을 위해 &lt;code>import 'package:intl/intl.dart';&lt;/code> 라이브러리를 추가로 활용했습니다.&lt;/li>
&lt;/ul>
&lt;p>전반으로 리액트나 뷰와 비슷한 느낌이라 기능 구현은 별로 어렵진 않았어서 다트 언어에 더 익숙해질 수 있는 시간이었네요.&lt;/p>
&lt;hr>
&lt;h2 id="2023년-06월-28일" class="flex items-center gap-3">2023년 06월 28일 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2023%eb%85%84-06%ec%9b%94-28%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>오늘은 간단하게 StatelessWidget과 StatefulWidget 그리고 Navigation에 대해 학습했습니다. (이번이 2주차 내용입니다.)&lt;/p>
&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=88bf678d41cdd472009b50585f45304b&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;h3 id="statelesswidget-vs-statefulwidget" class="flex items-center gap-3">StatelessWidget vs. StatefulWidget &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#statelesswidget-vs-statefulwidget"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>StatelessWidget: 상태가 없는 위젯으로 처음에 한번만 &lt;code>build&lt;/code>를 호출합니다.&lt;/li>
&lt;li>StatefulWidget: 상태를 가진 위젯으로 상태가 변경될 때마다 &lt;code>build&lt;/code> 메서드를 호출하여 다시 그립니다.&lt;/li>
&lt;/ul>
&lt;p>위 두 위젯은 보통 상속하여 &lt;code>build&lt;/code> 메서드를 override하는 방식으로 사용합니다. StatefulWidget은 State를 변경하는 클래스가 별도로 필요합니다.&lt;/p>
&lt;h3 id="navigation" class="flex items-center gap-3">Navigation &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#navigation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Navigation은 Route라고 불리는 페이지를 전환하는 것을 의미하고 &lt;code>Navigator&lt;/code> 위젯으로 수행합니다. &lt;code>push&lt;/code>로 페이지를 이동하고 &lt;code>pop&lt;/code>으로 이전 페이지로 이동할 수 있습니다.&lt;/p>
&lt;h3 id="당근마켓daangn-앱-클론" class="flex items-center gap-3">당근마켓(Daangn) 앱 클론 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#%eb%8b%b9%ea%b7%bc%eb%a7%88%ec%bc%93daangn-%ec%95%b1-%ed%81%b4%eb%a1%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=2eef886fac601cbee5bceebdd320a255&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>Stateful한 Feed 위젯을 구현해보았고, 파일을 분리하여 작성해보았습니다. (dartpad는 파일 분리를 지원하지 않아 main.dart에 전부 있습니다&amp;hellip;. &lt;a
class="underline-lsre"
href="https://github.com/dart-lang/dart-pad/issues/2149"
target="_blank" rel="noopener noreferrer nofollow"
>22년도에 올라온 이슈인데...&lt;/a
>)&lt;/p>
&lt;p>여기서 놀랐던 점은 &lt;code>ListView.builder&lt;/code>에 &lt;code>itemCount&lt;/code>를 명시하지 않으면 리스트 요소를 무한히 만들어낸다는 점입니다. 예전에 Recycle Scrolling을 구현하면서 겪은 제한으로는 적어도 요소의 최소 크기가 결정되어 있어야 하고, 요소의 개수를 어느정도 알고 있어야 했는데 그런거 없이 무한정 그려낼 수 있다는 점이 놀라웠습니다.&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://docs.flutter.dev/get-started/flutter-for/android-devs#how-do-i-update-listviews-dynamically"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>에서 &lt;code>ListView&lt;/code> 자체가 내부적으로 요소를 재활용(recycle)하는 동작으로 수행됨을 알 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>The recommended, efficient, and effective way to build a list uses a ListView.Builder. This method is great when you have a dynamic List or a List with very large amounts of data. This is essentially the equivalent of RecyclerView on Android, which automatically recycles list elements for you&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;h3 id="샤잠shazam-앱-클론" class="flex items-center gap-3">샤잠(Shazam) 앱 클론 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#%ec%83%a4%ec%9e%a0shazam-%ec%95%b1-%ed%81%b4%eb%a1%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=252f87e790119799f8be13d1c7875a6d&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>사실 과제는 페이지 세 개 중 하나를 택해 수행하는 건데 그까이꺼 전부 클론해봤습니다. 리팩토링이 필요한 부분이 굉장히 많아보이긴 하지만&amp;hellip; 항상 언젠가 한다는 마음가짐으로&amp;hellip;&lt;/p>
&lt;p>탭 생성 및 이동 방법에 대해서 알게 되었고, 많고 많은 삽질을 하며 스크롤 요소를 어디에 어떻게 배치해야하는지 요령을 습득했습니다.&lt;/p>
&lt;p>가장 난해했던 부분&amp;hellip; overflow&amp;hellip; Scrollable하지 않은 페이지에서 요소가 화면을 벗어나면 &lt;code>A ListView A RenderFlex overflowed by &amp;lt;number&amp;gt; pixels on the bottom.&lt;/code> 에러가 발생합니다. Scrollable하게 만들어주기 위해 &lt;code>SingleChildScrollView&lt;/code>를 이용하거나 &lt;code>ListView&lt;/code>로 감싸줘야하고, &lt;code>Expanded&lt;/code>로 감싸야합니다.&lt;/p>
&lt;hr>
&lt;h2 id="2023년-06월-27일" class="flex items-center gap-3">2023년 06월 27일 &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#2023%eb%85%84-06%ec%9b%94-27%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;a
class="underline-lsre"
href="https://nbcamp-android-ios-unity.oopy.io/0dc0a70c-49ca-499c-b2df-965a2828cca6"
target="_blank" rel="noopener noreferrer nofollow"
>내일배움캠프 iOS 과정&lt;/a
>에 앞서 앱 개발 전반의 이해를 위해 Dart와 Flutter를 학습했습니다.&lt;/p>
&lt;p>지원을 거의 막바지에 하게 되었는데 사전캠프가 이미 진행 도중이었습니다. 다른 분들보다 진도가 느릴까 걱정되었지만, 본 캠프는 9 to 9(&amp;hellip;) 과정이니만큼 사전캠프도 바쁘게 해보고자 최대한 빨리 나가고자 했습니다. (국비 과정이라 하루에 최대 16개만 수강할 수 있는게 아쉽긴 합니다&amp;hellip;)&lt;/p>
&lt;p>강의는 스파르타코딩클럽의 &lt;a
class="underline-lsre"
href="https://spartacodingclub.kr/nb/app"
target="_blank" rel="noopener noreferrer nofollow"
>[왕초보] 플러터(Flutter)로 시작하는 앱개발 종합반&lt;/a
>으로 진행했습니다.&lt;/p>
&lt;h3 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Flutter는 크로스 플랫폼 개발을 위한 프레임워크로 Dart라는 언어로 작성합니다. 동일한 역할을 수행하는 React Native와 비교했을 때 등장 시기는 늦지만 등장부터 빠르게 치고 올라가 Github Star 수는 이미 압도적이라 할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://api.star-history.com/svg?repos=flutter/flutter,facebook/react-native&amp;amp;type=Date" alt="Star History Chart">
&lt;a
class="underline-lsre"
href="https://star-history.com/#flutter/flutter&amp;amp;facebook/react-native"
target="_blank" rel="noopener noreferrer nofollow"
>출처: Github Star History | Flutter vs. React Native&lt;/a
>&lt;/p>
&lt;p>공식 문서 정리에 유튜브 채널까지&amp;hellip;&lt;br>
심지어 성능 또한 네이티브 못지않게 빠르다고 하니 Flutter를 써보지 않을 이유가 없을 듯 합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://api.flutter.dev/"
target="_blank" rel="noopener noreferrer nofollow"
>Flutter Docs&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://www.youtube.com/@flutterdev/videos"
target="_blank" rel="noopener noreferrer nofollow"
>Youtube Flutter Channel&lt;/a
>&lt;/li>
&lt;/ul>
&lt;h3 id="installation" class="flex items-center gap-3">Installation &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#installation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>전 brew로 설치 가능하면 전부 brew로 설치하는 편입니다.&lt;/p>
&lt;pre>&lt;code class="language-sh">$ brew install --cask flutter
&lt;/code>&lt;/pre>
&lt;p>설치 후 &lt;code>flutter&lt;/code> 명령어를 사용할 수 있습니다. &lt;code>doctor&lt;/code> 명령어로 정상적으로 설치됐는지 확인할 수 있습니다.&lt;/p>
&lt;pre>&lt;code class="language-sh">$ flutter doctor -v
Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel stable, 3.10.5, on macOS 13.4.1 22F82 darwin-arm64, locale en-KR)
[!] Android toolchain - develop for Android devices (Android SDK version 34.0.0)
✗ cmdline-tools component is missing
Run `path/to/sdkmanager --install &amp;quot;cmdline-tools;latest&amp;quot;`
See https://developer.android.com/studio/command-line for more details.
✗ Android license status unknown.
Run `flutter doctor --android-licenses` to accept the SDK licenses.
See https://flutter.dev/docs/get-started/install/macos#android-setup for more details.
[✓] Xcode - develop for iOS and macOS (Xcode 14.3.1)
[✓] Chrome - develop for the web
[✓] Android Studio (version 2022.2)
[✓] VS Code (version 1.79.2)
[✓] Connected device (2 available)
[✓] Network resources
! Doctor found issues in 1 category.
&lt;/code>&lt;/pre>
&lt;p>문제없이 실행하기 위해 필요한 도구 중 없는 것을 알려줍니다. 구글에서 제작한 flutter에서 vscode 설치 여부를 확인하고 있는게 좀 당황스럽긴 하지만 그만큼 vscode를 대신할만한 에디터가 없다는거겠죠.&lt;/p>
&lt;p>Android에서 문제가 발생했지만 노트북 용량이 부족하니 그냥 넘어가줍니다.&lt;/p>
&lt;p>VSCode에서는 다음 두 가지 Extension을 설치합니다. Flutter extension을 설치하면 dart는 알아서 설치됩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code"
target="_blank" rel="noopener noreferrer nofollow"
>Dart-Code.dart-code&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter"
target="_blank" rel="noopener noreferrer nofollow"
>Dart-Code.flutter&lt;/a
>&lt;/li>
&lt;/ul>
&lt;p>Command Palette를 열고 &lt;code>Dart: Use Recommended Settings&lt;/code> 명령어를 수행합니다. 추천하는 다트 설정을 vscode 전역 설정에 추가되는데 전 그게 싫어서 Workspace에 &lt;code>.vscode/settings.json&lt;/code> 생성 후 옮겼습니다.&lt;/p>
&lt;pre>&lt;code class="language-sh">$ flutter create hello_flutter --empty
$ cd hello_flutter &amp;amp;&amp;amp; code .
&lt;/code>&lt;/pre>
&lt;p>위 명령어로 프로젝트를 생성한 뒤 flutter 프로젝트를 시작합니다.&lt;/p>
&lt;h3 id="practice" class="flex items-center gap-3">Practice &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#practice"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Flutter는 Widget이라고 불리는 가장 작은 단위의 모듈이 겹겹이 쌓여 전체 프로젝트를 구성합니다. 이를 위젯 트리라 부릅니다.&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets"
target="_blank" rel="noopener noreferrer nofollow"
>Widget Catalog&lt;/a
>에서 다양한 위젯을 제공합니다. &lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets/cupertino"
target="_blank" rel="noopener noreferrer nofollow"
>iOS 스타일의 Cupertino 위젯&lt;/a
>과 &lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets/material"
target="_blank" rel="noopener noreferrer nofollow"
>Android 스타일의 위젯&lt;/a
>을 활용하면 쉽게 네이티브 스타일을 구현할 수 있습니다.&lt;/p>
&lt;p>Command Palette에서 &lt;code>Flutter: Launch Emulator&lt;/code> 명령을 실행하여 에뮬레이터의 실행을 마친 뒤, &lt;code>lib/main.dart&lt;/code> 파일을 열고 &lt;code>main&lt;/code> 함수 상단에 &lt;code>Run&lt;/code>을 클릭하여 프로젝트를 실행합니다.&lt;/p>
&lt;p>첫 주차에선 다양한 위젯을 활용하여 로그인 페이지와 간단한 영화 리스트 페이지를 작성했습니다.&lt;/p>
&lt;h4 id="simple-login-page" class="flex items-center gap-3">Simple Login Page &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#simple-login-page"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=9b26d4ef17f9b7df5f125ccd9f3b976a&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;ul>
&lt;li>사용자가 입력하기 위해 입력폼을 클릭했을 때 올라오는 키보드에 입력폼이 가려지는 문제가 있습니다. &lt;code>ListView&lt;/code>와 같이 scrollable한 위젯에선 발생하지 않는 문제지만 스크롤이 없을 때 발생합니다. 스크롤이 없는 단일 페이지에서 해당 문제가 발생할 시 &lt;code>SingleChildScrollView&lt;/code> 위젯을 사용해야 합니다.&lt;/li>
&lt;/ul>
&lt;h4 id="simple-movie-list" class="flex items-center gap-3">Simple Movie List &lt;i
class="transition opacity-10 hover:opacity-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#simple-movie-list"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=a92d7ac36eae072383b19b8438df0a15&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;ul>
&lt;li>&lt;code>ListView.builder&lt;/code> 위젯으로 리스트를 그릴 수 있습니다. &lt;code>ListView&lt;/code>를 &lt;code>Column&lt;/code>가 내부에서 사용할 때 &lt;code>Vertical viewport was given unbounded height.&lt;/code> 에러가 발생할 수 있는데, &lt;code>ListView&lt;/code>가 항상 최대 공간을 차지하려는 성질이 있어 높이가 무한대로 계산되는 문제가 발생하기 때문입니다. &lt;code>Expanded&lt;/code> 위젯으로 감싸서 문제를 해결할 수 있습니다.&lt;/li>
&lt;/ul></description></item></channel></rss>