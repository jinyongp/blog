<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design-pattern on jinyongp.dev</title><link>https://jinyongp.dev/tags/design-pattern/</link><description>Recent content in design-pattern on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Sat, Aug 12 09:52:24 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/tags/design-pattern/feed.xml" rel="self" type="application/rss+xml"/><item><title>Template Method Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/3/</link><pubDate>Sat, Aug 12 09:52:24 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/3/</guid><description>&lt;p>&lt;strong>Template Method Pattern&lt;/strong>은 특정 알고리즘을 반복적으로 사용하고 있을 때 중복을 제거하기 위하여 적용해볼 수 있습니다. 공통 알고리즘을 묶을 템플릿 메서드를 포함할 추상 클래스를 정의하고, 하위 클래스에서 구체적인 내용을 작성하는 패턴입니다. 해당 패턴을 통해 코드 중복을 제거하고 공통된 알고리즘을 재사용할 수 있습니다. 템플릿 메서드의 변경이 필요하다면 하위 클래스에서 재정의를 통해 인터페이스의 변경 없이 세부 구현을 변경할 수도 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Template Method Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Template Method Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>AbstractClass(추상 클래스): 템플릿 메서드를 정의하고 하위 클래스에서 구현할 메서드를 정의합니다.&lt;/li>
&lt;li>ConcreteClass(구현 클래스): 추상 클래스에서 정의한 추상 메서드를 구현합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 예제를 Swift 코드로 작성해봅시다. AbstractClass 역할을 수행하는 &lt;code>AbstractDisplay&lt;/code> 클래스를 정의합니다. &lt;code>AbstractDisplay&lt;/code> 클래스는 템플릿 메서드인 &lt;code>display&lt;/code> 메서드를 정의하고 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol AbstractDisplay {
func open()
func write()
func close()
}
extension AbstractDisplay {
func display() {
open()
for _ in 0..&amp;lt;5 {
write()
}
close()
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>AbstractClass&lt;/code>는 추상 클래스이므로 구현되어 있는 메서드가 존재하고 인스턴스를 생성할 수 없어야 합니다. &lt;code>protocol&lt;/code>과 &lt;code>extension&lt;/code> 키워드를 활용하여 추상 클래스를 정의하였습니다. &lt;code>display&lt;/code> 탬플릿 메서드를 사용하고 싶다면, &lt;code>AbstractClass&lt;/code>를 채택하고 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class CharDisplay: AbstractDisplay {
private let char: Character
init(char: Character) {
self.char = char
}
func open() {
print(&amp;#34;&amp;lt;&amp;lt;&amp;#34;, terminator: &amp;#34;&amp;#34;)
}
func write() {
print(char, terminator: &amp;#34;&amp;#34;)
}
func close() {
print(&amp;#34;&amp;gt;&amp;gt;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = CharDisplay(char: &amp;#34;H&amp;#34;)
display.display()
// output:
// &amp;lt;&amp;lt;HHHHH&amp;gt;&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>AbstractDisplay&lt;/code>를 채택하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>display&lt;/code> 메서드를 구현하지 않았지만, &lt;code>AbstractDisplay&lt;/code>의 &lt;code>display&lt;/code> 메서드를 사용할 수 있습니다.&lt;/p>
&lt;p>또 다른 클래스를 정의해봅니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class StringDisplay: AbstractDisplay {
private let string: String
private let width: Int
init(string: String) {
self.string = string
self.width = string.count
}
func open() {
printLine()
}
func write() {
print(&amp;#34;|\(string)|&amp;#34;)
}
func close() {
printLine()
}
private func printLine() {
print(&amp;#34;&amp;#43;\(String(repeating: &amp;#34;-&amp;#34;, count: width))&amp;#43;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = StringDisplay(string: &amp;#34;Hello, World&amp;#34;)
display.display()
// output:
// &amp;#43;-------------&amp;#43;
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// &amp;#43;-------------&amp;#43;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇듯 하나의 공통적인 로직을 템플릿화하여 코드의 중복을 없앨 수 있고, 추상 클래스를 상속(채택)하는 방식으로 인하여 상위 클래스 형식의 변수에 하위 클래스 인스턴스 중 어느 것을 대입해도 제대로 동작해야 한다는 원칙인 &lt;code>리스코프 치환 원칙(LSP, Liskov Substitution Principle)&lt;/code>을 만족합니다.&lt;/p>
&lt;p>Swift에서는 &lt;code>extension&lt;/code> 키워드의 존재로 인터페이스를 변경하지 않고도 쉽게 새로운 공통 로직을 언제든 추가할 수 있습니다.&lt;/p></description></item><item><title>Learning Software Design Pattern (Swift)</title><link>https://jinyongp.dev/series/design-pattern/1/</link><pubDate>Wed, Aug 09 09:45:38 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/design-pattern/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>소프트웨어 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하고 직면하는 문제에 대한 해결책입니다. 반복적으로 마주하는 문제에 대한 해결책을 청사진처럼 만들어두고 필요할 때마다 재사용할 수 있습니다.&lt;/p>
&lt;p>각 디자인 패턴마다 어떤 문제를 마주했을 때 적용할 법한 패턴인지 알아보고 Swift 언어를 활용하여 어떻게 구현할 수 있는지 알아보았습니다. 그러므로 Swift의 문법이 포함되어 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>⚠️ 디자인 패턴을 갓 배운 많은 개발자는 문제를 더 간단히 해결할 수 있는 상황임에도 모든 곳에 패턴을 적용해보려는 실수를 범한다고 합니다. 문제를 해결하는데 더 간단한 방법이 있다면 굳이 디자인 패턴을 적용할 필요가 없습니다.&lt;/p>
&lt;/blockquote>
&lt;p>본 시리즈는 &lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>을 참고하여 작성했습니다. 본 서적에선 GoF의 23가지 디자인 패턴을 다루고 있습니다. 하지만 GoF의 분류 체계(생성, 구조, 행위)를 따르지 않고, 다른 관점으로 분류하고 있으므로 이를 따라서 작성했습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns"
target="_blank" rel="noopener noreferrer nofollow"
>Design pattern - Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문 : 쉽게 배우는 GoF의 23가지 디자인 패턴&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns/swift"
target="_blank" rel="noopener noreferrer nofollow"
>Design Pattern in Swift&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Adapter Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/2/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/2/</guid><description>&lt;p>&lt;strong>Adapter Pattern&lt;/strong>을 활용하면 외부 라이브러리의 인터페이스와 내가 사용하고자 하는 인터페이스가 호환되지 않을 때, 중간에 Adapter를 추가하는 방법으로 호환성을 확보할 수 있습니다. Wrapper Pattern으로 불리기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Adapter Pattern&lt;/code>은 GoF의 분류 체계에서 구조(Structural) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Adapter Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Target(대상): 서비스 내에서 사용 중인 인터페이스입니다.&lt;/li>
&lt;li>Client(의뢰자): Target을 사용하는 클래스입니다.&lt;/li>
&lt;li>Adaptee(적응 대상자): Target과 호환되지 않는 인터페이스입니다.&lt;/li>
&lt;li>Adapter(적응자): Adaptee를 Target으로 변환하는 클래스입니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Adapter를 구현하는 방법은 상속을 이용한 방법과 위임(인스턴스)을 이용한 방법으로 나뉘지만 &lt;code>Is-A&lt;/code>보단 &lt;code>Has-A&lt;/code>가 더 좋은 방법이므로 위임을 이용한 방법을 사용하도록 합니다. &lt;a
class="underline-lsre"
href="https://www.google.com/search?q=is-a&amp;#43;has-a&amp;#43;relationship"
target="_blank" rel="noopener noreferrer nofollow"
>Is-A Has-A Relationship&lt;/a
>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>예시를 통해 자세히 알아보겠습니다. 시스템 내에서 사용 중인 로깅 인터페이스가 있다고 가정해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Logger {
func log(message: String)
func warn(message: String)
func error(message: String)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Logger&lt;/code>는 Adapter Pattern의 구성 요소 중 Target 역할을 수행합니다. 이를 채택하는 클래스 &lt;code>MyLogger&lt;/code>를 구현합니다. &lt;code>MyLogger&lt;/code>는 Swift의 &lt;code>print()&lt;/code>함수를 이용하여 Termianl 환경에서 로그를 출력합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct MyLogger: Logger {
func log(message: String) {
print(&amp;#34;[LOG] \(message)&amp;#34;)
}
func warn(message: String) {
print(&amp;#34;[WARN] \(message)&amp;#34;)
}
func error(message: String) {
print(&amp;#34;[ERROR] \(message)&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Client 역할을 수행하는 &lt;code>App&lt;/code> 클래스에서 Logger 구현체를 주입받아 시스템 전체에 걸쳐 사용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// App.swift
final class App {
private let logger: Logger
init(logger: Logger) {
self.logger = logger
}
func doSomething() {
logger.log(message: &amp;#34;doSomething&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// main.swift
let app = App(logger: MyLogger())
app.doSomething()
// output:
// [LOG] doSomething&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>MyLogger&lt;/code>는 swift의 &lt;code>print()&lt;/code> 함수에 의존하고 있습니다. 이제 외부 라이브러리를 통해 terminal 환경이 아닌 외부로 로그 정보를 보내려고 합니다. 외부 라이브러리 &lt;code>ExternalLogger&lt;/code>는 다음 인터페이스를 제공합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">enum LogLevel {
case debug
case info
case warn
case error
}
struct ExternalLogger {
func log(level: LogLevel, message: String) {
// 로그를 외부로 전송합니다.
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>언뜻 보기에도 &lt;code>ExternalLogger&lt;/code>는 &lt;code>Logger&lt;/code>와 호환되지 않는 것을 알 수 있습니다. 이럴 때 Adapter 클래스를 추가하여 호환성을 확보할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct ExternalLoggerAdapter: Logger {
private let logger = ExternalLogger()
func log(message: String) {
logger.log(level: .info, message: message)
}
func warn(message: String) {
logger.log(level: .warn, message: message)
}
func error(message: String) {
logger.log(level: .error, message: message)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let app = App(logger: ExternalLoggerAdapter())
app.doSomething()&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇게 Adapter 역할을 수행하는 중간자 클래스를 추가하여 세부 구현에 어떠한 변경도 없이 세부 구현에 어떠한 변경도 없이 확장에 성공하였습니다. 이런 식으로 Adapter 구조체를 추가하면 변경이 아닌 확장(OCP - 개방 폐쇄 원칙)이 되어 Side Effect도 없을 뿐더러 Unit Test를 작성하기도 쉬워집니다.&lt;/p></description></item><item><title>Iterator Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/1/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/1/</guid><description>&lt;p>&lt;strong>Iterator Pattern&lt;/strong>은 순회 로직을 순회자(Iterator) 객체로 분리합니다. 이러한 추상화 작업을 통해 순회 불가능한 객체더라도 인터페이스만 구현한다면 순회 가능한 객체로 만들 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Iterator Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>예를 들어, 자료구조 중 배열은 메모리 구조의 특징 덕분에 0..&amp;lt;배열크기 범위로 인덱스를 증가시키며 요소에 접근할 수 있습니다. 허나 리스트의 경우엔 순회 로직을 직접 구현하지 않는 한 인덱스를 이용한 순회가 불가능합니다. 리스트 클래스를 순회 가능한 객체로 만들기 위해선 별도의 구현을 추가해야 합니다. 여기서 Iterator Pattern을 적용한다면 리스트 클래스의 세부 구현을 변경하지 않고도 순회 가능한 객체로 확장할 수 있습니다.&lt;/p>
&lt;p>Iterator Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Iterator(반복자): 순회 로직을 추상화한 인터페이스입니다. 다음 요소를 반환하는 &lt;code>next()&lt;/code> 메서드와 현재 요소가 마지막 요소인지 확인하는 &lt;code>hasNext()&lt;/code> 메서드를 포함합니다.&lt;/li>
&lt;li>ConcreteIterator(구체적인 반복자): Iterator 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;li>Aggregate(집합체): 순회 가능한 객체임을 나타내는 인터페이스입니다. ConcreteIterator 객체를 생성하여 반환하는 &lt;code>makeIterator()&lt;/code> 메서드를 포함하기도 합니다. (aka. Iterable)&lt;/li>
&lt;li>ConcreteAggregate(구체적인 집합체): Aggregate 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 Iterator Pattern 예제를 Swift로 작성해보았습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Iterable&amp;lt;Element&amp;gt; {
associatedtype Element where Element == Iter.Element
associatedtype Iter: Iterator
func makeIterator() -&amp;gt; Iter;
}
protocol Iterator&amp;lt;Element&amp;gt; {
associatedtype Element
mutating func next() -&amp;gt; Element?
}
struct Book {
private(set) var name: String
}
struct BookShelf {
private var books: [Book] = []
var count: Int { books.count }
func book(at index: Int) -&amp;gt; Book {
return books[index]
}
mutating func add(book: Book) {
books.append(book)
}
}
extension BookShelf: Iterable {
typealias Element = Book
typealias Iter = BookShelfIterator
func makeIterator() -&amp;gt; Iter {
return BookShelfIterator(self)
}
}
struct BookShelfIterator: Iterator {
typealias Element = Book
private let bookShelf: BookShelf
private var index: Int
init(_ bookShelf: BookShelf) {
self.bookShelf = bookShelf
index = 0
}
mutating func next() -&amp;gt; Element? {
if bookShelf.count &amp;gt; index {
defer { index &amp;#43;= 1 }
return bookShelf.book(at: index)
}
return nil
}
}
var bookShelf = BookShelf()
bookShelf.add(book: Book(name: &amp;#34;Book1&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book2&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book3&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book4&amp;#34;))
var iterator = bookShelf.makeIterator()
while let book = iterator.next() {
print(book.name)
}
// output:
// Book1
// Book2
// Book3
// Book4&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>Swift에서는 &lt;code>nil&lt;/code> 값을 제공하므로 &lt;code>hasNext()&lt;/code> 메서드 대신 &lt;code>next()&lt;/code> 메서드가 &lt;code>nil&lt;/code>을 반환하면 순회를 종료하도록 구현합니다.&lt;/p>
&lt;/blockquote>
&lt;p>코드에 따르면 각 구조체는 다음 역할을 따릅니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Iterator&lt;/code>: Iterator&lt;/li>
&lt;li>&lt;code>BookShelfIterator&lt;/code>: ConcreteIterator&lt;/li>
&lt;li>&lt;code>Iterable&lt;/code>: Aggregate&lt;/li>
&lt;li>&lt;code>BookShelf&lt;/code>: ConcreteAggregate&lt;/li>
&lt;/ul>
&lt;p>이렇게 순회를 담당하는 로직을 별도의 클래스로 분리하여 확장성을 높이는 것이 Iterator Pattern의 핵심입니다. 인터페이스를 활용한 이러한 확장성 및 다형성 덕분에 &lt;code>Iterator&lt;/code> 인터페이스만 구현하고 있으면 모든 순회가 필요한 로직에 적용할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이미 Swift에서는 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol&lt;/a
> 프로토콜을 제공하여 어떠한 클래스든 &lt;code>IteratorProtocol&lt;/code>을 채택하여 &lt;code>for in&lt;/code> 구문에 활용할 수 있습니다. (Aggregate 역할을 &lt;code>Sequence&lt;/code> 프로토콜이 수행합니다.)&lt;/p>
&lt;p>Apple 공식 문서의 예제를 가져왔습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct Countdown: Sequence {
let start: Int
func makeIterator() -&amp;gt; CountdownIterator {
return CountdownIterator(self)
}
}
struct CountdownIterator: IteratorProtocol {
let countdown: Countdown
var times = 0
init(_ countdown: Countdown) {
self.countdown = countdown
}
mutating func next() -&amp;gt; Int? {
let nextNumber = countdown.start - times
guard nextNumber &amp;gt; 0 else { return nil }
times &amp;#43;= 1
return nextNumber
}
}
let countdown3 = Countdown(start: 3)
for count in countdown3 {
print(&amp;#34;\(count)...&amp;#34;)
}
// output:
// 3..
// 2..
// 1..&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Countdown&lt;/code>은 ConcreteAggregate 역할을 수행하며, &lt;code>CountdownIterator&lt;/code>는 ConcreteIterator 역할을 수행합니다. 이렇게 순회 로직을 분리하는 방식으로 Collection 형식이 아니라 하더라도 순회 로직을 추가함으로서 순회 가능한 객체를 만들 수 있습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/design-patterns/iterator"
target="_blank" rel="noopener noreferrer nofollow"
>Iterator Pattern : Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol : Apple&lt;/a
>&lt;/li>
&lt;/ul></description></item></channel></rss>