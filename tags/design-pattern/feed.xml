<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design-pattern on jinyongp.dev</title><link>https://jinyongp.dev/tags/design-pattern/</link><description>Recent content in design-pattern on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Wed, Aug 09 09:45:38 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/tags/design-pattern/feed.xml" rel="self" type="application/rss+xml"/><item><title>Learning Software Design Pattern (Swift)</title><link>https://jinyongp.dev/series/design-pattern/1/</link><pubDate>Wed, Aug 09 09:45:38 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/design-pattern/1/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>소프트웨어 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하고 직면하는 문제에 대한 해결책입니다. 반복적으로 마주하는 문제에 대한 해결책을 청사진처럼 만들어두고 필요할 때마다 재사용할 수 있습니다.&lt;/p>
&lt;p>각 디자인 패턴마다 어떤 문제를 마주했을 때 적용할 법한 패턴인지 알아보고 Swift 언어를 활용하여 어떻게 구현할 수 있는지 알아보았습니다. 그러므로 Swift의 문법이 포함되어 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>⚠️ 디자인 패턴을 갓 배운 많은 개발자는 문제를 더 간단히 해결할 수 있는 상황임에도 모든 곳에 패턴을 적용해보려는 실수를 범한다고 합니다. 문제를 해결하는데 더 간단한 방법이 있다면 굳이 디자인 패턴을 적용할 필요가 없습니다.&lt;/p>
&lt;/blockquote>
&lt;p>본 시리즈는 &lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>
을 참고하여 작성했습니다. 본 서적에선 GoF의 23가지 디자인 패턴을 다루고 있습니다. 하지만 GoF의 분류 체계(생성, 구조, 행위)를 따르지 않고, 다른 관점으로 분류하고 있으므로 이를 따라서 작성했습니다.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns"
target="_blank" rel="noopener noreferrer nofollow"
>Design pattern - Refactoring Guru&lt;/a
>
&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문 : 쉽게 배우는 GoF의 23가지 디자인 패턴&lt;/a
>
&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns/swift"
target="_blank" rel="noopener noreferrer nofollow"
>Design Pattern in Swift&lt;/a
>
&lt;/li>
&lt;/ul></description></item><item><title>Adapter Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/2/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/2/</guid><description>&lt;p>&lt;strong>Adapter Pattern&lt;/strong>을 활용하면 외부 라이브러리의 인터페이스와 내가 사용하고자 하는 인터페이스가 호환되지 않을 때, 중간에 Adapter를 추가하는 방법으로 호환성을 확보할 수 있습니다. Wrapper Pattern으로 불리기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Adapter Pattern&lt;/code>은 GoF의 분류 체계에서 구조(Structural) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Adapter Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Target(대상): 서비스 내에서 사용 중인 인터페이스입니다.&lt;/li>
&lt;li>Client(의뢰자): Target을 사용하는 클래스입니다.&lt;/li>
&lt;li>Adaptee(적응 대상자): Target과 호환되지 않는 인터페이스입니다.&lt;/li>
&lt;li>Adapter(적응자): Adaptee를 Target으로 변환하는 클래스입니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Adapter를 구현하는 방법은 상속을 이용한 방법과 위임(인스턴스)을 이용한 방법으로 나뉘지만 &lt;code>Is-A&lt;/code>보단 &lt;code>Has-A&lt;/code>가 더 좋은 방법이므로 위임을 이용한 방법을 사용하도록 합니다. &lt;a
class="underline-lsre"
href="https://www.google.com/search?q=is-a&amp;#43;has-a&amp;#43;relationship"
target="_blank" rel="noopener noreferrer nofollow"
>Is-A Has-A Relationship&lt;/a
>
&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>예시를 통해 자세히 알아보겠습니다. 시스템 내에서 사용 중인 로깅 인터페이스가 있다고 가정해봅시다.&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Logger {
func log(message: String)
func warn(message: String)
func error(message: String)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Logger&lt;/code>는 Adapter Pattern의 구성 요소 중 Target 역할을 수행합니다. 이를 채택하는 클래스 &lt;code>MyLogger&lt;/code>를 구현합니다. &lt;code>MyLogger&lt;/code>는 Swift의 &lt;code>print()&lt;/code>함수를 이용하여 Termianl 환경에서 로그를 출력합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">struct MyLogger {
func log(message: String) {
print(&amp;quot;[LOG] \(message)&amp;quot;)
}
func warn(message: String) {
print(&amp;quot;[WARN] \(message)&amp;quot;)
}
func error(message: String) {
print(&amp;quot;[ERROR] \(message)&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>Client 역할을 수행하는 &lt;code>App&lt;/code> 클래스에서 Logger 구현체를 주입받아 시스템 전체에 걸쳐 사용합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">// App.swift
final class App {
private let logger: Logger
init(logger: Logger) {
self.logger = logger
}
func doSomething() {
logger.log(message: &amp;quot;doSomething&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-swift">// main.swift
let app = App(logger: MyLogger())
app.doSomething()
&lt;/code>&lt;/pre>
&lt;p>&lt;code>MyLogger&lt;/code>는 swift의 &lt;code>print()&lt;/code> 함수에 의존하고 있습니다. 이제 외부 라이브러리를 통해 terminal 환경이 아닌 외부로 로그 정보를 보내려고 합니다. 외부 라이브러리 &lt;code>ExternalLogger&lt;/code>는 다음 인터페이스를 제공합니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">enum LogLevel {
case debug
case info
case warn
case error
}
struct ExternalLogger {
func log(level: LogLevel, message: String) {
// 로그를 외부로 전송합니다.
}
}
&lt;/code>&lt;/pre>
&lt;p>언뜻 보기에도 &lt;code>ExternalLogger&lt;/code>는 &lt;code>Logger&lt;/code>와 호환되지 않는 것을 알 수 있습니다. 이럴 때 Adapter 클래스를 추가하여 호환성을 확보할 수 있습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">struct ExternalLoggerAdapter: Logger {
private let logger = ExternalLogger()
func log(message: String) {
logger.log(level: .info, message: message)
}
func warn(message: String) {
logger.log(level: .warn, message: message)
}
func error(message: String) {
logger.log(level: .error, message: message)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-swift">let app = App(logger: ExternalLoggerAdapter())
app.doSomething()
&lt;/code>&lt;/pre>
&lt;p>이렇게 Adapter 역할을 수행하는 중간자 클래스를 추가하여 세부 구현에 어떠한 변경도 없이 세부 구현에 어떠한 변경도 없이 확정에 성공하였습니다. 이런 식으로 Adapter 구조체를 추가하면 변경이 아닌 확장(OCP - 개방 폐쇄 원칙)이 되어 Side Effect도 없을 뿐더러 Unit Test를 작성하기도 쉬워집니다.&lt;/p></description></item><item><title>Iterator Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/1/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/1/</guid><description>&lt;p>&lt;strong>Iterator Pattern&lt;/strong>은 순회 로직을 순회자(Iterator) 객체로 분리합니다. 이러한 추상화 작업을 통해 순회 불가능한 객체더라도 인터페이스만 구현한다면 순회 가능한 객체로 만들 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Iterator Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>예를 들어, 자료구조 중 배열은 메모리 구조의 특징 덕분에 0..&amp;lt;배열크기 범위로 인덱스를 증가시키며 요소에 접근할 수 있습니다. 허나 리스트의 경우엔 순회 로직을 직접 구현하지 않는 한 인덱스를 이용한 순회가 불가능합니다. 리스트 클래스를 순회 가능한 객체로 만들기 위해선 별도의 구현을 추가해야 합니다. 여기서 Iterator Pattern을 적용한다면 리스트 클래스의 세부 구현을 변경하지 않고도 순회 가능한 객체로 확장할 수 있습니다.&lt;/p>
&lt;p>Iterator Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Iterator(반복자): 순회 로직을 추상화한 인터페이스입니다. 다음 요소를 반환하는 &lt;code>next()&lt;/code> 메서드와 현재 요소가 마지막 요소인지 확인하는 &lt;code>hasNext()&lt;/code> 메서드를 포함합니다.&lt;/li>
&lt;li>ConcreteIterator(구체적인 반복자): Iterator 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;li>Aggregate(집합체): 순회 가능한 객체임을 나타내는 인터페이스입니다. ConcreteIterator 객체를 생성하여 반환하는 &lt;code>makeIterator()&lt;/code> 메서드를 포함하기도 합니다. (aka. Iterable)&lt;/li>
&lt;li>ConcreteAggregate(구체적인 집합체): Aggregate 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>
의 Iterator Pattern 예제를 Swift로 작성해보았습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Iterable&amp;lt;Element&amp;gt; {
associatedtype Element where Element == Iter.Element
associatedtype Iter: Iterator
func makeIterator() -&amp;gt; Iter;
}
protocol Iterator&amp;lt;Element&amp;gt; {
associatedtype Element
mutating func next() -&amp;gt; Element?
}
struct Book {
private(set) var name: String
}
struct BookShelf {
private var books: [Book] = []
var count: Int { books.count }
func book(at index: Int) -&amp;gt; Book {
return books[index]
}
mutating func add(book: Book) {
books.append(book)
}
}
extension BookShelf: Iterable {
typealias Element = Book
typealias Iter = BookShelfIterator
func makeIterator() -&amp;gt; Iter {
return BookShelfIterator(self)
}
}
struct BookShelfIterator: Iterator {
typealias Element = Book
private let bookShelf: BookShelf
private var index: Int
init(_ bookShelf: BookShelf) {
self.bookShelf = bookShelf
index = 0
}
mutating func next() -&amp;gt; Element? {
if bookShelf.count &amp;gt; index {
defer { index += 1 }
return bookShelf.book(at: index)
}
return nil
}
}
var bookShelf = BookShelf()
bookShelf.add(book: Book(name: &amp;quot;Book1&amp;quot;))
bookShelf.add(book: Book(name: &amp;quot;Book2&amp;quot;))
bookShelf.add(book: Book(name: &amp;quot;Book3&amp;quot;))
bookShelf.add(book: Book(name: &amp;quot;Book4&amp;quot;))
var iterator = bookShelf.makeIterator()
while let book = iterator.next() {
print(book.name)
}
// output:
// Book1
// Book2
// Book3
// Book4
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>Swift에서는 &lt;code>nil&lt;/code> 값을 제공하므로 &lt;code>hasNext()&lt;/code> 메서드 대신 &lt;code>next()&lt;/code> 메서드가 &lt;code>nil&lt;/code>을 반환하면 순회를 종료하도록 구현합니다.&lt;/p>
&lt;/blockquote>
&lt;p>코드에 따르면 각 구조체는 다음 역할을 따릅니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Iterator&lt;/code>: Iterator&lt;/li>
&lt;li>&lt;code>BookShelfIterator&lt;/code>: ConcreteIterator&lt;/li>
&lt;li>&lt;code>Iterable&lt;/code>: Aggregate&lt;/li>
&lt;li>&lt;code>BookShelf&lt;/code>: ConcreteAggregate&lt;/li>
&lt;/ul>
&lt;p>이렇게 순회를 담당하는 로직을 별도의 클래스로 분리하여 확장성을 높이는 것이 Iterator Pattern의 핵심입니다. 인터페이스를 활용한 이러한 확장성 및 다형성 덕분에 &lt;code>Iterator&lt;/code> 인터페이스만 구현하고 있으면 모든 순회가 필요한 로직에 적용할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이미 Swift에서는 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol&lt;/a
>
프로토콜을 제공하여 어떠한 클래스든 &lt;code>IteratorProtocol&lt;/code>을 채택하여 &lt;code>for in&lt;/code> 구문에 활용할 수 있습니다. (Aggregate 역할을 &lt;code>Sequence&lt;/code> 프로토콜이 수행합니다.)&lt;/p>
&lt;p>Apple 공식 문서의 예제를 가져왔습니다.&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Countdown: Sequence {
let start: Int
func makeIterator() -&amp;gt; CountdownIterator {
return CountdownIterator(self)
}
}
struct CountdownIterator: IteratorProtocol {
let countdown: Countdown
var times = 0
init(_ countdown: Countdown) {
self.countdown = countdown
}
mutating func next() -&amp;gt; Int? {
let nextNumber = countdown.start - times
guard nextNumber &amp;gt; 0 else { return nil }
times += 1
return nextNumber
}
}
let countdown3 = Countdown(start: 3)
for count in countdown3 {
print(&amp;quot;\(count)...&amp;quot;)
}
// output:
// 3..
// 2..
// 1..
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Countdown&lt;/code>은 ConcreteAggregate 역할을 수행하며, &lt;code>CountdownIterator&lt;/code>는 ConcreteIterator 역할을 수행합니다. 이렇게 순회 로직을 분리하는 방식으로 Collection 형식이 아니라 하더라도 순회 로직을 추가함으로서 순회 가능한 객체를 만들 수 있습니다.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/design-patterns/iterator"
target="_blank" rel="noopener noreferrer nofollow"
>Iterator Pattern : Refactoring Guru&lt;/a
>
&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol : Apple&lt;/a
>
&lt;/li>
&lt;/ul></description></item></channel></rss>