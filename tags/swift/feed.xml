<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift on jinyongp.dev</title><link>https://jinyongp.dev/tags/swift/</link><description>Recent content in swift on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Wed, Sep 13 02:37:04 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/tags/swift/feed.xml" rel="self" type="application/rss+xml"/><item><title>SwiftFormat로 코드 품질 높이기</title><link>https://jinyongp.dev/posts/xcode/1/</link><pubDate>Wed, Sep 13 02:37:04 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/xcode/1/</guid><description>&lt;h2 id="들어가기-전에" class="flex items-center gap-3">들어가기 전에 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="들어가기 전에" href="#%eb%93%a4%ec%96%b4%ea%b0%80%ea%b8%b0-%ec%a0%84%ec%97%90"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Swift 언어로 개발하며 애플이 제공하는 프레임워크나 라이브러리를 활용하기 위해서 Xcode IDE 말고는 다른 선택지가 없습니다. 웹 개발을 해오면서 항상 VSCode만 사용해왔었는데, iOS 앱 개발을 시작하고 Xcode에 적응하면서 여러가지 불편한 점이 있었습니다.&lt;/p>
&lt;p>그 중 하나는 VSCode에서 기본으로 제공되는 Code Formatter가 Xcode에는 없다는 건데요. 모든 코드를 드래그한 뒤, &lt;kbd>Ctrl ⌃&lt;/kbd>
+ &lt;kbd>I&lt;/kbd>
를 눌러 Tab Indent를 맞추는 정도의 포맷팅은 가능하지만 공백을 없애거나 만들어주는 등 세부적인 format 기능을 설정할 수 없고 제공하지 않는게 참 불편했습니다. 이를 해소하기 위해 Swift 언어의 formatter 도구를 찾아봤습니다.&lt;/p>
&lt;p>Code Formatter는 코드를 정해진 규칙(널리 쓰이는 컨벤션)에 맞춰 자동으로 정렬해주는 기능을 제공하는 도구입니다. 웹 개발 생태계에서는 다양한 formatter를 사용했었고 더 나아가 코드의 문제를 미리 찾고 방지할 수 있도록 도와주는 linter까지 활용하며 코드의 품질을 높였습니다. Swift에서도 마찬가지로 이러한 기능을 제공하는 도구가 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftFormat&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/realm/SwiftLint"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftLint&lt;/a
>&lt;/li>
&lt;/ul>
&lt;p>SwiftLint에 대해선 나중에 기회가 된다면 알아보도록 하고, 이 글에선 SwiftFormat을 설치하는 방법과 Xcode에서 사용하는 방법에 대해 알아보려고 합니다.&lt;/p>
&lt;h2 id="swiftformat-설치하기" class="flex items-center gap-3">SwiftFormat 설치하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="SwiftFormat 설치하기" href="#swiftformat-%ec%84%a4%ec%b9%98%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftFormat&lt;/a
> 저장소에서 설치 가능한 패키지는 기본적으로 Command Line 도구로 제공하고 있습니다. Xcode 용 &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat#xcode-source-editor-extension"
target="_blank" rel="noopener noreferrer nofollow"
>설치 가이드&lt;/a
>를 따라 설치해보도록 하겠습니다.&lt;/p>
&lt;p>MacOS를 사용하는 개발자라면 &lt;a
class="underline-lsre"
href="https://brew.sh/"
target="_blank" rel="noopener noreferrer nofollow"
>Homebrew&lt;/a
>를 반드시 사용하고 계시리라 생각합니다. &lt;code>brew&lt;/code> 명령어로 설치해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ brew install --cask swiftformat-for-xcode&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Homebrew를 사용하고 있지 않다면, 저장소의 &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat/releases"
target="_blank" rel="noopener noreferrer nofollow"
>Releases&lt;/a
>에서 설치한 다음 Applications 폴더로 옮겨줍니다.&lt;/p>
&lt;h2 id="swiftformat-적용하기" class="flex items-center gap-3">SwiftFormat 적용하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="SwiftFormat 적용하기" href="#swiftformat-%ec%a0%81%ec%9a%a9%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>설치를 완료하셨다면 Spotlight를 열고 &lt;code>SwiftFormat for Xcode&lt;/code>를 한번 실행합니다. (혹은, Applications 폴더에서 직접 실행해주세요.)&lt;/p>
&lt;blockquote>
&lt;p>저는 기본으로 제공되는 Spotlight 대신 &lt;a
class="underline-lsre"
href="https://raycast.com/"
target="_blank" rel="noopener noreferrer nofollow"
>Raycast&lt;/a
>를 사용하고 있습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Open SwiftFormat using Spotlight" src="https://jinyongp.dev/image/posts/xcode/1/open-swiftformat.png" />
&lt;img class="mx-auto" alt="SwiftFormat for Xcode - About" src="https://jinyongp.dev/image/posts/xcode/1/swiftformat-for-xcode-about.png" />
&lt;/div>
&lt;p>실행하며 프로그램이 열리면 About 화면에서 설치 방법을 보여주고 있습니다. 이를 따라 설치를 진행해보겠습니다.&lt;/p>
&lt;p>다시 Spotlight를 열어 MacOS의 System Settings(설정)를 열고 Extensions(확장)를 검색합니다.&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Open Extensions Setting" src="https://jinyongp.dev/image/posts/xcode/1/open-extensions.png" />
&lt;img class="mx-auto" alt="Activate SwiftFormat on Settings" src="https://jinyongp.dev/image/posts/xcode/1/activate-swiftformat.png" />
&lt;/div>
&lt;p>Xcode Source Editor를 클릭하면 SwiftFormat 항목이 있습니다. 체크하여 활성화합니다.&lt;/p>
&lt;p>이제 Xcode를 실행하면 상단 Menubar의 Editor 최하단에 SwiftFormat 항목이 추가된 걸 확인할 수 있습니다. Format File를 클릭하면 현재 열려있는 파일을 포맷팅합니다.&lt;/p>
&lt;h2 id="단축키-등록하기" class="flex items-center gap-3">단축키 등록하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="단축키 등록하기" href="#%eb%8b%a8%ec%b6%95%ed%82%a4-%eb%93%b1%eb%a1%9d%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>매번 Format File을 실행할 수는 없으니, 단축키를 등록하여 해당 명령어를 손쉽게 실행할 수 있도록 해보겠습니다.&lt;/p>
&lt;p>설정을 열고 keyboard를 검색한 뒤, Keyboard Shortcuts -&amp;gt; App Shortcuts를 클릭합니다.&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Search keyboard" src="https://jinyongp.dev/image/posts/xcode/1/search-keyboard.png" />
&lt;img class="mx-auto" alt="Open App Shortcuts" src="https://jinyongp.dev/image/posts/xcode/1/open-app-shortcuts.png" />
&lt;/div>
&lt;p>&lt;kbd>+&lt;/kbd>
버튼을 눌러 새로운 단축키를 추가합니다.&lt;/p>
&lt;ul>
&lt;li>Application을 Xcode.app으로 설정합니다.&lt;/li>
&lt;li>Menu Title을 &lt;code>Editor-&amp;gt;SwiftFormat-&amp;gt;Format File&lt;/code>을 오타에 주의하며 작성합니다.&lt;/li>
&lt;li>Keyboard Shortcuts를 클릭하고 원하는 단축키를 누릅니다. 저는 &lt;kbd>⌘&lt;/kbd>
+ &lt;kbd>S&lt;/kbd>
로 설정했습니다. (사용 중인 Xcode의 기존 단축키와 겹치는지 확인해주세요.)&lt;/li>
&lt;li>&lt;code>Done&lt;/code>를 눌러 저장합니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img class="mx-auto" alt="Set Xcode Shortcut" src="https://jinyongp.dev/image/posts/xcode/1/set-xcode-shortcut.png" />
&lt;/p>
&lt;p>마지막으로 Xcode를 재실행하여 아래처럼 망가진 코드를 작성한 뒤, 설정했던 단축키를 눌러 포맷팅이 잘 동작하는지 확인해봅니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// before
func foo () {
print (&amp;#34;test&amp;#34;)}
// ... ⌘ &amp;#43; S
// after
func foo() {
print(&amp;#34;test&amp;#34;)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>엉망으로 작성되어 있던 코드가 깔끔하게 정렬된 것을 확인할 수 있습니다.&lt;/p>
&lt;h2 id="마치며" class="flex items-center gap-3">마치며 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="마치며" href="#%eb%a7%88%ec%b9%98%eb%a9%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>SwiftFormat for Xcode의 rules 탭을 선택하면 세부적인 규칙 설정이 가능합니다. 세세한 규칙 설정에 따라 단순히 간격 조정이나 괄호 유무 뿐만 아니라 Swift의 문법에 따라 불필요한 코드를 제거해주기도 하고, 컨벤션에 맞게 코드를 수정해주기도 합니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="SwiftFormat for Xcode - Rules" src="https://jinyongp.dev/image/posts/xcode/1/swiftformat-for-xcode-rules.png" />
&lt;/p>
&lt;p>한 예로 stringOutlet이라는 설정이 있는데, 기본적으로 활성화되어 있습니다. 이 설정은 &lt;code>@IBOutlet&lt;/code>에서 &lt;code>weak&lt;/code> 키워드를 제거합니다. &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat/issues/740#issuecomment-692558057"
target="_blank" rel="noopener noreferrer nofollow"
>해당 이슈&lt;/a
>를 확인해보면 WWDC2015에서 추천했던 방식으로 오히려 &lt;code>weak&lt;/code>를 제거하는 것으로 약간의 성능 향상을 얻을 수 있다고 말합니다.&lt;/p>
&lt;p>이렇듯 Code Formatter를 적용하면 단순히 코드를 깔끔히 작성하는 것을 넘어서 성능 향상과 잠재적 버그를 사전에 방지하는 등의 긍정적인 효과를 얻을 수 있습니다.&lt;/p></description></item><item><title>[내배캠] UIKit 숙련 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/7/</link><pubDate>Mon, Sep 04 16:52:52 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/7/</guid><description>&lt;p>이번 7, 8주차에선 UIKit 숙련 과정 개인 과제를 진행했습니다. (2023년 8월 22일 ~ 9월 1일)&lt;br>
UIKit의 몇 가지 심화 내용을 학습하고 저번 입문 과제에서 작성했던 To-Do App을 개선했습니다.&lt;/p>
&lt;p>이번 프로젝트의 목표는 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>URLSession을 활용하여 네트워크 통신으로 데이터를 불러옵니다.&lt;/li>
&lt;li>MVC 아키텍처를 이해하고 적용합니다.&lt;/li>
&lt;li>iOS 앱과 UIViewController의 Lifecycle을 이해합니다.&lt;/li>
&lt;li>UserDefaults를 활용하여 데이터를 저장하고 불러옵니다.&lt;/li>
&lt;li>Dependency, 라이브러리, 프레임워크, 모듈에 대해 이해합니다.&lt;/li>
&lt;li>SPM을 사용하여 프로젝트의 의존성 관리를 할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;p>특히나, MVC 아키텍처를 적용하며 많은 고민을 해봤습니다. 어떻게 하면 각 역할에 맞게 코드를 잘 분리하고 데이터나 이벤트 흐름을 관리할 수 있을지 고민하면서 작성했습니다.&lt;/p>
&lt;p>&lt;strong>결과 미리보기&lt;/strong>&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 0.5rem;">
&lt;img class="mx-auto" alt="Empty Home Screen" src="https://jinyongp.dev/image/learn/nbcamp/7/empty-home.png" />
&lt;img class="mx-auto" alt="Home Menu" src="https://jinyongp.dev/image/learn/nbcamp/7/home-menu.png" />
&lt;img class="mx-auto" alt="Create New Task" src="https://jinyongp.dev/image/learn/nbcamp/7/create-new-task.png" />
&lt;img class="mx-auto" alt="Color Picker" src="https://jinyongp.dev/image/learn/nbcamp/7/color-picker.png" />
&lt;img class="mx-auto" alt="Collection View" src="https://jinyongp.dev/image/learn/nbcamp/7/collection-view.png" />
&lt;img class="mx-auto" alt="Detail Tasks" src="https://jinyongp.dev/image/learn/nbcamp/7/detail-tasks.png" />
&lt;img class="mx-auto" alt="List View" src="https://jinyongp.dev/image/learn/nbcamp/7/list-view.png" />
&lt;img class="mx-auto" alt="Delete Group" src="https://jinyongp.dev/image/learn/nbcamp/7/delete-group.png" />
&lt;/div>
&lt;hr>
&lt;h2 id="프로젝트-구조" class="flex items-center gap-3">프로젝트 구조 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구조" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ec%a1%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">ToDoList/
├── Resources/
├── Models/
├── ViewModels/
├── Services/
├── Views/
│ ├── EditTaskGroup/
│ ├── Shared/
│ ├── TaskGroup/
│ ├── TaskTable/
│ ├── Identifier.swift
│ └── RootView.swift
├── Controllers/
├── Utilities/
└── Info.plist&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="프로젝트-구현" class="flex items-center gap-3">프로젝트 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구현" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="제공하는-기능" class="flex items-center gap-3">제공하는 기능 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="제공하는 기능" href="#%ec%a0%9c%ea%b3%b5%ed%95%98%eb%8a%94-%ea%b8%b0%eb%8a%a5"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>할 일 그룹 생성/변경/삭제&lt;/li>
&lt;li>할 일 생성/변경/삭제&lt;/li>
&lt;li>할 일 순서 변경&lt;/li>
&lt;li>할 일 그룹 진행률 표시 (원형 진행바, 애니메이션 적용)&lt;/li>
&lt;li>할 일 그룹 별 랜덤 이미지 설정 (The Dog/Cat API)&lt;/li>
&lt;li>할 일 그룹 별 색상 설정&lt;/li>
&lt;li>CollectionView / TableView 제공&lt;/li>
&lt;li>Color Theme 대응 (Light/Dark)&lt;/li>
&lt;/ul>
&lt;h3 id="mvc-architecture" class="flex items-center gap-3">MVC Architecture &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="MVC Architecture" href="#mvc-architecture"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>해당 프로젝트는 Model - View - Controller 패턴을 적용하여 구현했습니다.&lt;/p>
&lt;h4 id="model" class="flex items-center gap-3">Model &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Model" href="#model"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;ul>
&lt;li>자료구조 및 클래스를 가지고 있는 Model과 ViewModel, 그리고 비즈니스 로직을 가진 Service입니다.&lt;/li>
&lt;li>Models: &lt;code>Codable&lt;/code> 프로토콜을 채택한 자료구조를 가집니다. Storage에서 데이터를 불러오고 내보내기 위해 사용합니다.&lt;/li>
&lt;li>ViewModels: Model의 데이터를 가공하여 View에게 전달합니다.
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="#publishable"
>&lt;code>Publishable&lt;/code>&lt;/a
>을 적용하여 구독자에게 변경사항을 알립니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Services: 비즈니스 로직을 담당합니다.
&lt;ul>
&lt;li>APIService: 네트워크 관련 로직을 담당합니다.&lt;/li>
&lt;li>TaskService: &lt;code>ViewModels&lt;/code> 데이터를 관리합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="view" class="flex items-center gap-3">View &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="View" href="#view"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;ul>
&lt;li>View는 사용자에게 보여지는 UI를 구성합니다.&lt;/li>
&lt;li>&lt;code>RootView&lt;/code>
&lt;ul>
&lt;li>Controller와 1:1 관계로 연결되는 View입니다. &lt;code>TypedViewController&lt;/code>에게 전달됩니다.&lt;/li>
&lt;li>프로토콜로서 &lt;code>initializeUI()&lt;/code>를 필수로 구현해야 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그 외 View는 &lt;code>RootView&lt;/code>에서 사용하는 하위 View입니다.&lt;/li>
&lt;li>Model의 변경사항을 구독하고 있으며, 구독 중인 속성이 변경되면 UI를 변경합니다. (&lt;a
class="underline-lsre"
href="#publishable"
>&lt;code>Publishable&lt;/code>&lt;/a
>)&lt;/li>
&lt;li>특정 이벤트가 발생하면 Controller에게 이를 알립니다. (&lt;a
class="underline-lsre"
href="#eventbus"
>&lt;code>EventBus&lt;/code>&lt;/a
>)&lt;/li>
&lt;/ul>
&lt;h4 id="controller" class="flex items-center gap-3">Controller &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Controller" href="#controller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;ul>
&lt;li>Controller는 View를 생성하고 연결합니다. 연결된 View는 &lt;code>typedView&lt;/code> 속성을 통해 접근할 수 있습니다.&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="#eventbus"
>&lt;code>EventBus&lt;/code>&lt;/a
>에 View에서 발생하는 모든 이벤트를 등록합니다. (&lt;code>ViewControllerEvents&lt;/code>, &lt;code>RootViewController&lt;/code>)&lt;/li>
&lt;li>등록된 이벤트가 발생했을 때 Model에게 데이터 변경을 요청할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;h3 id="scenarios" class="flex items-center gap-3">Scenarios &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Scenarios" href="#scenarios"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="사용자가-앱을-접속했을-때" class="flex items-center gap-3">사용자가 앱을 접속했을 때 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="사용자가 앱을 접속했을 때" href="#%ec%82%ac%ec%9a%a9%ec%9e%90%ea%b0%80-%ec%95%b1%ec%9d%84-%ec%a0%91%ec%86%8d%ed%96%88%ec%9d%84-%eb%95%8c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;pre class="mermaid">---
title: MVC Architecture Sequence Diagram
---
sequenceDiagram
participant User
participant Controller
participant View
participant Model
participant Storage
Note over Model: Publishable
autonumber
User->>Controller: Open app &amp; Request UI
Controller->>View: Create &amp; Connect (1:1 Relationship)
View->>Model: Subscribe data changes
Storage-->>Model: Load data (if exists)
Controller->>+Model: Request data
Model->>Model: Processing (to cause changes)
Model-->>-View: Publish data
View->>Controller: Build UI
Controller->>User: Display
&lt;/pre>
&lt;ol>
&lt;li>User가 앱을 실행하고 UI를 요청하면,
&lt;ol>
&lt;li>Controller가 View를 생성하고 자신에게 연결합니다. (&lt;code>TypedViewController&lt;/code>)&lt;/li>
&lt;li>View를 생성하는 단계에서 Model의 변경사항을 구독합니다. (&lt;a
class="underline-lsre"
href="#publishable"
>Publishable&lt;/a
>)&lt;/li>
&lt;li>Storage로부터 데이터를 불러와 Model을 준비합니다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Controller는 UI를 그리기 위해 필요한 데이터를 Model에 요청합니다.&lt;/li>
&lt;li>Model은 필요한 데이터를 정리하여 View에게 발행합니다. View는 이를 토대로 UI를 구축합니다.&lt;/li>
&lt;li>View와 연결된 Controller를 통해서 사용자에게 UI를 보여줍니다.&lt;/li>
&lt;/ol>
&lt;h4 id="사용자가-ui를-조작했을-때" class="flex items-center gap-3">사용자가 UI를 조작했을 때 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="사용자가 UI를 조작했을 때" href="#%ec%82%ac%ec%9a%a9%ec%9e%90%ea%b0%80-ui%eb%a5%bc-%ec%a1%b0%ec%9e%91%ed%96%88%ec%9d%84-%eb%95%8c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;pre class="mermaid">---
title: MVC Architecture Sequence Diagram
---
sequenceDiagram
participant User
participant View
participant EventBus
participant Controller
participant Model
participant Storage
Note over Model: Publishable
autonumber
Controller->>EventBus: Register callback for events
User->>View: Do specific actions
View->>+EventBus: Emit events (with data)
EventBus-->>-Controller: Run callback for the event
Controller->>+Model: Request CRUD
Model->>Model: Processing (to cause changes)
Model-->>Storage: Save data (if exists)
Model-->>-View: Publish changes with data
View->>User: Update UI &amp; Display
&lt;/pre>
&lt;ol>
&lt;li>Controller가 생성되는 과정에서 특정 이벤트에 실행할 동작을 정의합니다. (&lt;a
class="underline-lsre"
href="#eventbus"
>EventBus&lt;/a
>)&lt;/li>
&lt;li>User가 View를 통해 특정 행동을 수행하면 EventBus에 등록된 이벤트를 발행합니다.&lt;/li>
&lt;li>해당 이벤트를 구독 중인 Controller는 이벤트를 받아 데이터 생성/변경/삭제를 Model에게 요청합니다.&lt;/li>
&lt;li>Model은 요청에 맞게 데이터를 적절히 처리한 후, 변환하여 Storage에 저장합니다.&lt;/li>
&lt;li>Model은 변경사항을 데이터와 함께 구독 중인 View에게 알립니다. View는 이를 토대로 UI를 변경합니다.&lt;/li>
&lt;li>View와 연결된 Controller를 통해서 사용자에게 UI를 보여줍니다.&lt;/li>
&lt;/ol>
&lt;h2 id="api-references" class="flex items-center gap-3">API References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="API References" href="#api-references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="publishable" class="flex items-center gap-3">Publishable &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Publishable" href="#publishable"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>속성값의 변경사항을 구독자에게 자동으로 알려주는 Property Wrapper 클래스입니다.&lt;/p>
&lt;blockquote>
&lt;p>내부적으로 &lt;code>self&lt;/code>에 대한 참조를 &lt;a
class="underline-lsre"
href="#weakref"
>&lt;code>WeakRef&lt;/code>&lt;/a
>로 관리하고 있으므로, 메모리 해제 시 자동으로 구독을 해제합니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>API&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>Publishable&lt;/code>: 값의 변화를 구독자에게 알려주는 Property Wrapper 클래스입니다.&lt;/li>
&lt;li>&lt;code>Publisher&lt;/code>: 발행자를 나타냅니다. &lt;code>Publishable&lt;/code>을 적용한 속성의 타입입니다.&lt;/li>
&lt;li>&lt;code>Subscriber&lt;/code>: 구독자를 나타냅니다. &lt;code>Publishable&lt;/code>을 구독하는 타입입니다.&lt;/li>
&lt;li>&lt;code>Changes&lt;/code>: 값의 변화를 나타냅니다. 변경이전 값 &lt;code>old&lt;/code>와 변경된 값 &lt;code>new&lt;/code>를 가집니다.&lt;/li>
&lt;/ul>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">/// 구독자를 추가합니다. (immediate을 true로 설정하면 구독 즉시 이벤트를 발행합니다)
/// 이미 구독 중인 경우, 기존 구독을 취소하고 새로운 구독을 추가합니다.
func subscribe&amp;lt;Subscriber&amp;gt;(by: Subscriber, immediate: Bool, EventCallback&amp;lt;Subscriber&amp;gt;)
/// 주어진 구독자의 구독을 취소합니다.
func unsubscribe&amp;lt;Subscriber&amp;gt;(by: Subscriber)
/// 구독자에게 변경 사항을 발행합니다. nil을 전달하면 현재 값으로 발행합니다.
func publish(Changes?)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;strong>Example&lt;/strong>&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class MyModel {
@Publishable var name: String
init(name: String) {
self.name = name
}
}
final class Main {
static let shared = Main()
private init() {}
func run() {
let model = MyModel(name: &amp;#34;Old Model&amp;#34;)
model.$name.subscribe(by: self, immediate: true) { (subscriber, changes) in
// 강한 순환 참조를 피하기 위해 self 대신 subscriber를 사용합니다.
print(&amp;#34;Old Name: \(changes.old), New Name: \(changes.new)&amp;#34;)
}
model.name = &amp;#34;New Model&amp;#34; // 구독자에게 변경을 알립니다.
}
}
Main.shared.run()
// 출력 결과
// Old Name: Old Model, New Name: Old Model
// Old Name: Old Model, New Name: New Model&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="eventbus" class="flex items-center gap-3">EventBus &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="EventBus" href="#eventbus"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>이벤트를 관리하며, 구독 및 발행 기능을 제공합니다. 이벤트 기반의 프로그래밍 패턴을 제공합니다.&lt;/p>
&lt;blockquote>
&lt;p>내부적으로 &lt;code>self&lt;/code>에 대한 참조를 &lt;a
class="underline-lsre"
href="#weakref"
>&lt;code>WeakRef&lt;/code>&lt;/a
>로 관리하고 있으므로, 메모리 해제 시 자동으로 구독을 해제합니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>API&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>EventBus&lt;/code>: 이벤트를 구독 및 발행할 수 있는 싱글턴 클래스입니다.&lt;/li>
&lt;li>&lt;code>EventProtocol&lt;/code>: 이벤트를 나타내는 프로토콜입니다. &lt;code>Payload&lt;/code> 연관 타입을 가집니다.&lt;/li>
&lt;li>&lt;code>Emitter&lt;/code>: 이벤트를 발행할 수 있는 타입입니다.&lt;/li>
&lt;li>&lt;code>Listener&lt;/code>: 이벤트를 구독할 수 있는 타입입니다.&lt;/li>
&lt;/ul>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">/// 주어진 이벤트를 구독합니다.
func on&amp;lt;Listener, Event: EventProtocol&amp;gt;(Event.Type, by: Listener, EventCallback&amp;lt;Listener, Event&amp;gt;)
/// 주어진 구독자의 이벤트 구독을 취소합니다.
func off&amp;lt;Listener, Event: EventProtocol&amp;gt;(Event, by: Listener)
/// 주어진 구독자의 모든 구독을 취소합니다.
func reset&amp;lt;Listener&amp;gt;(Listener)
/// 주어진 이벤트를 발행합니다.
func emit&amp;lt;Event: EventProtocol&amp;gt;(Event) &lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;strong>Example&lt;/strong>&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class Main {
static let shared = Main()
private init() {}
func run() {
struct MyEvent: EventProtocol {
struct Payload {
let text: String
}
let payload: Payload
}
// 이벤트 구독
EventBus.shared.on(MyEvent.self, by: self) { (listener, payload) in
// 강한 순환 참조를 피하기 위해 self 대신 listener를 사용합니다.
print(&amp;#34;Payload: \(payload.text)&amp;#34;)
}
// 이벤트 발행
EventBus.shared.emit(MyEvent(payload: .init(text: &amp;#34;Hello, World!&amp;#34;)))
}
}
Main.shared.run()
// 출력 결과
// Payload: Hello, World!&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="weakref" class="flex items-center gap-3">WeakRef &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="WeakRef" href="#weakref"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;code>weak&lt;/code> 참조를 감싸는 구조체입니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct WeakRef&amp;lt;T: AnyObject&amp;gt; {
weak var value: T?
init(_ value: T?) {
self.value = value
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="storage" class="flex items-center gap-3">Storage &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Storage" href="#storage"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>데이터를 (영속적으로) 저장하고, 불러오는 기능을 제공하는 타입이 채택하는 프로토콜입니다.&lt;/p>
&lt;p>현재 &lt;code>UserDefaultsStorage&lt;/code>를 제공합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Storage {
static var shared: Self { get }
func save&amp;lt;T: Encodable&amp;gt;(_ object: T, forKey key: String)
func load&amp;lt;T: Decodable&amp;gt;(forKey key: String) -&amp;gt; T?
func remove(forKey key: String)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;hr>
&lt;h2 id="회고" class="flex items-center gap-3">회고 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="회고" href="#%ed%9a%8c%ea%b3%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이번 개인 과제를 진행하면서 MVC 아키텍처에 대해 많은 경험을 해볼 수 있었습니다. UIKit에서 View와 Controller를 어떻게 분리할 수 있을지, 그리고 View에서 사용자 입력이 발생했을 때 Controller에게 어떻게 알려줄 수 있을지, 그리고 Model에서 데이터가 변경되었을 때 View에게 어떻게 알려줄 수 있을지 고민하면서 여러 시도를 해보았습니다. 이러한 문제를 해결하기 위해 &lt;code>TypedViewController&lt;/code>, &lt;code>EventBus&lt;/code> 그리고 &lt;code>Publishable&lt;/code>을 구현하고 프로젝트에 적용해보았는데요. 확실히 디자인 패턴이 문제를 해결하는데 도움을 주고 또 꽤 효율적이라고 느낄 수 있었습니다.&lt;/p>
&lt;p>아쉬운 점은 튜터님께서 피드백을 주신대로 &lt;code>EventBus&lt;/code>의 이벤트를 하나의 파일에서 관리한 부분이었습니다. 다음 팀 프로젝트에서는 이러한 문제를 개선하고 보다 더 나은 MVC 아키텍처를 적용해보려고 합니다.&lt;/p></description></item><item><title>[내배캠] UIKit 입문 팀 프로젝트</title><link>https://jinyongp.dev/learn/nbcamp/6/</link><pubDate>Mon, Sep 04 16:52:52 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/6/</guid><description>&lt;p>6주차가 되었습니다. (2023년 8월 14일 ~ 21일)&lt;br>
개인 과제 때 학습한 내용을 기반으로 UIKit을 활용하여 팀 프로젝트를 진행했습니다.&lt;/p>
&lt;p>이번 과제는 팀원의 의견을 수렴하여 스토리보드 없이 코드로 UI를 작성하기로 결정하였습니다. UI 개발에 어려움을 겪을 것이 예상되어, 최대한 심플한 UI와 함께 과제 요구조건에 부합하는 최소 기능을 개발하기로 했습니다. Pinterest App에서 제공하는 UI와 기능이 가장 심플하여 선택하게 되었습니다.&lt;/p>
&lt;p>&lt;strong>핀터레스트 앱 디자인&lt;/strong>&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Pinterest Main Page" src="https://jinyongp.dev/image/learn/nbcamp/6/pinterest-main.png" />
&lt;img class="mx-auto" alt="Pinterest Detail Page" src="https://jinyongp.dev/image/learn/nbcamp/6/pinterest-detail.png" />
&lt;img class="mx-auto" alt="Pinterest Profile Page" src="https://jinyongp.dev/image/learn/nbcamp/6/pinterest-profile.png" />
&lt;img class="mx-auto" alt="Pinterest Edit Profile Page" src="https://jinyongp.dev/image/learn/nbcamp/6/pinterest-edit-profile.png" />
&lt;/div>
&lt;p>&lt;strong>과제 결과&lt;/strong>&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 0.5rem;">
&lt;img class="mx-auto" alt="Main Page" src="https://jinyongp.dev/image/learn/nbcamp/6/result-main-page.png" />
&lt;img class="mx-auto" alt="Create New Item Page" src="https://jinyongp.dev/image/learn/nbcamp/6/result-create-page.png" />
&lt;img class="mx-auto" alt="Detail Page" src="https://jinyongp.dev/image/learn/nbcamp/6/result-detail-page.png" />
&lt;img class="mx-auto" alt="Profile Page" src="https://jinyongp.dev/image/learn/nbcamp/6/result-profile-page.png" />
&lt;img class="mx-auto" alt="Edit Profile Page" src="https://jinyongp.dev/image/learn/nbcamp/6/result-edit-profile-page.png" />
&lt;/div>
&lt;hr>
&lt;h2 id="프로젝트-목표" class="flex items-center gap-3">프로젝트 목표 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 목표" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%eb%aa%a9%ed%91%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>UITableView / UICollectionView를 활용하며 피드 화면을 구현합니다.&lt;/li>
&lt;li>UITabBarController를 활용해서 다양한 메뉴 화면에 접근할 수 있는 UI를 제공합니다.&lt;/li>
&lt;li>UIStackView와 UIScrollView를 활용하여 프로필 화면을 구현합니다.&lt;/li>
&lt;li>사용자가 상호작용할 수 있는 다양한 기능을 제공합니다.&lt;/li>
&lt;li>UITextView와 UITextField를 활용하여 화면을 구성합니다.&lt;/li>
&lt;li>UIImagePickerController 혹은 PHPickerViewController를 활용하여 사진을 가져옵니다.&lt;/li>
&lt;/ul>
&lt;h2 id="프로젝트-구현" class="flex items-center gap-3">프로젝트 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구현" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>저는 Main.storyboard 없이 코드로 UI를 작성하기 위해 개발환경을 셋업하는 작업과 UICollectionView를 활용하여 Pinterest 스타일의 CollectionView를 구현하는 작업을 진행했습니다.&lt;/p>
&lt;h3 id="개발환경-셋업" class="flex items-center gap-3">개발환경 셋업 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="개발환경 셋업" href="#%ea%b0%9c%eb%b0%9c%ed%99%98%ea%b2%bd-%ec%85%8b%ec%97%85"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>첫번째로 Main.storyboard와 함께 Info.plist와 Targets의 Info 탭에서 Main을 제거했습니다. 그 후, SceneDelegate.swift에서 ViewController를 직접 생성하여 화면에 보여주도록 작성했습니다.&lt;/p>
&lt;p>화면에 첫번째로 보여줄 ContainerViewController인 TabBarController를 작성했습니다. 각 탭에 해당하는 ViewController를 생성하여 TabBarController에 추가해주었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TabBarController: UITabBarController {
override func viewDidLoad() {
super.viewDidLoad()
let tabs: [(vc: UIViewController.Type, icon: String)] = [
(HomeViewController.self, &amp;#34;house&amp;#34;),
(NewPostViewController.self, &amp;#34;plus.app&amp;#34;),
(ProfileViewController.self, &amp;#34;person&amp;#34;),
]
setViewControllers(tabs.map { vc, icon in
let navigationController = UINavigationController(rootViewController: vc.init())
let tabBarItem = UITabBarItem(title: nil, image: .init(systemName: icon), selectedImage: .init(systemName: &amp;#34;\(icon).fill&amp;#34;))
navigationController.tabBarItem = tabBarItem
return navigationController
}, animated: false)
}
override func viewDidLayoutSubviews() {
super.viewDidLayoutSubviews()
let paddingTop: CGFloat = 10.0
tabBar.frame = .init(
x: tabBar.frame.origin.x,
y: tabBar.frame.origin.y - paddingTop,
width: tabBar.frame.width,
height: tabBar.frame.height &amp;#43; paddingTop
)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>그리고 SceneDelegate에서 TabBarController를 생성하여 화면에 보여주도록 작성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// SceneDelegate.swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {
var window: UIWindow?
func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
guard let windowScene = (scene as? UIWindowScene) else { return }
window = UIWindow(windowScene: windowScene)
window?.makeKeyAndVisible()
AuthService.shared.login()
let tabBarController = TabBarController()
window?.rootViewController = tabBarController
}
// ...
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="pinterest-스타일의-collectionview-구현" class="flex items-center gap-3">Pinterest 스타일의 CollectionView 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Pinterest 스타일의 CollectionView 구현" href="#pinterest-%ec%8a%a4%ed%83%80%ec%9d%bc%ec%9d%98-collectionview-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Pinterest Style의 CollectionView를 구현하기 위해 Custom FlowLayout을 작성해주었습니다. 또한, JSON 형식의 데이터를 준비하여 메인 페이지에 그려주는 방식으로 구현하였습니다. 네트워크에서 불러온다고 가정하여 비동기로 불러오도록 구현하고 UI를 보여주기 전에 Progress Bar를 작성하여 변환 진척도를 사용자에게 보여주었습니다.&lt;/p>
&lt;h4 id="uicollectionview" class="flex items-center gap-3">UICollectionView &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="UICollectionView" href="#uicollectionview"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>&lt;code>UICollectionView&lt;/code>에서 기본으로 사용되는 &lt;code>UICollectionViewFlowLayout&lt;/code>은 높이가 유동적으로 변하는 Cell을 구현하기에 적합하지 않습니다. &lt;a
class="underline-lsre"
href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>에 따르면 FlowLayout은 항상 동일한 높이에 아이템을 배치하기 때문에, Cell 간 간격이 일정하지 않고 Cell의 높이에 따라 달라지게 됩니다. 그런 이유로 Pinterest 스타일의 CollectionView를 구현하기 위해서는 Custom FlowLayout을 작성해야 합니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="CollectionViewFlowLayout" src="https://jinyongp.dev/image/learn/nbcamp/6/collection-view-flow-layout.png" />
&lt;/p>
&lt;h4 id="pinterestcollectionviewflowlayout" class="flex items-center gap-3">PinterestCollectionViewFlowLayout &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="PinterestCollectionViewFlowLayout" href="#pinterestcollectionviewflowlayout"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;details class="rounded group my-2 border border-accent/20 p-2 px-3">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer text-slate-600 hover:text-accent transition-colors"
>
전체 코드 보기
&lt;span
class="text-xs text-current before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">import UIKit
@objc protocol PinterestCollectionViewDelegateFlowLayout: AnyObject {
@objc optional func collectionView(_ collectionView: UICollectionView, layout: UICollectionViewLayout, contentHeightAt indexPath: IndexPath) -&amp;gt; CGFloat
@objc optional func collectionView(_ collectionView: UICollectionView, layout: UICollectionViewLayout, contentPaddingForSectionAt section: Int) -&amp;gt; CGFloat
}
final class PinterestCollectionViewFlowLayout: UICollectionViewFlowLayout {
var numberOfColumns = 1
var contentPadding: CGFloat = 0
var headerHeight: CGFloat = 0
weak var delegate: PinterestCollectionViewDelegateFlowLayout?
private var attributesCache: [UICollectionViewLayoutAttributes] = []
private var columnHeights: [CGFloat] = []
override var collectionViewContentSize: CGSize {
guard let collectionView else { return .zero }
return .init(
width: collectionView.bounds.width,
height: (columnHeights.max() ?? 0) &amp;#43; headerHeight * 2)
}
override func prepare() {
super.prepare()
guard let collectionView else { return }
attributesCache = []
columnHeights = .init(repeating: 0, count: numberOfColumns)
for section in 0..&amp;lt;collectionView.numberOfSections {
let contentPadding = delegate?.collectionView?(collectionView, layout: self, contentPaddingForSectionAt: section) ?? contentPadding
let contentWidth = (collectionView.bounds.width - (CGFloat(numberOfColumns &amp;#43; 1) * contentPadding)) / CGFloat(numberOfColumns)
let columnOffsets: [CGFloat] = (0..&amp;lt;numberOfColumns).map { CGFloat($0) * (contentWidth &amp;#43; contentPadding) &amp;#43; contentPadding }
var column = 0
for item in 0..&amp;lt;collectionView.numberOfItems(inSection: section) {
let indexPath = IndexPath(item: item, section: section)
let contentHeight = contentPadding * 2 &amp;#43; (delegate?.collectionView?(collectionView, layout: self, contentHeightAt: indexPath) ?? contentWidth)
let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath)
attributes.frame = CGRect(x: columnOffsets[column], y: columnHeights[column] &amp;#43; headerHeight &amp;#43; contentPadding, width: contentWidth, height: contentHeight)
attributesCache.append(attributes)
columnHeights[column] = columnHeights[column] &amp;#43; contentHeight &amp;#43; contentPadding
column = (column &amp;#43; 1) % numberOfColumns
}
}
}
override func layoutAttributesForElements(in rect: CGRect) -&amp;gt; [UICollectionViewLayoutAttributes]? {
var attributes = attributesCache.filter { $0.frame.intersects(rect) }
if let headerAttributes = layoutAttributesForSupplementaryView(ofKind: UICollectionView.elementKindSectionHeader, at: IndexPath(item: 0, section: 0)) {
attributes.append(headerAttributes)
}
return attributes
}
override func layoutAttributesForSupplementaryView(ofKind elementKind: String, at indexPath: IndexPath) -&amp;gt; UICollectionViewLayoutAttributes? {
if elementKind == UICollectionView.elementKindSectionHeader {
let attributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: elementKind, with: indexPath)
attributes.frame = .init(x: 0, y: 0, width: collectionView?.frame.width ?? 0, height: headerHeight)
return attributes
}
return nil
}
override func layoutAttributesForItem(at indexPath: IndexPath) -&amp;gt; UICollectionViewLayoutAttributes? {
attributesCache[indexPath.item]
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="text-slate-500 transition-colors text-xs text-right">
전체 코드 보기
&lt;/div>
&lt;/details>
&lt;p>Custom FlowLayout을 작성하기 위해서 &lt;code>UICollectionViewFlowLayout&lt;/code>을 상속합니다. 그리고 몇가지 프로퍼티와 함수를 오버라이드해야 합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>collectionViewContentSize&lt;/code>: CollectionView의 ContentSize를 반환합니다. Cell의 높이에 따라 CollectionView의 높이가 유동적으로 변하므로 이를 계산해야 합니다.&lt;/li>
&lt;li>&lt;code>prepare&lt;/code>: CollectionView의 레이아웃을 준비합니다. Cell의 위치를 계산하고, CollectionView의 ContentSize를 계산한 뒤에 메모리에 저장해둡니다. &lt;code>IndexPath&lt;/code>에 대응하는 레이아웃 속성을 저장합니다.&lt;/li>
&lt;li>&lt;code>layoutAttributesForElements&lt;/code>: CollectionView의 레이아웃을 반환합니다. &lt;code>prepare&lt;/code>에서 계산한 레이아웃을 반환합니다.&lt;/li>
&lt;li>&lt;code>layoutAttributesForItem&lt;/code>: &lt;code>IndexPath&lt;/code>에 대응하는 레이아웃을 반환합니다. &lt;code>prepare&lt;/code>에서 계산한 레이아웃을 반환합니다.&lt;/li>
&lt;/ul>
&lt;p>모든 Cell의 높이가 다르므로 Cell의 높이를 저장하고 있을 속성이 필요합니다. 클래스에 &lt;code>contentHeights&lt;/code> 속성을 선언하고 &lt;code>prepare&lt;/code>에서 계산한 높이를 저장합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">private var columnHeights: [CGFloat] = []&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>prepare&lt;/code>이 실행되면 &lt;code>contentHeights&lt;/code>를 column의 개수만큼의 요소를 가진 배열로 초기화합니다. 그리고 CollectionView가 가진 요소를 모두 순회하며 너비와 높이를 계산합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>contentWidth&lt;/code>: CollectionView의 너비와 열 개수를 통해 구한 하나의 열의 너비입니다.&lt;/li>
&lt;li>&lt;code>contentHeight&lt;/code>: 외부에서 주입된 높이 값입니다.&lt;/li>
&lt;/ul>
&lt;p>이를 기반으로 Cell의 위치를 계산하여 frame을 생성한 뒤, &lt;code>attributesCache&lt;/code>에 저장합니다.&lt;/p>
&lt;p>&lt;code>contentHeights&lt;/code>에 Cell의 높이를 모두 저장합니다. &lt;code>column&lt;/code> 속성을 통해 현재 순회가 몇 번째 위치에 열인지 저장합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">override func prepare() {
super.prepare()
guard let collectionView else { return }
attributesCache = []
columnHeights = .init(repeating: 0, count: numberOfColumns)
for section in 0..&amp;lt;collectionView.numberOfSections {
let contentPadding = delegate?.collectionView?(collectionView, layout: self, contentPaddingForSectionAt: section) ?? contentPadding
let contentWidth = (collectionView.bounds.width - (CGFloat(numberOfColumns &amp;#43; 1) * contentPadding)) / CGFloat(numberOfColumns)
let columnOffsets: [CGFloat] = (0..&amp;lt;numberOfColumns).map { CGFloat($0) * (contentWidth &amp;#43; contentPadding) &amp;#43; contentPadding }
var column = 0
for item in 0..&amp;lt;collectionView.numberOfItems(inSection: section) {
let indexPath = IndexPath(item: item, section: section)
let contentHeight = contentPadding * 2 &amp;#43; (delegate?.collectionView?(collectionView, layout: self, contentHeightAt: indexPath) ?? contentWidth)
let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath)
attributes.frame = CGRect(x: columnOffsets[column], y: columnHeights[column] &amp;#43; headerHeight &amp;#43; contentPadding, width: contentWidth, height: contentHeight)
attributesCache.append(attributes)
columnHeights[column] = columnHeights[column] &amp;#43; contentHeight &amp;#43; contentPadding
column = (column &amp;#43; 1) % numberOfColumns
}
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>attributesCache&lt;/code>는 &lt;code>UICollectionViewLayoutAttributes&lt;/code> 타입으로 Cell의 위치와 크기를 저장합니다. 이는 &lt;code>layoutAttributesForElements&lt;/code>와 &lt;code>layoutAttributesForItem&lt;/code>에서 사용됩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>layoutAttributesForElements&lt;/code>: &lt;code>attributesCache&lt;/code>에서 현재 보이는 화면인 &lt;code>rect&lt;/code>와 겹치는 레이아웃을 반환합니다.&lt;/li>
&lt;li>&lt;code>layoutAttributesForItem&lt;/code>: &lt;code>attributesCache&lt;/code>에서 &lt;code>indexPath&lt;/code>에 해당하는 레이아웃을 반환합니다.&lt;/li>
&lt;/ul>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">override func layoutAttributesForElements(in rect: CGRect) -&amp;gt; [UICollectionViewLayoutAttributes]? {
attributesCache.filter { $0.frame.intersects(rect) }
}
override func layoutAttributesForItem(at indexPath: IndexPath) -&amp;gt; UICollectionViewLayoutAttributes? {
attributesCache[indexPath.item]
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>마지막으로 &lt;code>collectionViewContentSize&lt;/code>를 오버라이드하여 CollectionView의 ContentSize를 반환합니다. &lt;code>columnHeights&lt;/code>에서 최대 높이를 가져와서 반환합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">override var collectionViewContentSize: CGSize {
guard let collectionView else { return .zero }
return .init(
width: collectionView.bounds.width,
height: (columnHeights.max() ?? 0) &amp;#43; headerHeight * 2)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 Pinterest 스타일의 CollectionView를 구현할 수 있습니다.&lt;/p>
&lt;h2 id="회고" class="flex items-center gap-3">회고 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="회고" href="#%ed%9a%8c%ea%b3%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이번 과제에서는 CollectionViewFlowLayout에 대해 알아보고 Pinterest 스타일의 레이아웃을 직접 작성해보았습니다. &lt;code>frame&lt;/code>을 활용해서 Cell의 높이와 너비 그리고 x, y 좌표를 설정해서 직접 배치하는 방법으로 UI을 그리는 방법이 생각보다 동작을 잘해서 놀라웠던 경험이었습니다. 이를 구현하기 위해 여러 UICollectionView 사용방법을 보면서 이 뿐만 아니라 굉장히 다양한 용도로 사용하고 있었고, 또 애플에서 제공하는 기능이 훨씬 방대해서 UICollectionView를 더 많이 다양하게 사용해볼 필요성을 느꼈습니다.&lt;/p></description></item><item><title>[내배캠] UIKit 입문 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/5/</link><pubDate>Fri, Aug 11 06:52:27 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/5/</guid><description>&lt;p>이번 과제는 4, 5주차로 진행했습니다. (2023년 7월 31일 ~ 8월 11일)&lt;br>
지금까지 배운 Swift 문법을 기반으로 하여 UIKit의 기초적인 내용을 학습하고 간단한 ToDo App을 만들어보는 과제입니다.&lt;/p>
&lt;p>내일배움캠프에서 제공하는 학습 자료와 함께 &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8-%ec%95%b1%eb%a7%8c%eb%93%a4%ea%b8%b0"
target="_blank" rel="noopener noreferrer nofollow"
>15개 앱을 만들면서 근본원리부터 배우는 UIKit&lt;/a
> 강의를 병행하였습니다. 프로젝트의 요구 조건을 충족하기 위해 필요한 내용을 학습했습니다.&lt;/p>
&lt;ul>
&lt;li>UIKit의 기본적인 구조와 사용법&lt;/li>
&lt;li>리스트를 표시하는 방법 (UITableView)&lt;/li>
&lt;li>페이지 간 이동 및 데이터 전달 방법 (Segue)&lt;/li>
&lt;li>Alert 표시 및 사용자로부터 입력 받는 방법 (UIAlertController)&lt;/li>
&lt;/ul>
&lt;h2 id="프로젝트-목표" class="flex items-center gap-3">프로젝트 목표 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 목표" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%eb%aa%a9%ed%91%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>iOS 앱 개발도구인 xcode의 프로젝트 생성, 디버깅, 유틸리티 기능을 이해하고 활용합니다.&lt;/li>
&lt;li>Swift 문법을 활용하여 iOS 앱 개발에 적용할 수 있습니다.&lt;/li>
&lt;li>iOS의 UI를 구성하는 View와 ViewController에 대해 이해합니다.&lt;/li>
&lt;li>ViewController의 세부 요소인 Container-View-Container에 대해 이해합니다.&lt;/li>
&lt;/ul>
&lt;h2 id="프로젝트-구조" class="flex items-center gap-3">프로젝트 구조 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구조" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ec%a1%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">TodoApp/
├── LaunchScreen.storyboard
├── Main.storyboard
├── Models/
│ └── TodoItem.swift
├── Services/
│ └── TodoService.swift
├── Views/
│ ├── ViewController.swift
│ ├── CompletesViewController.swift
│ └── TodoTableViewCell.swift
├── Info.plist
├── AppDelegate.swift
└── SceneDelegate.swift&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Views&lt;/code>: UI를 담당하는 클래스를 가집니다.&lt;/li>
&lt;li>&lt;code>Models&lt;/code>: 데이터 모델 구조체를 가집니다.&lt;/li>
&lt;li>&lt;code>Services&lt;/code>: 데이터를 관리하는 비즈니스 로직을 담은 클래스를 가집니다&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="스토리보드" class="flex items-center gap-3">스토리보드 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="스토리보드" href="#%ec%8a%a4%ed%86%a0%eb%a6%ac%eb%b3%b4%eb%93%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;img class="mx-auto" alt="Storyboard" src="https://jinyongp.dev/image/learn/nbcamp/5/storyboard.png" />
&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 0.5rem;">
&lt;img class="mx-auto" alt="Main Page" src="https://jinyongp.dev/image/learn/nbcamp/5/main-page.png" />
&lt;img class="mx-auto" alt="Completes Page" src="https://jinyongp.dev/image/learn/nbcamp/5/completes-page.png" />
&lt;img class="mx-auto" alt="Add New Item" src="https://jinyongp.dev/image/learn/nbcamp/5/add-new-item.png" />
&lt;img class="mx-auto" alt="Edit Item" src="https://jinyongp.dev/image/learn/nbcamp/5/edit-item.png" />
&lt;/div>
&lt;h2 id="프로젝트-구현" class="flex items-center gap-3">프로젝트 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구현" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="todoitem" class="flex items-center gap-3">TodoItem &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoItem" href="#todoitem"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoItem {
var id: String
var content: String
var createdAt: UInt
var completedAt: UInt?
var completed: Bool { completedAt != nil }
init(content: String) {
self.id = UUID().uuidString
self.content = content
self.createdAt = UInt(Date().timeIntervalSince1970)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>배열에서 인스턴스를 가져오는 과정에서 값의 복사가 아닌 참조를 가져오길 원했습니다. 그런 이유로 &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>를 사용했고, 상속할 여지가 없으므로 &lt;code>final&lt;/code> 키워드를 붙여 Dynamic Dispatch 대신 Static Dispatch 방식으로 동작하게끔 했습니다.&lt;/p>
&lt;h3 id="todoservice" class="flex items-center gap-3">TodoService &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoService" href="#todoservice"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoService {
static var shared: TodoService = .init()
private init() {}
private(set) var items: [TodoItem] = [
TodoItem(content: &amp;#34;New를 눌러 새로운 항목을 추가해보세요!&amp;#34;),
TodoItem(content: &amp;#34;여기를 눌러 할 일 내용을 변경해보세요!&amp;#34;),
TodoItem(content: &amp;#34;체크박스를 눌러 할 일을 완료해보세요!&amp;#34;),
TodoItem(content: &amp;#34;Completes를 눌러 완료 내역을 확인하세요!&amp;#34;),
]
func add(content: String) {
items.append(TodoItem(content: content))
}
func update(index: Int, content: String) {
items[index].content = content
}
func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>TodoService&lt;/code>의 경우, 대부분의 &lt;code>Views&lt;/code>에서 사용될 예정이므로 하나의 &lt;code>Items&lt;/code>만 생성되어야 함을 보장하기 위해 Singleton 패턴을 적용하였습니다.&lt;/p>
&lt;h3 id="viewcontroller" class="flex items-center gap-3">ViewController &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="ViewController" href="#viewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;code>ViewController&lt;/code>의 경우 Main Page의 View와 Logic을 담당합니다. UI 관련 로직은 생략했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class ViewController: UIViewController {
@IBOutlet weak var titleLabel: UILabel!
@IBOutlet weak var tableView: UITableView!
@IBOutlet weak var newButton: UIButton!
@IBOutlet weak var completesButton: UIButton!
private var todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { !$0.completed } }
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
func initializeUI() {
// ...
}
@IBAction func newButtonTapped(_ sender: UIButton) {
// ...
}
}
extension ViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;TodoCell&amp;#34;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let index = indexPath.row
let item = items[index]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { [weak self] cell in
guard let self else { return }
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
cell.onLabelTapped = { [weak self] label in
guard let self else { return }
let alert = UIAlertController(title: &amp;#34;Edit Todo Item&amp;#34;, message: nil, preferredStyle: .alert)
let confirmAction = UIAlertAction(title: &amp;#34;Edit&amp;#34;, style: .default) { [weak alert] _ in
let text = alert?.textFields?[0].text ?? &amp;#34;&amp;#34;
if text.isEmpty { return }
label.text = text
self.todoService.update(index: index, content: text)
}
let cancelAction = UIAlertAction(title: &amp;#34;Cancel&amp;#34;, style: .cancel) { _ in
self.dismiss(animated: true)
}
alert.addTextField { $0.placeholder = label.text }
alert.addAction(confirmAction)
alert.addAction(cancelAction)
self.present(alert, animated: true)
}
return cell
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>UITableViewDataSource&lt;/code>를 채택하여 TableView를 그리기 위해 필요한 최소 메서드를 구현하였습니다. 완료하지 않은 할 일 목록만 가져와서 표시하고 있습니다. &lt;code>TodoTableViewCell&lt;/code>에 데이터를 전달하고 어떠한 이벤트가 발생했을 때 실행할 함수를 클로저로 전달하고 있습니다. Delegate Pattern을 활용할 수 있겠지만, 단순하게 클로저를 전달하는 방법으로 구현하였습니다.&lt;/p>
&lt;p>완료 버튼을 눌렀을 땐 애니메이션과 함께 목록에서 제거하도록 작성하였고, 라벨을 눌렀을 땐 Alert을 띄워 내용을 수정할 수 있도록 작성하였습니다.&lt;/p>
&lt;h2 id="todotableviewcell" class="flex items-center gap-3">TodoTableViewCell &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoTableViewCell" href="#todotableviewcell"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoTableViewCell: UITableViewCell {
@IBOutlet weak var todoLabel: UILabel!
@IBOutlet weak var completeButton: UIButton!
var onCompleted: ((_: TodoTableViewCell) -&amp;gt; Void)?
var onLabelTapped: ((_: UILabel) -&amp;gt; Void)?
var completed: Bool = false {
didSet {
completeButton.isSelected = completed
let attributedText = NSMutableAttributedString(string: todoLabel.text!)
if completed {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.5, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
} else {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: [] as [Any], range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.0, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
}
todoLabel.attributedText = attributedText
}
}
override func didMoveToSuperview() {
initializeUI()
}
private func initializeUI() {
setupGesture()
}
private func setupGesture() {
let tapGesture = UITapGestureRecognizer(target: self, action: #selector(labelTapped))
todoLabel.isUserInteractionEnabled = true
todoLabel.addGestureRecognizer(tapGesture)
}
@objc
func labelTapped() {
onLabelTapped?(todoLabel)
}
@IBAction func doneButtonTapped(_ sender: UIButton) {
onCompleted?(self)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>TodoTableViewCell&lt;/code>은 완료 여부를 뜻하는 &lt;code>completed&lt;/code>을 감시자 속성으로 가지고 있어, &lt;code>completed&lt;/code>가 변경됨에 따라 라벨에 &lt;code>strikethrough&lt;/code> 스타일을 추가/제거합니다.&lt;/p>
&lt;p>라벨에 Touch Action을 등록하기 위해서 &lt;code>UITapGestureRecognizer&lt;/code>를 추가하였습니다.&lt;/p>
&lt;h2 id="completesviewcontroller" class="flex items-center gap-3">CompletesViewController &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="CompletesViewController" href="#completesviewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>메인 페이지에서 &lt;code>completes&lt;/code> 버튼을 누르면 해당 페이지를 표시합니다. 버튼에 직접 등록하는 Segue 방식으로 연결하였습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class CompletesViewController: UIViewController {
@IBOutlet weak var tableView: UITableView!
private let todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { $0.completed } }
var onDismissed: (() -&amp;gt; Void)?
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
onDismissed?()
}
func initializeUI() {
tableView.backgroundView = {
let label = UILabel()
label.text = &amp;#34;Complete Your Todo!&amp;#34;
label.textAlignment = .center
label.textColor = .gray
return label
}()
}
}
extension CompletesViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
UIView.animate(withDuration: 0.2) {
tableView.backgroundView?.layer.opacity = self.items.count &amp;gt; 0 ? 0.0 : 1.0
}
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;TodoCell&amp;#34;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let item = items[indexPath.row]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { cell in
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
return cell
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CompletesViewController&lt;/code>에서도 &lt;code>UITableView&lt;/code>를 사용하므로 &lt;code>ViewController&lt;/code>와 동일한 방식으로 구현하였습니다. 완료 버튼을 눌러 완료를 취소할 수 있도록 하였습니다. 완료를 취소한 후, 변경 내용이 메인 페이지에도 반영되어야 하므로 페이지가 닫힐 때 호출할 &lt;code>onDismissed&lt;/code> 클로저를 추가하였습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;#34;CompletesVC&amp;#34; {
if let vc = segue.destination as? CompletesViewController {
vc.onDismissed = {
self.tableView.reloadData()
}
}
}
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CompletesViewController&lt;/code> 객체에 클로저를 전달하기 위해 &lt;code>ViewController&lt;/code>에 &lt;code>prepare&lt;/code> 메서드를 구현하였습니다. &lt;code>onDismissed&lt;/code>가 호출되면 메인 페이지의 &lt;code>tableView&lt;/code>를 갱신합니다.&lt;/p>
&lt;h3 id="delegate-패턴-적용" class="flex items-center gap-3">Delegate 패턴 적용 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Delegate 패턴 적용" href="#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>클로저 전달 방식 대신 Delegate 패턴을 적용해보았습니다. &lt;code>onDismissed&lt;/code> 클로저를 전달하는 대신 &lt;code>CompletesViewControllerDelegate&lt;/code> 프로토콜을 정의하여 &lt;code>onDismissed&lt;/code> 메서드 동작을 위임하도록 해보았습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">@objc protocol CompletesViewControllerDelegate {
@objc optional func onDismissed()
}
final class CompletesViewController: UIViewController {
var delegate: CompletesViewControllerDelegate?
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
delegate?.onDismissed?()
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;#34;CompletesVC&amp;#34; {
if let vc = segue.destination as? CompletesViewController {
vc.delegate = self
}
}
}
}
extension ViewController: CompletesViewControllerDelegate {
func onDismissed() {
tableView.reloadData()
}
} &lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>ViewController&lt;/code>가 &lt;code>prepare&lt;/code> 메서드에서 &lt;code>delegate&lt;/code> 인스턴스를 전달하고, &lt;code>CompletesViewControllerDelegate&lt;/code>를 채택하여 &lt;code>tableView&lt;/code>를 갱신하도록 작성했습니다. 위와 동일하게 동작함을 확인할 수 있습니다.&lt;/p>
&lt;h2 id="트러블슈팅" class="flex items-center gap-3">트러블슈팅 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="트러블슈팅" href="#%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="1-객체의-속성-변경이-반영되지-않는-문제" class="flex items-center gap-3">1. 객체의 속성 변경이 반영되지 않는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="1. 객체의 속성 변경이 반영되지 않는 문제" href="#1-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%86%8d%ec%84%b1-%eb%b3%80%ea%b2%bd%ec%9d%b4-%eb%b0%98%ec%98%81%eb%90%98%ec%a7%80-%ec%95%8a%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;code>TodoService&lt;/code>에서 &lt;code>TodoItem&lt;/code>의 속성을 변경할 때 제대로 변경되지 않는 문제가 있었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>원인은 &lt;code>TodoItem&lt;/code>이 &lt;code>struct&lt;/code> 키워드로 선언되어 있어, &lt;code>first&lt;/code>를 통해 찾은 값을 &lt;code>item&lt;/code> 변수에 할당하는 과정에서 값의 복사가 발생하여 복사된 값의 속성을 변경하더라도 원본 값이 변경되지 않는 문제였습니다. &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>로 선언하는 방식으로 문제를 해결했습니다.&lt;/p>
&lt;h3 id="2-unknown-class-_viewcontroller-in-interface-builder-file-에러" class="flex items-center gap-3">2. Unknown class _ViewController in Interface Builder file. 에러 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2. Unknown class _ViewController in Interface Builder file. 에러" href="#2-unknown-class-_viewcontroller-in-interface-builder-file-%ec%97%90%eb%9f%ac"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>여러 ViewController를 생성하는 과정에서 xcode의 버그로 인해 Module이 제대로 설정되지 않아 발생한 문제였습니다.&lt;/p>
&lt;img class="!my-0 !mx-auto md:!ml-4 md:w-1/3 md:float-right" src="https://jinyongp.dev/image/learn/nbcamp/5/unknown-class-error.png" alt="Unknown Class Error">
&lt;p>Storyboard에서 문제가 발생하는 ViewController를 선택한 뒤, 우측 Inspector Pane의 Identifier Inspector에서 Custom Class 항목의 Module이 None인지 확인합니다. None이라면 프로젝트 이름으로 변경한 뒤 Inherit Module From Target을 활성화합니다.&lt;/p>
&lt;p>참고: &lt;a
class="underline-lsre"
href="https://points.tistory.com/10"
target="_blank" rel="noopener noreferrer nofollow"
>[iOS] Unknown class _ViewController in Interface Builder file.&lt;/a
>&lt;/p>
&lt;h2 id="회고" class="flex items-center gap-3">회고 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="회고" href="#%ed%9a%8c%ea%b3%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>UIKit로 개발하면서 여태까지 해왔던 웹 개발과 많은 비교를 하게 되었습니다. UIKit으로 개발하는 건 웹 개발로 비유를 하자면 HTML, CSS 없이 JavaScript로만 모든 UI와 Style을 작성하는 것과 비슷했습니다. 웹에서 HTML과 CSS 그리고 JavaScript가 분리되어 있다는 게 굉장한 장점이구나 다시 한번 느끼게 되었습니다. UIKit의 경우 모든 내용을 선언형이 아닌 명령형으로 작성해야 하기 때문에 각 역할에 맞게 적절하게 코드를 분리하기 위한 노력이 필요함을 절실히 깨달았습니다.&lt;/p>
&lt;p>Storyboard와 코드를 연동하여 작성되어야 하는 부분이 있기 때문에 코드가 실행되는데 눈에 보이는 부분보단 이렇게 동작할 것이다 추론해야 하는 경우가 많았고 에러가 발생해도 추적하기가 굉장히 어려워서 개발 경험이 그리 좋지 않았습니다. 아무래도 UIKit의 대부분이 Objective-C로 작성되어 있어 해당 내용을 알아야만 에러 내용을 통해 원인을 유추할 수 있는 것도 한몫 하다보니 어려웠던 듯 싶습니다. 협업 관점에서 보나 디버깅 관점에서 보나 웬만하면 Storyboard 방식보단 코드 방식의 개발이 더 유리하지 않을까 생각했습니다.&lt;/p>
&lt;p>이후 기초 팀 프로젝트에서는 코드 방식으로 개발을 진행하며 Storyboard 개발 방식과 비교해보고자 합니다.&lt;/p></description></item><item><title>Learning Software Design Pattern (Swift)</title><link>https://jinyongp.dev/series/design-pattern/1/</link><pubDate>Wed, Aug 09 09:45:38 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/design-pattern/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>소프트웨어 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하고 직면하는 문제에 대한 해결책입니다. 반복적으로 마주하는 문제에 대한 해결책을 청사진처럼 만들어두고 필요할 때마다 재사용할 수 있습니다.&lt;/p>
&lt;p>본 시리즈는 &lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>을 참고하여 작성했습니다. 본 서적에선 GoF의 23가지 디자인 패턴을 다루고 있습니다. 하지만 GoF의 분류 체계(생성, 구조, 행위)를 따르지 않고, 다른 관점으로 분류하고 있으므로 이를 따라서 작성했습니다.&lt;/p>
&lt;p>글의 구성은 어떤 문제 혹은 상황에 직면했을 때 적용할 법한 패턴인지, 그리고 Swift 언어를 활용한 예시를 통해 해당 디자인 패턴을 어떻게 구현할 수 있는지에 초점을 맞춰 작성했습니다. 부족한 부분이 있다면 꾸준히 개선해나갈 예정이므로 틀린 내용 혹은 추가되었으면 하는 내용이 있다면 댓글로 남겨주시면 감사하겠습니다.&lt;/p>
&lt;blockquote>
&lt;p>⚠️ 디자인 패턴을 갓 배운 많은 개발자는 문제를 더 간단히 해결할 수 있는 상황임에도 모든 곳에 패턴을 적용해보려는 실수를 범한다고 합니다. 문제를 해결하는데 더 간단한 방법이 있다면 굳이 디자인 패턴을 적용할 필요가 없습니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns/swift"
target="_blank" rel="noopener noreferrer nofollow"
>Design Pattern in Swift&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns"
target="_blank" rel="noopener noreferrer nofollow"
>Design pattern : Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문 : 쉽게 배우는 GoF의 23가지 디자인 패턴&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Understanding Delegate Pattern</title><link>https://jinyongp.dev/posts/uikit/1/</link><pubDate>Tue, Aug 01 03:32:29 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/uikit/1/</guid><description>&lt;h2 id="introduce-delegate-pattern" class="flex items-center gap-3">Introduce Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduce Delegate Pattern" href="#introduce-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>UIKit에서는 여러가지 UI 관련 View를 제공합니다. 이 중에선 동작에 필요한 세부 구현은 숨겨진 채로 특정 상황이 발생했을 때만 ViewController에게 데이터를 전달하는 UIView가 있습니다.&lt;/p>
&lt;p>예를 들어 &lt;code>UITextField&lt;/code>의 경우, 사용자가 입력창을 눌렀을 때 OS에게 키보드를 열 것을 명령하며 사용자가 입력한 값을 &lt;code>UITextField&lt;/code>에 전달하는 동작이 구현되어 있을 것입니다. 하지만 ViewController에선 이러한 세부 동작은 알 필요 없이 특정 상황이 발생했을 때만 데이터를 전달 받아 이용하면 됩니다.&lt;/p>
&lt;p>UIkit에서는 이렇게 세부 구현은 숨긴 채로 특정 상황이 발생했음을 알리거나 동작의 제어를 위임하기 위해 Delegate Pattern을 활용하고 있습니다. &lt;code>UITextField&lt;/code>는 &lt;code>UITextFieldDelegate&lt;/code> 프로토콜을 통해 이를 구현하고 있으며, 이를 채택한 ViewController는 다음의 메서드를 구현하여 데이터를 전달받고 동작을 제어할 수 있습니다.&lt;/p>
&lt;p>&lt;code>UITextFieldDelegate&lt;/code>를 채택하여 구현할 수 있는 메서드 목록은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 편집을 시작할 때 호출합니다. Bool 값을 반환하여 편집을 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldBeginEditing(_:) -&amp;gt; Bool
// 편집이 시작된 직후 호출됩니다.
optional func textFieldDidBeginEditing(_:)
// 편집이 종료될 때 호출됩니다. Bool 값을 반환하여 편집을 중지할지 여부를 결정할 수 있습니다.
optional func textFieldShouldEndEditing(_:) -&amp;gt; Bool
// 편집이 종료된 직후 호출됩니다.
optional func textFieldDidEndEditing(_:)
// 텍스트 필드의 문자열이 변경될 때 호출됩니다. Bool 값을 반환하여 변경을 허용할지 여부를 결정할 수 있습니다.
optional func textField(_:shouldChangeCharactersIn:replacementString:) -&amp;gt; Bool
// 텍스트 필드의 선택 영역이 변경될 때 호출됩니다.
optional func textFieldDidChangeSelection(_:)
// 텍스트를 삭제할 때 호출됩니다. Bool 값을 반환하여 삭제를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldClear(_:) -&amp;gt; Bool
// 텍스트 필드의 리턴 키가 눌렸을 때 호출됩니다. Bool 값을 반환하여 리턴 키를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldReturn(_:) -&amp;gt; Bool&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>&lt;code>optional&lt;/code> 키워드로 정의되어 있으니 ViewController는 이 중에서 필요한 메서드만 구현하면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>정의한 메서드가 호출되려면 &lt;code>UITextField&lt;/code> 인스턴스의 &lt;code>delegate&lt;/code> 프로퍼티에 ViewController를 할당해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class ViewController: UIViewController {
private let textField = UITextField()
override func viewDidLoad() {
super.viewDidLoad()
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
// ...
}
func textFieldDidBeginEditing(_ textField: UITextField) {
// ...
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이런 식으로 Delegate Pattern을 통해 동작의 제어권을 위임받을 수 있습니다.&lt;/p>
&lt;h2 id="understand-delegate-pattern" class="flex items-center gap-3">Understand Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Understand Delegate Pattern" href="#understand-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>그렇다면 Delegate Pattern은 어떤 식으로 동작하기에 다른 객체에게 동작의 제어권을 위임할 수 있는걸까요? 간단한 &lt;code>Delegate&lt;/code> 프로토콜을 구현하여 동작을 확인해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool
func textFieldDidBeginEditing(_ textField: UITextField)
}
class UITextField {
var delegate: UITextFieldDelegate?
func userTextFieldTapped() {
guard let delegate else { return }
if delegate.textFieldShouldBeginEditing(self) {
// OS에게 키보드 열기 요청
delegate.textFieldDidBeginEditing(self)
}
}
}
class ViewController {
let textField = UITextField()
func viewDidLoad() {
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
print(#function)
return true
}
func textFieldDidBeginEditing(_ textField: UITextField) {
print(#function)
}
}
let controller = ViewController()
controller.viewDidLoad()
controller.textField.userTextFieldTapped()
// output:
// textFieldShouldBeginEditing(_:)
// textFieldDidBeginEditing(_:)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>소스 코드가 공개되어 있지 않으므로 정확한 세부 구현은 알 수 없으나 Delegate 패턴을 활용한 내부 모습은 대략 위와 비슷할 것으로 추정합니다.&lt;/p>
&lt;p>&lt;code>UITextField&lt;/code>의 경우 외부로부터 주입 받은 &lt;code>delegate&lt;/code> 객체를 통해 &lt;code>textFieldShouldBeginEditing&lt;/code>를 호출하여 동작의 제어권을 위임한 모습입니다. &lt;code>textFieldShouldBeginEditing&lt;/code>에서 &lt;code>false&lt;/code>를 반환하면 &lt;code>textFieldDidBeginEditing&lt;/code>는 호출되지 않을 것입니다.&lt;/p>
&lt;p>이러한 원리를 응용하여 Custom Delegate를 추가할 수 있습니다. &lt;a
class="underline-lsre"
href="https://jinyongp.dev/learn/nbcamp/5#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>Delegate Pattern 적용하기&lt;/a
>&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/uikit/uitextfield"
target="_blank" rel="noopener noreferrer nofollow"
>Apple Developer : UITextField&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/uikit/uitextfielddelegate"
target="_blank" rel="noopener noreferrer nofollow"
>Apple Developer : UITextFieldDelegate&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8-%ec%95%b1%eb%a7%8c%eb%93%a4%ea%b8%b0"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨 (15개 앱을 만들면서 근본 원리부터 배우는 UIKit)&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>[내배캠] Swift 심화 팀 과제</title><link>https://jinyongp.dev/learn/nbcamp/4/</link><pubDate>Fri, Jul 21 09:25:11 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/4/</guid><description>&lt;p>본 캠프가 시작되고 3주차가 되었습니다! (2023년 7월 24일 ~ 28일)&lt;/p>
&lt;p>이번 주차에서는 팀 프로젝트로서 Swift 심화 내용을 학습하고 간단한 키오스크 CLI 프로그램을 작성했습니다. 저번 개인 프로젝트에서 진행했던대로 터미널 환경에서 Swift 프로젝트를 생성하여 진행했습니다.&lt;/p>
&lt;p>팀 과제인만큼 소통에 보다 많은 노력을 쏟았습니다. 매일 오전 회의와 코드 리뷰를 진행하며 자신이 개발했던 내용과 어려움에 대해 공유했고, 페어 프로그래밍을 진행하며 하나의 기능을 함께 개발해보았습니다. 아무래도 부트캠프 과정 자체가 빠르게 진행되고 있기 때문에 프로그래밍을 처음 접한 팀원이 어려움을 많이 느꼈습니다. 정말 스파르타코딩클럽의 스&lt;/p>
&lt;p>구현한 키오스크 프로그램은 다음의 기능을 제공합니다.&lt;/p>
&lt;ol>
&lt;li>메뉴 화면 및 세부 메뉴 화면 표시&lt;/li>
&lt;li>숫자를 입력하여 메뉴 선택 가능&lt;/li>
&lt;li>메뉴를 장바구니에 추가하고 관리&lt;/li>
&lt;li>장바구니에 있는 메뉴를 주문&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>결과 미리보기&lt;/strong>&lt;/p>
&lt;details class="rounded group my-2 border border-accent/20 p-2 px-3">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer text-slate-600 hover:text-accent transition-colors"
>
SHAEKSHACK 메뉴 선택 화면
&lt;span
class="text-xs text-current before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ ⭐️ WELCOME SHAKESHACK ⭐️ ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Burger ┃ 앵거스 비프 통살을 다져만든 버거
2. Flat-Top Degs ┃ 참나무칩으로 훈연한 소시지가 들어간 핫 도그
3. Frozen Custard ┃ 매장에서 신선하게 만드는 아이스크림
4. Drink ┃ 매장에서 직접 만드는 상큼한 음료
5. Beer ┃ 뉴욕 브루클린 브루어리에서 양조한 맥주
6. Order ┃ 장바구니를 확인합니다.
7. Exit ┃ 프로그램을 종료합니다
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="text-slate-500 transition-colors text-xs text-right">
SHAEKSHACK 메뉴 선택 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2 border border-accent/20 p-2 px-3">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer text-slate-600 hover:text-accent transition-colors"
>
Burger 메뉴 선택 화면
&lt;span
class="text-xs text-current before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ 🍔 Burger MENU 🥤 ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Shack Burger ┃ W 6.9 ┃ 토마토, 양상추, 쉑소스가 토핑된 치즈버거
2. Smoke Burger ┃ W 8.9 ┃ 베이컨, 체리 페퍼, 쉑소스가 들어간 치즈버거
3. Shroom Burger ┃ W 9.4 ┃ 치즈로 속을 채운 베지테리안 버거
4. Shack Stack ┃ W 9.9 ┃ 슈룸 버거, 쉑버거의 맛을 즐길 수 있는 메뉴
5. Cheeseburger ┃ W 6.9 ┃ 포테이토 번, 비프패티, 치즈를 담은 치즈버거
6. Hamburger ┃ W 5.4 ┃ 포테이토 번, 비프패티, 신선한 재료를 담은 버거
0. Back ┃ 홈 화면으로 돌아갑니다.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 3
3. Shroom Burger ┃ W 9.4 ┃ 치즈로 속을 채운 베지테리안 버거
장바구니에 추가할까요? (Y/n): Y
정상적으로 추가되었습니다.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="text-slate-500 transition-colors text-xs text-right">
Burger 메뉴 선택 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2 border border-accent/20 p-2 px-3">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer text-slate-600 hover:text-accent transition-colors"
>
장바구니 화면
&lt;span
class="text-xs text-current before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[ ⭐️ WELCOME SHAKESHACK ⭐️ ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Burger ┃ 앵거스 비프 통살을 다져만든 버거
2. Flat-Top Degs ┃ 참나무칩으로 훈연한 소시지가 들어간 핫 도그
3. Frozen Custard ┃ 매장에서 신선하게 만드는 아이스크림
4. Drink ┃ 매장에서 직접 만드는 상큼한 음료
5. Beer ┃ 뉴욕 브루클린 브루어리에서 양조한 맥주
6. Order ┃ 장바구니를 확인합니다.
0. Exit ┃ 프로그램을 종료합니다
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 6&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="text-slate-500 transition-colors text-xs text-right">
장바구니 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2 border border-accent/20 p-2 px-3">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer text-slate-600 hover:text-accent transition-colors"
>
주문 화면
&lt;span
class="text-xs text-current before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ 🍕 Order List 💳 ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Buy ┃ 장바구니에 담은 제품을 구매합니다.
2. Clear ┃ 장바구니를 비웁니다.
0. Back ┃ 홈 화면으로 돌아갑니다.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
품목 목록
Shroom Burger x 1
🧾 Total Order Price: 9,400 WON
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 1
결제가 정상적으로 처리되었습니다. 감사합니다.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="text-slate-500 transition-colors text-xs text-right">
주문 화면
&lt;/div>
&lt;/details>
&lt;hr>
&lt;h2 id="프로젝트-구조" class="flex items-center gap-3">프로젝트 구조 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구조" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ec%a1%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">.
├── Options/
│ └── Option.swift
├── Services/
│ ├── CoreService.swift
│ ├── OrderService.swift
│ ├── Receipt.swift
│ └── WaitService.swift
├── Viewers/
│ ├── ConsoleViewer.swift
│ └── Viewer.swift
├── App.swift
└── main.swift&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="프로젝트-구현" class="flex items-center gap-3">프로젝트 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구현" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이번 프로젝트에선 enum 형식의 Associated Value를 적극적으로 활용하여 메뉴 화면에 표시될 옵션을 구현했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">enum Option: Equatable, Hashable {
struct Attr {
let id: Int
let name: String
let desc: String
}
case category(attr: Attr, menus: [Option])
case menu(attr: Attr, price: Int)
case order(attr: Attr, actions: [Option])
case action(attr: Attr)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Option&lt;/code> enum은 재귀적으로 작성되어 메뉴를 선택하면 하위 메뉴가 표시되는 구조입니다. &lt;code>main.swift&lt;/code> 파일에서 세부적인 모든 옵션을 추가하고 &lt;code>App&lt;/code> 클래스에 서비스를 등록합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">import Foundation
let viewer = ConsoleViewer()
let app = App(core: CoreService(
viewer: viewer,
orderService: OrderService(),
waitService: WaitService(
viewer: viewer,
queue: DispatchQueue(
label: &amp;#34;waiting&amp;#34;,
attributes: .concurrent)))
)
app.register(option: .category(
attr: Option.Attr(id: 1, name: &amp;#34;Burger&amp;#34;, desc: &amp;#34;앵거스 비프 통살을 다져만든 버거&amp;#34;),
menus: [
.menu(attr: Option.Attr(id: 1, name: &amp;#34;Shack Burger&amp;#34;, desc: &amp;#34;토마토, 양상추, 쉑소스가 토핑된 치즈버거&amp;#34;), price: 6900),
.menu(attr: Option.Attr(id: 2, name: &amp;#34;Smoke Burger&amp;#34;, desc: &amp;#34;베이컨, 체리 페퍼, 쉑소스가 들어간 치즈버거&amp;#34;), price: 8900),
.menu(attr: Option.Attr(id: 3, name: &amp;#34;Shroom Burger&amp;#34;, desc: &amp;#34;치즈로 속을 채운 베지테리안 버거&amp;#34;), price: 9400),
.menu(attr: Option.Attr(id: 4, name: &amp;#34;Shack Stack&amp;#34;, desc: &amp;#34;슈룸 버거, 쉑버거의 맛을 즐길 수 있는 메뉴&amp;#34;), price: 9900),
.menu(attr: Option.Attr(id: 5, name: &amp;#34;Cheeseburger&amp;#34;, desc: &amp;#34;포테이토 번, 비프패티, 치즈를 담은 치즈버거&amp;#34;), price: 6900),
.menu(attr: Option.Attr(id: 6, name: &amp;#34;Hamburger&amp;#34;, desc: &amp;#34;포테이토 번, 비프패티, 신선한 재료를 담은 버거&amp;#34;), price: 5400),
])
)
// 더욱 많은 메뉴 추가...
app.register(option: .order(
attr: Option.Attr(id: 6, name: &amp;#34;Order&amp;#34;, desc: &amp;#34;장바구니를 확인합니다.&amp;#34;),
actions: [
.action(attr: Option.Attr(id: 1, name: &amp;#34;Buy&amp;#34;, desc: &amp;#34;장바구니에 담은 제품을 구매합니다.&amp;#34;)),
.action(attr: Option.Attr(id: 2, name: &amp;#34;Clear&amp;#34;, desc: &amp;#34;장바구니를 비웁니다.&amp;#34;)),
])
)
app.run()&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>최대한 App 클래스가 구체적인 클래스에 의존하지 않도록 Protocol을 적극 사용하였습니다. 또한, 변경될 수 있는 세부 사항의 경우 &lt;code>main.swift&lt;/code>에서 주입할 수 있도록 작성해주었습니다.&lt;/p>
&lt;p>&lt;code>Viewer&lt;/code>도 이와 마찬가지로 메뉴를 보여주는 화면의 경우 또한 콘솔창이든 실제 키오스크 기기든 언제 어떻게든 변경될 수 있으므로, 프로토콜로 작성해주어서 주입해주는 방식으로 작성하였습니다.&lt;/p>
&lt;h2 id="회고" class="flex items-center gap-3">회고 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="회고" href="#%ed%9a%8c%ea%b3%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이번 프로젝트에서는 Swift 문법의 enum associated values 기능을 활용하여 메뉴 목록을 나열하고 여러가지 기능을 구현해보았습니다. OOP에 대해 처음 공부할 때 추상화, 캡슐화, 상속, 다형성 그리고 SOLID 원칙에 대해 암기하느라 바빴지 그 개념에 대한 이해나 활용을 전혀 하지 못했었는데, 이번 프로젝트를 진행하면서 프로토콜과 클래스를 적극 활용하며 현재 내가 구현하고 있는 코드가 OOP의 특징과 원칙을 잘 준수하고 있는지에 대해 고민해보며 깊은 이해를 할 수 있었습니다.&lt;/p></description></item><item><title>[내배캠] Swift 기초 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/3/</link><pubDate>Wed, Jul 19 04:26:26 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/3/</guid><description>&lt;p>본 캠프가 시작되고 2주차가 되었습니다. (2023년 7월 17일 ~ 21일)&lt;/p>
&lt;p>이번 주차에선 Swift 기초를 학습하고 간단한 연산 기능을 제공하는 CLI 계산기를 만들어 보는 과제를 수행했습니다.&lt;/p>
&lt;hr>
&lt;h2 id="요구조건" class="flex items-center gap-3">요구조건 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="요구조건" href="#%ec%9a%94%ea%b5%ac%ec%a1%b0%ea%b1%b4"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>1단계: 덧셈, 뺄셈, 곱셈, 나눗셈 연산 기능을 제공하는 Calculator 클래스 구현&lt;/li>
&lt;li>2단계: 1단계에서 구현한 Calculator 클래스를에 나머지 연산 기능 추가&lt;/li>
&lt;li>3단계: 각 연산을 개별 연산 클래스로 분리하고 Calculator와 연결 (feat. 단일 책임 원칙)&lt;/li>
&lt;li>4단계: 연산 클래스를 추상화한 추상 클래스 작성 (feat. 결합도, 의존성 역전 원칙)&lt;/li>
&lt;/ul>
&lt;h2 id="프로젝트-구조" class="flex items-center gap-3">프로젝트 구조 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구조" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ec%a1%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">.
├── Sources/
│ ├── Operators/
│ │ ├── AddOperator.swift
│ │ ├── SubOperator.swift
│ │ ├── MulOperator.swift
│ │ ├── DivOperator.swift
│ │ ├── ModOperator.swift
│ │ └── Operator.swift
│ ├── Calculator.swift
│ └── main.swift
├── Package.swift
└── README.md&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="프로젝트-구현" class="flex items-center gap-3">프로젝트 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="프로젝트 구현" href="#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="개발-환경설정" class="flex items-center gap-3">개발 환경설정 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="개발 환경설정" href="#%ea%b0%9c%eb%b0%9c-%ed%99%98%ea%b2%bd%ec%84%a4%ec%a0%95"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>과제에서는 단순히 연산 후 출력하는 걸 요구하고 있지만, 저는 &lt;code>readLine&lt;/code> 함수를 활용하여 사용자로부터 입력을 받아 계속 연산이 가능하도록 구현했습니다.&lt;/p>
&lt;p>실행 가능한 파일로 작성하기 위해 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>를 참고하여 프로젝트를 생성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ swift package init --type executable&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>위 명령어를 실행하면 현재 위치한 폴더에 &lt;code>Package.swift&lt;/code> 파일을 생성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// swift-tools-version: 5.8
// The swift-tools-version declares the minimum version of Swift required to build this package.
import PackageDescription
let package = Package(
name: &amp;#34;calculator-cli&amp;#34;,
targets: [
// Targets are the basic building blocks of a package, defining a module or a test suite.,
// Targets can depend on other targets in this package and products from dependencies.
.executableTarget(
name: &amp;#34;calc&amp;#34;,
path: &amp;#34;Sources&amp;#34;
),
]
)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이 파일에서 프로젝트에 대한 의존성 관리 및 빌드 설정 등을 할 수 있습니다.&lt;/p>
&lt;p>&lt;code>Sources&lt;/code> 폴더에 &lt;code>main.swift&lt;/code> 또한 생성되므로 &lt;code>swift run&lt;/code> 명령어를 실행하여 프로젝트를 실행할 수 있습니다.&lt;/p>
&lt;h3 id="operator-protocol-구현" class="flex items-center gap-3">Operator protocol 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Operator protocol 구현" href="#operator-protocol-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>각 연산에 대한 클래스의 명세를 정하기 위해 &lt;code>Operator&lt;/code> 프로토콜을 작성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이를 토대로 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 클래스를 작성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">class AddOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand {
return lhs &amp;#43; rhs
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>여기서 &lt;code>lhs + rhs&lt;/code> 에서 &lt;code>Binary operator '+' cannot be applied to two 'Operand' operands&lt;/code> 에러가 발생합니다. &lt;code>Operand&lt;/code> 타입이 덧셈 기능을 제공하는지 모르기 때문입니다.&lt;/p>
&lt;p>이를 해결하려면 &lt;code>Operand&lt;/code> 타입이 연산 가능한 타입만 올 수 있도록 제약을 걸 필요가 있습니다. &lt;code>Calculable&lt;/code> 프로토콜을 추가하여 이를 준수하는 타입만 올 수 있도록 제약을 걸었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Operator {
func operate&amp;lt;Operand: Calculable&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}
protocol Calculable {
static func &amp;#43;(lhs: Self, rhs: Self) -&amp;gt; Self
static func -(lhs: Self, rhs: Self) -&amp;gt; Self
static func *(lhs: Self, rhs: Self) -&amp;gt; Self
static func /(lhs: Self, rhs: Self) -&amp;gt; Self
static func %(lhs: Self, rhs: Self) -&amp;gt; Self
}
extension Int: Calculable {}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Calculable&lt;/code> 프로토콜을 추가하고 &lt;code>Int&lt;/code> 타입이 이를 준수하도록 확장(extension)했습니다.&lt;/p>
&lt;p>하지만, 위와 같은 방식으로 &lt;code>Double&lt;/code> 타입을 확장했을 때, &lt;code>Type 'Double' does not conform to protocol 'Calculable'&lt;/code> 에러가 발생합니다. 실수 타입인 &lt;code>Double&lt;/code>은 나머지 연산에 대한 동작이 정의되어 있지 않기 때문입니다. 단순히 정수 타입으로 동작하도록 확장해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension Double: Calculable {
static func %(lhs: Self, rhs: Self) -&amp;gt; Self {
return Double(Int(lhs) % Int(rhs))
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">class ModOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand where Operand : Calculable {
return lhs % rhs
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 나머지 연산에 대해서도 &lt;code>Double&lt;/code> 타입을 사용할 수 있게 되었고, &lt;code>Operator&lt;/code> 프로토콜을 준수하는 &lt;code>ModOperator&lt;/code> 클래스를 작성할 수 있게 되었습니다. (SPR. 단일 책임 원칙)&lt;/p>
&lt;h3 id="calculator-class-구현" class="flex items-center gap-3">Calculator class 구현 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Calculator class 구현" href="#calculator-class-%ea%b5%ac%ed%98%84"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>작성한 연산자를 언제든 사용할 수 있는 형태로 하여 Dictionary 형태로 외부에서 주입할 수 있도록 작성했습니다.&lt;/p>
&lt;p>&lt;code>_result&lt;/code>는 여태까지 연산한 결과를 갖고 있는 저장 프로퍼티이고, &lt;code>calculate&lt;/code> 메서드를 호출하여 연산을 수행합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">import Foundation
class Calculator&amp;lt;T: Calculable&amp;gt; {
private var _result: T
private var _operators: [String: Operator]
init(defaultValue: T? = nil, operators: [String: Operator] = [:]) {
_result = defaultValue ?? Calculator.zero()
_operators = operators
}
var result: T { _result }
var operators: [String] { Array(_operators.keys) }
@discardableResult
func calculate(_ operand: T, name: String) -&amp;gt; T {
guard let operation = _operators[name] else { return _result }
_result = operation.operate(_result, operand)
return _result
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let calculator = Calculator&amp;lt;Double&amp;gt;(
operators: [
&amp;#34;&amp;#43;&amp;#34;: AddOperator(),
&amp;#34;-&amp;#34;: SubOperator(),
&amp;#34;*&amp;#34;: MulOperator(),
&amp;#34;/&amp;#34;: DivOperator(),
&amp;#34;%&amp;#34;: ModOperator(),
]
)
calculator.calculate(10, name: &amp;#34;&amp;#43;&amp;#34;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 &lt;code>Calculator&lt;/code>는 구체적인 클래스가 아닌 추상화된 프로토콜에 의존합니다. (DIP. 의존성 역전 원칙)&lt;/p>
&lt;h2 id="트러블슈팅" class="flex items-center gap-3">트러블슈팅 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="트러블슈팅" href="#%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;h3 id="1-0으로-초기화할-때-제네릭-타입으로-변환할-수-없는-문제" class="flex items-center gap-3">1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제" href="#1-0%ec%9c%bc%eb%a1%9c-%ec%b4%88%ea%b8%b0%ed%99%94%ed%95%a0-%eb%95%8c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%eb%b3%80%ed%99%98%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>계산기이니 &lt;code>clear&lt;/code> 메서드를 작성했고, 이는 결과를 0으로 초기화하는 단순한 작업을 수행합니다. &lt;code>Int&lt;/code> 타입은 0으로 초기화하는 반면에 &lt;code>Double&lt;/code>은 0.0으로 초기화해야 했기 때문입니다. 제네릭 타입으로부터 이를 확인할 수 있는 방법은 없었지만, 0과 0.0 이외에 경우는 없다고 가정하고 nullish coalescing operator를 사용하여 해결했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">private static func zero() -&amp;gt; T {
return 0 as? T ?? 0.0 as! T
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="2-첫-문자를-제외한-문자열-가져오기" class="flex items-center gap-3">2. 첫 문자를 제외한 문자열 가져오기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2. 첫 문자를 제외한 문자열 가져오기" href="#2-%ec%b2%ab-%eb%ac%b8%ec%9e%90%eb%a5%bc-%ec%a0%9c%ec%99%b8%ed%95%9c-%eb%ac%b8%ec%9e%90%ec%97%b4-%ea%b0%80%ec%a0%b8%ec%98%a4%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Swift에서 문자열을 조작하기란 다른 언어에 비해 번거로운 점이 많았습니다&amp;hellip; index 또한 단순히 숫자가 아니라 String.Index를 생성하여 전달해야했고, 주어진 Index로부터 어느정도 떨어졌는지하는 방식으로 문자열을 가져와야했습니다.&lt;/p>
&lt;p>첫 문자를 제외하고 문자열을 가져오려면 다음 방식으로 가져와야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let input: String = &amp;#34;Hello, World!&amp;#34;
input[input.index(input.startIndex, offsetBy: 1)...] // ello, World!&lt;/code>&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>input.index&lt;/code> 메서드를 호출하여 &lt;code>String.Index&lt;/code> 타입의 인덱스를 생성합니다. 이때, &lt;code>input.startIndex&lt;/code>를 기준으로 &lt;code>offsetBy&lt;/code> 만큼 떨어진 인덱스를 생성합니다.&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/partialrangefrom"
target="_blank" rel="noopener noreferrer nofollow"
>PartialRangeFrom&lt;/a
> 문법을 활용하여 해당 인덱스부터 문자열을 가져옵니다.&lt;/li>
&lt;/ol>
&lt;p>나중에 알게된 내용인데 단순하게 &lt;code>dropFirst&lt;/code> 메서드를 활용해도 됩니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">input.dropFirst() // ello, World!&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>문자열 관련 메서드는 대개 &lt;code>Self.SubSequence&lt;/code> 타입을 반환합니다. 잘라낸 문자열을 저장하기 위헤 새로운 메모리 공간을 할당하는 것이 아닌 기존의 문자열에서 필요한 부분에 직접 접근하기 때문입니다. 따라서, 문자열로서 사용하고 싶다면 &lt;code>String&lt;/code>으로 변환해야 합니다.&lt;/p>
&lt;h2 id="회고" class="flex items-center gap-3">회고 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="회고" href="#%ed%9a%8c%ea%b3%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>객체 지향 프로그래밍의 5대 원칙 중 단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)을 적용하여 계산기를 구현해보았습니다. 원칙을 적용해보기 위해 프로토콜로 명세를 작성하고 이를 준수하는 클래스는 작성하는 작업을 진행하면서 코드의 중복을 제거하고 확장성 높은 프로그램을 작성할 수 있었습니다.&lt;/p>
&lt;p>앞으로 이외에도 적용할 수 있는 원칙을 찾아보고 적합한 디자인 패턴 및 기법을 추가로 학습하여 적용해보려고 합니다.&lt;/p></description></item></channel></rss>