<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jinyongp.dev</title><link>https://jinyongp.dev/</link><description>Recent content on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Wed, 19 Jul 2023 04:26:26 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>[내배캠] Swift 기초 개인 과제</title><link>https://jinyongp.dev/study/nbcamp/3/</link><pubDate>Wed, 19 Jul 2023 04:26:26 +0000</pubDate><guid>https://jinyongp.dev/study/nbcamp/3/</guid><description>본 캠프가 시작되고 2주차가 되었습니다.
이번 주차에선 Swift를 학습하고 간단한 연산 기능을 제공하는 계산기를 만들어 보는 과제를 수행했습니다.
캠프에서는 자기주도적 학습 방식을 추구하기 때문에 주어지는 학습 자료 외에도 스스로 조사하고 학습해야 합니다. 주어지는 학습자료만으로는 깊게 학습할 수 없었기에 공식 문서와 다른 강의를 병행하며 부족한 부분을 채워야 합니다.
저는 캠프 참여 이전에 이러한 부분을 인지하고 있었으므로 자세한 문법이나 이론 관련한 내용은 앨런 Swift 문법 마스터 스쿨 과정을 병행하며 보충했습니다.
과제를 수행하기에 충분한 문법과 이론을 학습했고, 이를 기반으로 CLI에서 실행할 수 있는 간단한 계산기 툴을 작성했습니다.</description></item><item><title>[내배캠] 첫번째 팀 프로젝트</title><link>https://jinyongp.dev/study/nbcamp/2/</link><pubDate>Wed, 19 Jul 2023 01:27:06 +0000</pubDate><guid>https://jinyongp.dev/study/nbcamp/2/</guid><description>사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다.
4일간 진행한 프로젝트로 목적은 앱 개발 전반의 과정을 익히기 위함이지만, 보다 팀원분들과의 소통과 협업 관점에 비중으로 두고 프로젝트를 진행하였습니다.
프로젝트의 주제는 팀과 팀원의 소개를 담은 앱을 작성하는 것으로, 각자 자신의 소개를 담은 상세 페이지를 작성하고 합치기로 결정하였습니다. 저는 상세 페이지와 더불어 메인 페이지와 각 상세 페이지에서 쓰일 댓글 관리 서비스를 맡았습니다.
그 중에서도 댓글 관리 서비스를 어떻게 구현했는지 정리해보고자 합니다.
프로젝트 저장소</description></item><item><title>[내배캠] 사전캠프</title><link>https://jinyongp.dev/study/nbcamp/1/</link><pubDate>Tue, 27 Jun 2023 11:16:56 +0000</pubDate><guid>https://jinyongp.dev/study/nbcamp/1/</guid><description>2023년 06월 30일 5주차 강의는 HTTP API 요청 방법을 익혔습니다. 다음주는 광고 붙이는건데&amp;hellip; 이번이 마지막일 듯 하네요.
Requesting Network Data HttpClient로는 dio 패키지를 활용했습니다. 책 정보를 불러올 수 있는 Google API를 활용하여 Watcha Pedia 서비스를 구현했습니다.
// main.dart void main() async { late SharedPreferences pref; if (!kIsWeb) { WidgetsFlutterBinding.ensureInitialized(); pref = await SharedPreferences.getInstance(); } runApp(MultiProvider( providers: [ ChangeNotifierProvider( create: (_) =&amp;gt; BookService( get: &amp;lt;T&amp;gt;(String query) async { String url = &amp;#39;https://www.</description></item><item><title>D3.js and Canvas API : Refactoring for Performance</title><link>https://jinyongp.dev/blog/d3js/4/</link><pubDate>Fri, 22 Apr 2022 14:18:15 +0000</pubDate><guid>https://jinyongp.dev/blog/d3js/4/</guid><description>이전 시리즈: d3-zoom, d3-drag : Panning and Zooming and Dragging Introduction 저번 시리즈에서 필요한 기능은 전부 구현해보았지만, svg 요소의 개수가 증가할수록 성능이 하락하는 모습을 확인했습니다. 50개의 nodes에 대해 DevTools로 측정해본 결과, 렌더링 연산에 굉장히 많은 CPU, GPU 작업을 필요로 하고 있었습니다.
이를 해결하기 위해서 Canvas API를 이용할 수 있습니다. Canvas API를 이용하면 d3-selection을 다룰 일은 거의 없습니다. 특히나 이번처럼 단순히 원과 선만 그리면 되는 작업에서는 그리기 더욱 쉽습니다. 대신 zoom과 drag는 구현 방식에 차이가 있어 다소 어려운 점도 있습니다.</description></item><item><title>d3-zoom, drag : Panning, Zooming and Dragging</title><link>https://jinyongp.dev/blog/d3js/3/</link><pubDate>Thu, 21 Apr 2022 11:16:27 +0000</pubDate><guid>https://jinyongp.dev/blog/d3js/3/</guid><description>이전 시리즈: d3-selection : Data Driven Transformation of DOM 다음 시리즈: D3.js and Canvas API : Refactoring for Performance Introduction d3-zoom과 d3-drag는 사용자가 마우스 클릭 혹은 터치로 화면을 제어하거나 요소를 이동하는 기능을 제공합니다.
이번 시리즈 또한 마찬가지로 저번 시리즈에 구현했던 코드에 d3-zoom과 d3-drag를 결합하는 걸 목표로 하여 그에 필요한 부분만 다루도록 하겠습니다.
d3-zoom d3-zoom은 사용자가 화면을 드래그 혹은 스크롤하여 현재 보는 범위를 이동, 확대, 축소하는 기능을 제공합니다. 혹은, 특정 요소를 선택했을 때 그 위치로 이동하면서 포커스하는 효과를 줄 수도 있습니다.</description></item><item><title>d3-selection : Data Driven Transformation of DOM</title><link>https://jinyongp.dev/blog/d3js/2/</link><pubDate>Sat, 16 Apr 2022 02:47:11 +0000</pubDate><guid>https://jinyongp.dev/blog/d3js/2/</guid><description>이전 시리즈: d3-force : Simulating Physical Forces 다음 시리즈: d3-zoom, d3-drag : Panning and Zooming and Dragging Introduction d3-selection은 데이터를 기반으로 DOM을 조작할 수 있는 다양한 기능을 제공합니다.
이번 시리즈는 d3-force와 연계하여 Github Follower, Following 관계망 그리기를 목표로 하고 있으므로 구현 과정에서 필요한 부분에 대해서만 다루도록 하겠습니다.
들어가기 전에 Selection 객체에 대해 알아봅시다. d3-selection으로 선택한 요소는 &amp;lt;code&amp;gt;groups&amp;lt;/code&amp;gt;와 &amp;lt;code&amp;gt;parents&amp;lt;/code&amp;gt; property를 갖는 &amp;lt;code&amp;gt;Selection&amp;lt;/code&amp;gt; 객체를 생성합니다. Selection 객체는 선택한 요소를 제어할 수 있는 다양한 메서드를 제공합니다.</description></item><item><title>D3.js Network Simulation In Depth</title><link>https://jinyongp.dev/projects/d3js/1/</link><pubDate>Thu, 14 Apr 2022 14:31:09 +0000</pubDate><guid>https://jinyongp.dev/projects/d3js/1/</guid><description>원티드 프리온보딩에서 주어진 과제 중 하나인 D3.js를 이용한 Github Starred Repo 관계망 그리기 프로젝트를 진행하면서 d3.js에 큰 흥미를 가지게 되었습니다. 처음 다뤄보는 시각화 라이브러리이라 기능 하나를 추가할 때마다 많은 자료와 문서를 찾아봐야 했습니다. 어찌어찌하긴 해내긴 했지만 코드와 동작을 보며 느껴지는 부족함에 아쉬움이 생겼습니다. 아무래도 짧은 시간 내에 구현해내느라 이해하는데 어려움이 있었기 때문에, 그 어려움을 극복하고자 문서를 톺아보며 살펴보고 정리해보고자 합니다.
사용하는 라이브러리는 d3.js입니다. d3가 가진 수많은 라이브러리 중에서도 d3-force, d3-zoom, d3-selection, d3-drag 등 추가로 필요한 모듈이라면 전부 활용해볼 예정이고 성능 향상을 위해 Canvas API로 구현해보려고 합니다.</description></item><item><title>d3-force : Simulating Physical Forces</title><link>https://jinyongp.dev/blog/d3js/1/</link><pubDate>Thu, 14 Apr 2022 14:20:46 +0000</pubDate><guid>https://jinyongp.dev/blog/d3js/1/</guid><description>다음 시리즈: d3-selection : Data Driven Transformation of DOM Introduction d3-force는 입자(nodes) 간에 가해지는 물리적 힘(forces)을 simulation하여 입자의 좌표값을 계산하고 제공합니다.
코드와 함께 Simulation과 Forces에 대해 이해해봅시다.
Simulation Simulation은 nodes에 가해지는 물리적 힘을 계산합니다. d3.forceSimulation() 함수로 simulation을 생성합니다.
const simulation = d3.forceSimulation(); Simulation에 그래프의 정점 목록인 nodes와 간선 목록인 links를 등록할 수 있습니다.
Nodes 먼저 nodes에 대해 알아봅시다. Simulation은 입력한 node 객체에 계산 결과값을 추가합니다. nodes 배열에서 각 node를 인덱스로 관리해도 되지만, 보기 어려우므로 고유 식별자 id를 추가하겠습니다.</description></item></channel></rss>