<!doctype html><html lang=ko><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://jinyongp.dev><meta name=naver-site-verification content="c36f259891f25bc92e3884c1ceb626a0aaa76146"><meta name=author content="jinyongp"><meta property="og:site_name" content="jinyongp.dev"><meta property="og:title" content="Simulating Physical Forces"><meta property="og:type" content="website"><meta property="og:url" content="https://jinyongp.dev/posts/d3js/1/"><meta property="og:description" content="d3-force의 개념과 동작 방식을 코드와 함께 살펴봅니다."><meta name=description content="d3-force의 개념과 동작 방식을 코드와 함께 살펴봅니다."><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PFTW4CN")</script><title>Simulating Physical Forces</title><link rel=icon href=https://jinyongp.dev/favicon.png><link rel=stylesheet href=https://jinyongp.dev/main.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><style>:root{--accent:65 105 225;--font:Raleway}</style><script src=https://kit.fontawesome.com/62c573b42c.js crossorigin=anonymous></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/rainbow.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.highlightAll(),hljs.configure({ignoreUnescapedHTML:!0})</script><script src=/js/main.js></script></head><body><nav class=shadow-md><div class="layout flex justify-between text-gray-600"><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=/>Home</a></li><li class=hover:text-accent><a href=/posts class=text-accent>Posts</a></li><li class=hover:text-accent><a href=/series>Series</a></li><li class=hover:text-accent><a href=/learn>Learn</a></li></ul><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=mailto:dev.jinyongp@gmail.com><i class="fa-solid fa-square-envelope text-xl"></i></a></li><li class=hover:text-accent><a href=https://github.com/jinyongp/><i class="fa-brands fa-github-square text-xl"></i></a></li></ul></div></nav><main class=pb-24><div class=layout><header class=text-center><h1 class="mt-16 mb-12">Simulating Physical Forces</h1><div class="flex justify-between items-center"><div><a href=https://jinyongp.dev/tags/d3.js><kbd class="text-sm bg-accent text-white rounded px-1 py-0.5">d3.js</kbd></a></div><h6>Written on Apr 14, 2022</h6></div><hr class=my-4></header><div class="grid grid-cols-1 gap-2 md:gap-10 md:grid-cols-2 text-slate-700"><div></div><div><a href=/posts/d3js/2/ class="flex flex-col gap-1 border border-current text-current rounded p-2 hover:text-accent text-right"><div class="flex items-center gap-1 justify-end"><span class=font-bold>NEXT SERIES</span>
<i class="fa-solid fa-arrow-right"></i></div><span class="truncate whitespace-nowrap">Data Driven Transformation of DOM</span></a></div></div><hr class=mt-4><article class="content [&_hr]:my-4"><h1 id=introduction>Introduction</h1><p><a href=https://github.com/d3/d3-force>d3-force</a>는 입자(<code>nodes</code>) 간에 가해지는 물리적 힘(forces)을 simulation하여 입자의 좌표값을 계산하고 제공합니다.</p><p>코드와 함께 <a href=#simulation>Simulation</a>과 <a href=#forces>Forces</a>에 대해 이해해봅시다.</p><hr><h2 id=simulationhttpsgithubcomd3d3-forcesimulation><a href=https://github.com/d3/d3-force#simulation>Simulation</a></h2><p>Simulation은 <code>nodes</code>에 가해지는 물리적 힘을 계산합니다. <code>d3.forceSimulation()</code> 함수로 simulation을 생성합니다.</p><pre><code class=language-js>const simulation = d3.forceSimulation();
</code></pre><p>Simulation에 그래프의 정점 목록인 <code>nodes</code>와 간선 목록인 <code>links</code>를 등록할 수 있습니다.</p><h3 id=nodes>Nodes</h3><p>먼저 <code>nodes</code>에 대해 알아봅시다. Simulation은 입력한 <code>node</code> 객체에 계산 결과값을 추가합니다. <code>nodes</code> 배열에서 각 <code>node</code>를 인덱스로 관리해도 되지만, 보기 어려우므로 고유 식별자 <code>id</code>를 추가하겠습니다.</p><pre><code class=language-js>const nodes = [...Array(5)].map((_, i) =&gt; ({ id: i + 1 }));
// [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }]

simulation.nodes(nodes);
// nodes [
//   {
//     id: 1,
//     index: 0,
//     vx: x.xx,
//     vy: x.xx,
//     x: x.xx,
//     y: x.xx,
//   }
//   , ...
// ]
</code></pre><p>Simulation은 <code>node</code>에 <code>index</code>와 함께 좌표값인 <code>x</code>, <code>y</code> 그리고 속도값인 <code>vx</code>, <code>vy</code>를 추가합니다. 원본 <code>node</code> 객체 자체를 수정해야하므로 <a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions>non-extensible한 객체</a>는 사용할 수 없습니다. 만약 불변성 유지가 필요하다면 객체를 복사하여 전달해야 합니다.</p><h3 id=links>Links</h3><p>그럼 이제 <code>links</code>를 등록해봅시다. d3-force에서 <code>link</code> 객체는 방향성을 지닌 간선이므로 <code>source</code>와 <code>target</code>을 가진 객체로 선언합니다. <code>nodes</code>와 달리 각 property는 객체가 아닌 <code>node</code>를 식별할 <code>id</code>를 갖습니다.</p><pre><code class=language-js>const links = [
  { source: 1, target: 4 },
  { source: 3, target: 4 },
  { source: 2, target: 5 },
  { source: 4, target: 1 },
  { source: 5, target: 4 },
];

simulation.force('link', d3.forceLink(links).id(({ id }) =&gt; id));
// links [
//   {
//     index: 1,
//     source: {
//       id: 3
//       index: 2
//       vx: x.xx,
//       vy: x.xx,
//       x: x.xx,
//       y: x.xx,
//     },
//     target: {
//       ...
//     },
//   }, ...
// ]
</code></pre><p>나중에 <a href=#forces>Forces</a> 챕터에서 다시 만나겠지만, <code>links</code>는 <code>nodes</code>에 작용할 힘을 제공하므로 <code>force</code>로 추가합니다. <code>links</code>를 simulation에 추가하면 <code>source</code>, <code>target</code>에 설정된 <code>id</code>를 동일한 <code>id</code>를 가진 <code>node</code> 객체로 대체합니다. (코드에 나와 있듯 <a href=https://github.com/d3/d3-force#link_id>link.id()</a> 함수로 지정해야 합니다.)</p><h3 id=tick>Tick</h3><p>Simulation에 <code>nodes</code>와 <code>links</code>를 등록해봤습니다. <code>tick</code> 이벤트에 핸들러 함수를 등록하여 매 <code>tick</code>마다 실행할 코드를 작성할 수 있습니다. Simulation은 생성 직후 곧바로 실행됩니다. 필요하다면 <a href=https://github.com/d3/d3-force#simulation_stop><code>simulation.stop()</code></a> 함수로 정지하거나 <a href=https://github.com/d3/d3-force#simulation_restart><code>simulation.restart()</code></a>로 재시작할 수 있습니다.</p><p><code>tick</code> 이벤트 핸들러를 등록하여 <code>node</code>에 저장된 결과값을 확인해봅시다.</p><pre><code class=language-js>simulation.on('tick', () =&gt; {
  console.log(nodes[0]);
});
// 첫 번째 tick: {id: 1, index: 0, x: 5.826695986913618, y: -4.292216192303559, vy: -4.292216192303559, …}
// 두 번째 tick: {id: 1, index: 0, x: 4.820993020602418, y: -8.04960224695047, vy: -3.7573860546469113, …}
// 세 번째 tick: {id: 1, index: 0, x: 4.188865598751164, y: -10.465829270778734, vy: -2.4162270238282635, …}
// 네 번째 tick: {id: 1, index: 0, x: 3.823314491169919, y: -11.82585404923582, vy: -1.3600247784570867, …}
// ...
</code></pre><p>Simulation은 <code>tick</code> 단위마다 좌표값을 계산합니다. 우린 simulation에 의해 <code>tick</code>마다 계산된 절대 좌표값(x, y)를 화면에 그려주기만 하면 됩니다. 그리는 건 나중에 d3-selection과 함께 알아보겠습니다.</p><h3 id=alpha>Alpha</h3><p>Simulation을 얼마나 진행할 지 결정하는 <code>alpha</code>, <code>alphaMin</code>, <code>alphaDecay</code>, <code>alphaTarget</code>, <code>velocityDecay</code> 속성에 대해 알아보겠습니다. 문서에 주어진 <code>alpha</code>의 정의는 설명도 부실하고 이해하기 꽤 어려우니 <a href=https://github.com/d3/d3-force/blob/main/src/simulation.js>구현 코드</a>를 보며 동작 방식을 알아봅시다. 주어진 속성의 초기값은 다음과 같습니다.</p><pre><code class=language-js>var simulation,
    alpha = 1,
    alphaMin = 0.001,
    alphaDecay = 1 - Math.pow(alphaMin, 1 / 300) // 0.02276277904418933
    alphaTarget = 0,
    velocityDecay = 0.6,
    // ...
</code></pre><p><code>alpha</code>는 매 <code>tick</code>마다 <code>alpha += (alphaTarget - alpha) * alphaDecay</code>로 계산되어 감소합니다. 또한, 매 <code>tick</code>마다 <code>alpha</code>와 <code>alphaMin</code>를 비교합니다. <code>alpha</code>가 <code>alphaMin</code>보다 작아질 때까지 simulation을 실행합니다.</p><pre><code class=language-js>simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9772372209558107    = 1 + (0 - 1) * 0.02276277904418933;
  // 002: 0.9549925860214359    = alpha + (alphaTarget - alpha) * alphaDecay
  // ...
  // 300: 0.0009999999999999966 종료: alphaMin(0.001) 미만
});
</code></pre><p><code>alphaTarget</code>은 <code>alpha</code>의 도달 목표입니다. <code>alpha</code>는 <code>alphaTarget</code>에 도달할 때까지 감소합니다. <code>alphaTarget</code>이 <code>alphaMin</code>보다 크다면 <code>alpha</code>가 <code>alphaMin</code>에 도달할 수 없으므로 simulation은 종료되지 않고 계속 실행됩니다. 나중에 d3-drag를 적용할 때 이용할 수 있습니다.</p><p>아래 코드에서 <code>alphaTarget</code>으로 <code>alpha</code>가 <code>1</code>부터 <code>0.5</code>까지 감소하도록 설정했습니다. 하지만 <code>alpha</code>가 <code>0.6</code> 미만으로 감소했을 때 simulation이 종료되므로 <code>0.5</code>까지 감소할 일은 없습니다.</p><pre><code class=language-js>simulation.alphaMin(0.6).alphaTarget(0.5);
simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9886186104779053
  // 002: 0.9774962930107179
  // ...
  // 070: 0.5997631157484438 종료: alphaMin(0.6) 미만
});
</code></pre><p>아래 코드에선 <code>alpha</code>가 <code>0.4</code> 이하로 감소해야만 종료됩니다. 하지만, <code>alphaTarget</code>에 의해 <code>0.4</code>보다 작아질 수 없습니다. 고로, simulation이 종료되지 않습니다.</p><pre><code class=language-js>simulation.alphaMin(0.4).alphaTarget(0.5);
simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9886186104779053
  // 002: 0.9774962930107179
  // ...
  // 300: 0.5005000000000002
  // 301: 진행 중...
});
</code></pre><p><code>alphaDecay</code>는 <code>alpha</code>의 감소량입니다. 수가 클수록 <code>alpha</code>는 <code>alphaMin</code>에 빠르게 도달합니다.</p><p><code>velocityDecay</code>는 <code>node.vx</code>, <code>node.vy</code> 값의 감소량입니다. 구현 코드에선 <code>node.x += node.vx *= velocityDecay;</code>로 작성되어 있는데, <code>node.vx *= velocityDecay</code>를 먼저 연산하고 <code>node.x += node.vx</code>를 연산합니다. <code>0</code>으로 설정하면 simulation이 종료될 때까지 속도를 계속 유지합니다.</p><hr><h2 id=forceshttpsgithubcomd3d3-forceforces><a href=https://github.com/d3/d3-force#forces>Forces</a></h2><p>Forces는 simulation에서 <code>node</code>에 적용할 물리적 힘입니다. 척력 혹은 인력을 적용하거나, 일정 거리를 유지하게끔 합니다. 몇가지 모듈을 이용해 force를 적용할 수 있습니다. Links, many-body, centering, collision, positioning에 대해 알아봅시다.</p><h3 id=linkshttpsgithubcomd3d3-forcelinks><a href=https://github.com/d3/d3-force#links>Links</a></h3><p>Link force는 <code>node</code>를 연결하고 일정 거리를 유지하는 힘입니다. 위에서 언급했듯 <code>simulation.force()</code>와 <code>d3.forceLink()</code>로 생성합니다. 이 과정에서 <code>distance</code>와 <code>strength</code>를 이용해 거리와 거리를 유지할 힘을 결정합니다.</p><pre><code class=language-js>const forceLink = d3
  .forceLink(links)
  .id(({ id }) =&gt; id)
  .distance(100)
  .strength(1);

simulation.force('link', forceLink);
</code></pre><p><code>strength</code>는 <code>distance</code>로 설정한 일정 거리를 유지하는 힘입니다. <code>0</code>부터 <code>1</code> 사이를 추천합니다</p><h3 id=many-bodyhttpsgithubcomd3d3-forcemany-body><a href=https://github.com/d3/d3-force#many-body>Many-Body</a></h3><p>Many Body force는 <code>nodes</code>에 척력 혹은 인력을 적용합니다. <code>simulation.force()</code>와 <code>d3.forceManyBody()</code>로 생성합니다. 이 또한, <code>strength</code>로 적용할 힘을 결정합니다. 전달한 수가 양수라면 인력, 음수라면 척력입니다.</p><pre><code class=language-js>const forceManyBody = d3
  .forceManyBody()
  .strength(-300);

simulation.force('manyBody', forceManyBody);
</code></pre><p>참고로 많은 예시에서 <code>force('manyBody', forceManyBody)</code>가 아닌 <code>force('charge', forceCharge)</code>로 되어있지만 이름은 전혀 중요하지 않습니다. 단순히 식별자 역할을 수행하므로 다른 force와 구분만 가능하면 됩니다.</p><h3 id=centeringhttpsgithubcomd3d3-forcecentering><a href=https://github.com/d3/d3-force#centering>Centering</a></h3><p>Centering force는 <code>nodes</code>의 중심이 지정한 좌표(x, y)에 위치하도록 합니다. <code>simulation.force()</code>와 <code>d3.forceCenter()</code>로 생성합니다. Viewport 상에서 정중앙에 위치해야 할 때 적용합니다. <code>strength</code>를 이용하면 부드러운 움직임이 가능합니다.</p><pre><code class=language-js>const forceCenter = d3
  .forceCenter(width / 2, height / 2)
  .strength(0.1);

simulation.force('center', forceCenter);
</code></pre><p><code>resize</code> 이벤트 혹은 <a href=https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver>ResizeObserver</a>로 크기 변경을 감지하고 <code>nodes</code>가 항상 중앙에 위치하도록 할 수 있습니다.</p><h3 id=collisionhttpsgithubcomd3d3-forcecollision><a href=https://github.com/d3/d3-force#collision>Collision</a></h3><p>Collision force는 <code>nodes</code>가 서로 겹치는 것을 방지하는 힘입니다. <code>simulation.force()</code>와 <code>d3.forceCollide()</code>로 생성합니다. <code>node</code>를 점이 아닌 원으로 취급하여 충돌 여부를 확인하고 <code>radius</code>로 원의 반지름을 결정합니다. <code>strength</code>로 겹칠 때 서로 밀어낼 힘을 결정합니다.</p><pre><code class=language-js>const forceCollide = d3
  .forceCollide()
  .radius(5)
  .strength(0.8);

simulation.force('collide', forceCollide);
</code></pre><h3 id=positioninghttpsgithubcomd3d3-forcepositioning><a href=https://github.com/d3/d3-force#positioning>Positioning</a></h3><p>Positioning force는 지정한 좌표(x, y)로 <code>nodes</code>를 밀어내는 힘입니다. <code>simulation.force()</code>와 <code>d3.forceX()</code> 그리고 <code>d3.forceY()</code>로 생성합니다. <code>strength</code>로 밀어내는 힘을 결정합니다.</p><pre><code class=language-js>const forceX = d3.forceX().strength(1);
const forceY = d3.forceY(height / 2);

simulation.force('x', forceX).force('y', forceY);
</code></pre><p><code>d3.forceRadial()</code> 함수는 원형을 기준으로 밀어내는 힘을 생성합니다. <code>strength</code>로 밀어내는 힘을 결정합니다.</p><pre><code class=language-js>const forceRadial = d3
  .forceRadial(100, width / 2, height / 2)
  .strength(0.5);

simulation.force('radial', forceRadial);
</code></pre><hr><h2 id=conclusion>Conclusion</h2><p>d3-force의 개념과 동작 방식을 코드와 함께 살펴보았습니다. d3-force의 simulation, tick을 조절할 수 있는 alpha 그리고 force의 종류에 대해서 알아봤습니다. 처음 볼 땐 어려워보일 수 있겠지만 알아야 할 개념이 그리 많지 않고 이해하기 쉬운 코드와 패턴으로 금방 익힐 수 있었습니다.</p><p>아직 d3-selection를 다루지 않아 계산 결과값으로 그래프를 그려보진 않았습니다만, 다음 시간에 d3-selection을 학습하면서 SVG로 그래프를 그려보고 이후 d3-zoom과 d3-drag를 적용해보도록 하겠습니다.</p><hr><h2 id=references>References</h2><ul><li><a href=https://github.com/d3/d3-force>d3-force</a></li><li><a href=https://stackoverflow.com/q/46426072/9735184>What is the difference between alphaTarget and alphaMin?</a></li></ul></article><script src=https://giscus.app/client.js data-repo=jinyongp/jinyongp.dev data-repo-id=R_kgDOHJDtcg data-category=Comments data-category-id=DIC_kwDOHJDtcs4CXf7o data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=ko crossorigin=anonymous async></script></div></main><footer class="absolute bottom-0 w-full"><div class="flex justify-center py-8"><p class=[&_a]:text-accent>© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a>.</p></div></footer><div id=js-scroll-back-to-top class="back-to-top hide fixed bottom-10 right-10 rounded-full w-10 h-10 bg-accent grid place-items-center cursor-pointer"><i class="fa-solid fa-arrow-up text-white"></i></div></body></html>