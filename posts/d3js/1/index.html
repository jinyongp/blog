<!doctype html><html lang=ko><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://jinyongp.dev><meta name=naver-site-verification content="c36f259891f25bc92e3884c1ceb626a0aaa76146"><link rel=alternate type=application/rss+xml href=https://jinyongp.dev/feed.xml title=jinyongp.dev><meta name=author content="jinyongp <dev.jinyongp@gmail.com>"><link rel=manifest href=/manifest.webmanifest><meta name=mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="jinyongp.dev"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta property="og:site_name" content="jinyongp.dev"><meta property="og:title" content="Simulating Physical Forces"><meta property="og:type" content="website"><meta property="og:url" content="https://jinyongp.dev/posts/d3js/1/"><meta property="og:description" content="d3-force의 개념과 동작 방식을 코드와 함께 살펴봅니다."><meta name=description content="d3-force의 개념과 동작 방식을 코드와 함께 살펴봅니다."><title>Simulating Physical Forces</title><link rel=icon href=https://jinyongp.dev/favicon.png><link rel=stylesheet href=https://jinyongp.dev/main.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><style>:root{--accent:65 105 225;--font:Raleway}</style><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/nord.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.highlightAll(),hljs.configure({ignoreUnescapedHTML:!0})</script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PFTW4CN")</script><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/js/sw.js").then(function(e){console.log("ServiceWorker registration successful with scope: ",e.active)}).catch(function(e){console.log("ServiceWorker registration failed: ",e)})</script><script src=/js/main.js></script></head><body><nav class=shadow-md><div class="layout flex justify-between text-gray-600"><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=/>Home</a></li><li class=hover:text-accent><a href=/posts class=text-accent>Posts</a></li><li class=hover:text-accent><a href=/series>Series</a></li><li class=hover:text-accent><a href=/learn>Learn</a></li></ul><ul class="flex gap-4 py-4"><li class="hover:text-accent grid place-items-center"><a class=text-xl href=mailto:dev.jinyongp@gmail.com><i><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><path d="M64 112c-8.8.0-16 7.2-16 16v22.1L220.5 291.7c20.7 17 50.4 17 71.1.0L464 150.1V128c0-8.8-7.2-16-16-16H64zM48 212.2V384c0 8.8 7.2 16 16 16H448c8.8.0 16-7.2 16-16V212.2L322 328.8c-38.4 31.5-93.7 31.5-132 0L48 212.2zM0 128C0 92.7 28.7 64 64 64H448c35.3.0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3.0-64-28.7-64-64V128z"/></svg></i></a></li><li class="hover:text-accent grid place-items-center"><a class=text-xl href=https://github.com/jinyongp/><i><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></i></a></li></ul></div></nav><main class=pb-24><div class=layout><header class="relative text-center flex flex-col items-stretch justify-center"><h1 class="mt-16 mb-12">Simulating Physical Forces</h1><div class="flex justify-between items-center"><div><a href=https://jinyongp.dev/tags/d3.js><kbd class="text-xs bg-accent text-white rounded px-1 py-0.5">d3.js</kbd></a></div><h6>Written on Apr 14, 2022</h6></div><hr class="my-4 w-full"></header><div class="text-slate-500 grid grid-cols-1 gap-2 md:gap-20 md:grid-cols-2"><div></div><div><a href=/posts/d3js/2/ class="flex flex-col gap-1 border border-current text-current rounded p-2 hover:text-accent text-right"><div class="flex items-center gap-1 [&_span]:font-bold justify-end"><span>NEXT</span>
<i class=mb-0.5><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></svg></i></div><span class="truncate whitespace-nowrap">Data Driven Transformation of DOM</span></a></div></div><hr class=my-4><article class="content [&_hr]:my-4"><h1 id=introduction>Introduction</h1><p><a class=underline-lsre href=https://github.com/d3/d3-force target=_blank rel="noopener noreferrer nofollow">d3-force</a>
는 입자(<code>nodes</code>) 간에 가해지는 물리적 힘(forces)을 simulation하여 입자의 좌표값을 계산하고 제공합니다.</p><p>코드와 함께 <a class=underline-lsre href=#simulation target=_blank rel="noopener noreferrer nofollow">Simulation</a>
과 <a class=underline-lsre href=#forces target=_blank rel="noopener noreferrer nofollow">Forces</a>
에 대해 이해해봅시다.</p><hr><h2 id=simulationhttpsgithubcomd3d3-forcesimulation><a class=underline-lsre href=https://github.com/d3/d3-force#simulation target=_blank rel="noopener noreferrer nofollow">Simulation</a></h2><p>Simulation은 <code>nodes</code>에 가해지는 물리적 힘을 계산합니다. <code>d3.forceSimulation()</code> 함수로 simulation을 생성합니다.</p><pre><code class=language-js>const simulation = d3.forceSimulation();
</code></pre><p>Simulation에 그래프의 정점 목록인 <code>nodes</code>와 간선 목록인 <code>links</code>를 등록할 수 있습니다.</p><h3 id=nodes>Nodes</h3><p>먼저 <code>nodes</code>에 대해 알아봅시다. Simulation은 입력한 <code>node</code> 객체에 계산 결과값을 추가합니다. <code>nodes</code> 배열에서 각 <code>node</code>를 인덱스로 관리해도 되지만, 보기 어려우므로 고유 식별자 <code>id</code>를 추가하겠습니다.</p><pre><code class=language-js>const nodes = [...Array(5)].map((_, i) =&gt; ({ id: i + 1 }));
// [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }]

simulation.nodes(nodes);
// nodes [
//   {
//     id: 1,
//     index: 0,
//     vx: x.xx,
//     vy: x.xx,
//     x: x.xx,
//     y: x.xx,
//   }
//   , ...
// ]
</code></pre><p>Simulation은 <code>node</code>에 <code>index</code>와 함께 좌표값인 <code>x</code>, <code>y</code> 그리고 속도값인 <code>vx</code>, <code>vy</code>를 추가합니다. 원본 <code>node</code> 객체 자체를 수정해야하므로 <a class=underline-lsre href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions target=_blank rel="noopener noreferrer nofollow">non-extensible한 객체</a>
는 사용할 수 없습니다. 만약 불변성 유지가 필요하다면 객체를 복사하여 전달해야 합니다.</p><h3 id=links>Links</h3><p>그럼 이제 <code>links</code>를 등록해봅시다. d3-force에서 <code>link</code> 객체는 방향성을 지닌 간선이므로 <code>source</code>와 <code>target</code>을 가진 객체로 선언합니다. <code>nodes</code>와 달리 각 property는 객체가 아닌 <code>node</code>를 식별할 <code>id</code>를 갖습니다.</p><pre><code class=language-js>const links = [
  { source: 1, target: 4 },
  { source: 3, target: 4 },
  { source: 2, target: 5 },
  { source: 4, target: 1 },
  { source: 5, target: 4 },
];

simulation.force('link', d3.forceLink(links).id(({ id }) =&gt; id));
// links [
//   {
//     index: 1,
//     source: {
//       id: 3
//       index: 2
//       vx: x.xx,
//       vy: x.xx,
//       x: x.xx,
//       y: x.xx,
//     },
//     target: {
//       ...
//     },
//   }, ...
// ]
</code></pre><p>나중에 <a class=underline-lsre href=#forces target=_blank rel="noopener noreferrer nofollow">Forces</a>
챕터에서 다시 만나겠지만, <code>links</code>는 <code>nodes</code>에 작용할 힘을 제공하므로 <code>force</code>로 추가합니다. <code>links</code>를 simulation에 추가하면 <code>source</code>, <code>target</code>에 설정된 <code>id</code>를 동일한 <code>id</code>를 가진 <code>node</code> 객체로 대체합니다. (코드에 나와 있듯 <a class=underline-lsre href=https://github.com/d3/d3-force#link_id target=_blank rel="noopener noreferrer nofollow">link.id()</a>
함수로 지정해야 합니다.)</p><h3 id=tick>Tick</h3><p>Simulation에 <code>nodes</code>와 <code>links</code>를 등록해봤습니다. <code>tick</code> 이벤트에 핸들러 함수를 등록하여 매 <code>tick</code>마다 실행할 코드를 작성할 수 있습니다. Simulation은 생성 직후 곧바로 실행됩니다. 필요하다면 <a class=underline-lsre href=https://github.com/d3/d3-force#simulation_stop target=_blank rel="noopener noreferrer nofollow"><code>simulation.stop()</code></a>
함수로 정지하거나 <a class=underline-lsre href=https://github.com/d3/d3-force#simulation_restart target=_blank rel="noopener noreferrer nofollow"><code>simulation.restart()</code></a>
로 재시작할 수 있습니다.</p><p><code>tick</code> 이벤트 핸들러를 등록하여 <code>node</code>에 저장된 결과값을 확인해봅시다.</p><pre><code class=language-js>simulation.on('tick', () =&gt; {
  console.log(nodes[0]);
});
// 첫 번째 tick: {id: 1, index: 0, x: 5.826695986913618, y: -4.292216192303559, vy: -4.292216192303559, …}
// 두 번째 tick: {id: 1, index: 0, x: 4.820993020602418, y: -8.04960224695047, vy: -3.7573860546469113, …}
// 세 번째 tick: {id: 1, index: 0, x: 4.188865598751164, y: -10.465829270778734, vy: -2.4162270238282635, …}
// 네 번째 tick: {id: 1, index: 0, x: 3.823314491169919, y: -11.82585404923582, vy: -1.3600247784570867, …}
// ...
</code></pre><p>Simulation은 <code>tick</code> 단위마다 좌표값을 계산합니다. 우린 simulation에 의해 <code>tick</code>마다 계산된 절대 좌표값(x, y)를 화면에 그려주기만 하면 됩니다. 그리는 건 나중에 d3-selection과 함께 알아보겠습니다.</p><h3 id=alpha>Alpha</h3><p>Simulation을 얼마나 진행할 지 결정하는 <code>alpha</code>, <code>alphaMin</code>, <code>alphaDecay</code>, <code>alphaTarget</code>, <code>velocityDecay</code> 속성에 대해 알아보겠습니다. 문서에 주어진 <code>alpha</code>의 정의는 설명도 부실하고 이해하기 꽤 어려우니 <a class=underline-lsre href=https://github.com/d3/d3-force/blob/main/src/simulation.js target=_blank rel="noopener noreferrer nofollow">구현 코드</a>
를 보며 동작 방식을 알아봅시다. 주어진 속성의 초기값은 다음과 같습니다.</p><pre><code class=language-js>var simulation,
    alpha = 1,
    alphaMin = 0.001,
    alphaDecay = 1 - Math.pow(alphaMin, 1 / 300) // 0.02276277904418933
    alphaTarget = 0,
    velocityDecay = 0.6,
    // ...
</code></pre><p><code>alpha</code>는 매 <code>tick</code>마다 <code>alpha += (alphaTarget - alpha) * alphaDecay</code>로 계산되어 감소합니다. 또한, 매 <code>tick</code>마다 <code>alpha</code>와 <code>alphaMin</code>를 비교합니다. <code>alpha</code>가 <code>alphaMin</code>보다 작아질 때까지 simulation을 실행합니다.</p><pre><code class=language-js>simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9772372209558107    = 1 + (0 - 1) * 0.02276277904418933;
  // 002: 0.9549925860214359    = alpha + (alphaTarget - alpha) * alphaDecay
  // ...
  // 300: 0.0009999999999999966 종료: alphaMin(0.001) 미만
});
</code></pre><p><code>alphaTarget</code>은 <code>alpha</code>의 도달 목표입니다. <code>alpha</code>는 <code>alphaTarget</code>에 도달할 때까지 감소합니다. <code>alphaTarget</code>이 <code>alphaMin</code>보다 크다면 <code>alpha</code>가 <code>alphaMin</code>에 도달할 수 없으므로 simulation은 종료되지 않고 계속 실행됩니다. 나중에 d3-drag를 적용할 때 이용할 수 있습니다.</p><p>아래 코드에서 <code>alphaTarget</code>으로 <code>alpha</code>가 <code>1</code>부터 <code>0.5</code>까지 감소하도록 설정했습니다. 하지만 <code>alpha</code>가 <code>0.6</code> 미만으로 감소했을 때 simulation이 종료되므로 <code>0.5</code>까지 감소할 일은 없습니다.</p><pre><code class=language-js>simulation.alphaMin(0.6).alphaTarget(0.5);
simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9886186104779053
  // 002: 0.9774962930107179
  // ...
  // 070: 0.5997631157484438 종료: alphaMin(0.6) 미만
});
</code></pre><p>아래 코드에선 <code>alpha</code>가 <code>0.4</code> 이하로 감소해야만 종료됩니다. 하지만, <code>alphaTarget</code>에 의해 <code>0.4</code>보다 작아질 수 없습니다. 고로, simulation이 종료되지 않습니다.</p><pre><code class=language-js>simulation.alphaMin(0.4).alphaTarget(0.5);
simulation.on('tick', () =&gt; {
  console.log(simulation.alpha());
  // 001: 0.9886186104779053
  // 002: 0.9774962930107179
  // ...
  // 300: 0.5005000000000002
  // 301: 진행 중...
});
</code></pre><p><code>alphaDecay</code>는 <code>alpha</code>의 감소량입니다. 수가 클수록 <code>alpha</code>는 <code>alphaMin</code>에 빠르게 도달합니다.</p><p><code>velocityDecay</code>는 <code>node.vx</code>, <code>node.vy</code> 값의 감소량입니다. 구현 코드에선 <code>node.x += node.vx *= velocityDecay;</code>로 작성되어 있는데, <code>node.vx *= velocityDecay</code>를 먼저 연산하고 <code>node.x += node.vx</code>를 연산합니다. <code>0</code>으로 설정하면 simulation이 종료될 때까지 속도를 계속 유지합니다.</p><hr><h2 id=forceshttpsgithubcomd3d3-forceforces><a class=underline-lsre href=https://github.com/d3/d3-force#forces target=_blank rel="noopener noreferrer nofollow">Forces</a></h2><p>Forces는 simulation에서 <code>node</code>에 적용할 물리적 힘입니다. 척력 혹은 인력을 적용하거나, 일정 거리를 유지하게끔 합니다. 몇가지 모듈을 이용해 force를 적용할 수 있습니다. Links, many-body, centering, collision, positioning에 대해 알아봅시다.</p><h3 id=linkshttpsgithubcomd3d3-forcelinks><a class=underline-lsre href=https://github.com/d3/d3-force#links target=_blank rel="noopener noreferrer nofollow">Links</a></h3><p>Link force는 <code>node</code>를 연결하고 일정 거리를 유지하는 힘입니다. 위에서 언급했듯 <code>simulation.force()</code>와 <code>d3.forceLink()</code>로 생성합니다. 이 과정에서 <code>distance</code>와 <code>strength</code>를 이용해 거리와 거리를 유지할 힘을 결정합니다.</p><pre><code class=language-js>const forceLink = d3
  .forceLink(links)
  .id(({ id }) =&gt; id)
  .distance(100)
  .strength(1);

simulation.force('link', forceLink);
</code></pre><p><code>strength</code>는 <code>distance</code>로 설정한 일정 거리를 유지하는 힘입니다. <code>0</code>부터 <code>1</code> 사이를 추천합니다</p><h3 id=many-bodyhttpsgithubcomd3d3-forcemany-body><a class=underline-lsre href=https://github.com/d3/d3-force#many-body target=_blank rel="noopener noreferrer nofollow">Many-Body</a></h3><p>Many Body force는 <code>nodes</code>에 척력 혹은 인력을 적용합니다. <code>simulation.force()</code>와 <code>d3.forceManyBody()</code>로 생성합니다. 이 또한, <code>strength</code>로 적용할 힘을 결정합니다. 전달한 수가 양수라면 인력, 음수라면 척력입니다.</p><pre><code class=language-js>const forceManyBody = d3
  .forceManyBody()
  .strength(-300);

simulation.force('manyBody', forceManyBody);
</code></pre><p>참고로 많은 예시에서 <code>force('manyBody', forceManyBody)</code>가 아닌 <code>force('charge', forceCharge)</code>로 되어있지만 이름은 전혀 중요하지 않습니다. 단순히 식별자 역할을 수행하므로 다른 force와 구분만 가능하면 됩니다.</p><h3 id=centeringhttpsgithubcomd3d3-forcecentering><a class=underline-lsre href=https://github.com/d3/d3-force#centering target=_blank rel="noopener noreferrer nofollow">Centering</a></h3><p>Centering force는 <code>nodes</code>의 중심이 지정한 좌표(x, y)에 위치하도록 합니다. <code>simulation.force()</code>와 <code>d3.forceCenter()</code>로 생성합니다. Viewport 상에서 정중앙에 위치해야 할 때 적용합니다. <code>strength</code>를 이용하면 부드러운 움직임이 가능합니다.</p><pre><code class=language-js>const forceCenter = d3
  .forceCenter(width / 2, height / 2)
  .strength(0.1);

simulation.force('center', forceCenter);
</code></pre><p><code>resize</code> 이벤트 혹은 <a class=underline-lsre href=https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver target=_blank rel="noopener noreferrer nofollow">ResizeObserver</a>
로 크기 변경을 감지하고 <code>nodes</code>가 항상 중앙에 위치하도록 할 수 있습니다.</p><h3 id=collisionhttpsgithubcomd3d3-forcecollision><a class=underline-lsre href=https://github.com/d3/d3-force#collision target=_blank rel="noopener noreferrer nofollow">Collision</a></h3><p>Collision force는 <code>nodes</code>가 서로 겹치는 것을 방지하는 힘입니다. <code>simulation.force()</code>와 <code>d3.forceCollide()</code>로 생성합니다. <code>node</code>를 점이 아닌 원으로 취급하여 충돌 여부를 확인하고 <code>radius</code>로 원의 반지름을 결정합니다. <code>strength</code>로 겹칠 때 서로 밀어낼 힘을 결정합니다.</p><pre><code class=language-js>const forceCollide = d3
  .forceCollide()
  .radius(5)
  .strength(0.8);

simulation.force('collide', forceCollide);
</code></pre><h3 id=positioninghttpsgithubcomd3d3-forcepositioning><a class=underline-lsre href=https://github.com/d3/d3-force#positioning target=_blank rel="noopener noreferrer nofollow">Positioning</a></h3><p>Positioning force는 지정한 좌표(x, y)로 <code>nodes</code>를 밀어내는 힘입니다. <code>simulation.force()</code>와 <code>d3.forceX()</code> 그리고 <code>d3.forceY()</code>로 생성합니다. <code>strength</code>로 밀어내는 힘을 결정합니다.</p><pre><code class=language-js>const forceX = d3.forceX().strength(1);
const forceY = d3.forceY(height / 2);

simulation.force('x', forceX).force('y', forceY);
</code></pre><p><code>d3.forceRadial()</code> 함수는 원형을 기준으로 밀어내는 힘을 생성합니다. <code>strength</code>로 밀어내는 힘을 결정합니다.</p><pre><code class=language-js>const forceRadial = d3
  .forceRadial(100, width / 2, height / 2)
  .strength(0.5);

simulation.force('radial', forceRadial);
</code></pre><hr><h2 id=conclusion>Conclusion</h2><p>d3-force의 개념과 동작 방식을 코드와 함께 살펴보았습니다. d3-force의 simulation, tick을 조절할 수 있는 alpha 그리고 force의 종류에 대해서 알아봤습니다. 처음 볼 땐 어려워보일 수 있겠지만 알아야 할 개념이 그리 많지 않고 이해하기 쉬운 코드와 패턴으로 금방 익힐 수 있었습니다.</p><p>아직 d3-selection를 다루지 않아 계산 결과값으로 그래프를 그려보진 않았습니다만, 다음 시간에 d3-selection을 학습하면서 SVG로 그래프를 그려보고 이후 d3-zoom과 d3-drag를 적용해보도록 하겠습니다.</p><hr><h2 id=references>References</h2><ul><li><a class=underline-lsre href=https://github.com/d3/d3-force target=_blank rel="noopener noreferrer nofollow">d3-force</a></li><li><a class=underline-lsre href=https://stackoverflow.com/q/46426072/9735184 target=_blank rel="noopener noreferrer nofollow">What is the difference between alphaTarget and alphaMin?</a></li></ul></article><script src=https://giscus.app/client.js data-repo=jinyongp/jinyongp.dev data-repo-id=R_kgDOHJDtcg data-category=Comments data-category-id=DIC_kwDOHJDtcs4CXf7o data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=ko crossorigin=anonymous async></script></div></main><footer class="absolute bottom-0 w-full"><div class="flex justify-center py-8"><p class="[&_a]:text-accent text-center text-sm">Copyright 2023. Jinyong Park. All rights reserved.<br><span class=text-xs>Powered by <a class=underline-lsre href=https://gohugo.io target=_blank rel="noopener noreferrer nofollow">Hugo</a>
.</span></p></div></footer><div id=js-scroll-back-to-top class="back-to-top hide fixed bottom-10 right-10 rounded-full w-10 h-10 bg-white border border-accent grid place-items-center cursor-pointer"><i class=text-accent><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 576 512"><path d="M288 0c17.7.0 32 14.3 32 32V49.7C451.8 63.4 557.7 161 573.9 285.9c2 15.6-17.3 24.4-27.8 12.7C532.1 283 504.8 272 480 272c-38.7.0-71 27.5-78.4 64.1-1.7 8.7-8.7 15.9-17.6 15.9s-15.8-7.2-17.6-15.9C359 299.5 326.7 272 288 272s-71 27.5-78.4 64.1c-1.7 8.7-8.7 15.9-17.6 15.9s-15.8-7.2-17.6-15.9C167 299.5 134.7 272 96 272c-24.8.0-52.1 11-66.1 26.7C19.4 310.4.1 301.5 2.1 285.9 18.3 161 124.2 63.4 256 49.7V32c0-17.7 14.3-32 32-32zm0 304c12.3.0 23.5 4.6 32 12.2V430.6c0 45-36.5 81.4-81.4 81.4-30.8.0-59-17.4-72.8-45l-2.3-4.7c-7.9-15.8-1.5-35 14.3-42.9s35-1.5 42.9 14.3l2.3 4.7c3 5.9 9 9.6 15.6 9.6 9.6.0 17.4-7.8 17.4-17.4V316.2c8.5-7.6 19.7-12.2 32-12.2z"/></svg></i></div></body></html>