<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on jinyongp.dev</title><link>https://jinyongp.dev/posts/</link><description>Recent content in Posts on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Sat, Aug 12 09:52:24 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/posts/feed.xml" rel="self" type="application/rss+xml"/><item><title>Template Method Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/3/</link><pubDate>Sat, Aug 12 09:52:24 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/3/</guid><description>&lt;p>&lt;strong>Template Method Pattern&lt;/strong>은 특정 알고리즘을 반복적으로 사용하고 있을 때 중복을 제거하기 위하여 적용해볼 수 있습니다. 공통 알고리즘을 묶을 템플릿 메서드를 포함할 추상 클래스를 정의하고, 하위 클래스에서 구체적인 내용을 작성하는 패턴입니다. 해당 패턴을 통해 코드 중복을 제거하고 공통된 알고리즘을 재사용할 수 있습니다. 템플릿 메서드의 변경이 필요하다면 하위 클래스에서 재정의를 통해 인터페이스의 변경 없이 세부 구현을 변경할 수도 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Template Method Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Template Method Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>AbstractClass(추상 클래스): 템플릿 메서드를 정의하고 하위 클래스에서 구현할 메서드를 정의합니다.&lt;/li>
&lt;li>ConcreteClass(구현 클래스): 추상 클래스에서 정의한 추상 메서드를 구현합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 예제를 Swift 코드로 작성해봅시다. AbstractClass 역할을 수행하는 &lt;code>AbstractDisplay&lt;/code> 클래스를 정의합니다. &lt;code>AbstractDisplay&lt;/code> 클래스는 템플릿 메서드인 &lt;code>display&lt;/code> 메서드를 정의하고 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol AbstractDisplay {
func open()
func write()
func close()
}
extension AbstractDisplay {
func display() {
open()
for _ in 0..&amp;lt;5 {
write()
}
close()
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>AbstractClass&lt;/code>는 추상 클래스이므로 구현되어 있는 메서드가 존재하고 인스턴스를 생성할 수 없어야 합니다. &lt;code>protocol&lt;/code>과 &lt;code>extension&lt;/code> 키워드를 활용하여 추상 클래스를 정의하였습니다. &lt;code>display&lt;/code> 탬플릿 메서드를 사용하고 싶다면, &lt;code>AbstractClass&lt;/code>를 채택하고 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class CharDisplay: AbstractDisplay {
private let char: Character
init(char: Character) {
self.char = char
}
func open() {
print(&amp;#34;&amp;lt;&amp;lt;&amp;#34;, terminator: &amp;#34;&amp;#34;)
}
func write() {
print(char, terminator: &amp;#34;&amp;#34;)
}
func close() {
print(&amp;#34;&amp;gt;&amp;gt;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = CharDisplay(char: &amp;#34;H&amp;#34;)
display.display()
// output:
// &amp;lt;&amp;lt;HHHHH&amp;gt;&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>AbstractDisplay&lt;/code>를 채택하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>display&lt;/code> 메서드를 구현하지 않았지만, &lt;code>AbstractDisplay&lt;/code>의 &lt;code>display&lt;/code> 메서드를 사용할 수 있습니다.&lt;/p>
&lt;p>또 다른 클래스를 정의해봅니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class StringDisplay: AbstractDisplay {
private let string: String
private let width: Int
init(string: String) {
self.string = string
self.width = string.count
}
func open() {
printLine()
}
func write() {
print(&amp;#34;|\(string)|&amp;#34;)
}
func close() {
printLine()
}
private func printLine() {
print(&amp;#34;&amp;#43;\(String(repeating: &amp;#34;-&amp;#34;, count: width))&amp;#43;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = StringDisplay(string: &amp;#34;Hello, World&amp;#34;)
display.display()
// output:
// &amp;#43;-------------&amp;#43;
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// &amp;#43;-------------&amp;#43;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇듯 하나의 공통적인 로직을 템플릿화하여 코드의 중복을 없앨 수 있고, 추상 클래스를 상속(채택)하는 방식으로 인하여 상위 클래스 형식의 변수에 하위 클래스 인스턴스 중 어느 것을 대입해도 제대로 동작해야 한다는 원칙인 &lt;code>리스코프 치환 원칙(LSP, Liskov Substitution Principle)&lt;/code>을 만족합니다.&lt;/p>
&lt;p>Swift에서는 &lt;code>extension&lt;/code> 키워드의 존재로 인터페이스를 변경하지 않고도 쉽게 새로운 공통 로직을 언제든 추가할 수 있습니다.&lt;/p></description></item><item><title>Adapter Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/2/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/2/</guid><description>&lt;p>&lt;strong>Adapter Pattern&lt;/strong>을 활용하면 외부 라이브러리의 인터페이스와 내가 사용하고자 하는 인터페이스가 호환되지 않을 때, 중간에 Adapter를 추가하는 방법으로 호환성을 확보할 수 있습니다. Wrapper Pattern으로 불리기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Adapter Pattern&lt;/code>은 GoF의 분류 체계에서 구조(Structural) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Adapter Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Target(대상): 서비스 내에서 사용 중인 인터페이스입니다.&lt;/li>
&lt;li>Client(의뢰자): Target을 사용하는 클래스입니다.&lt;/li>
&lt;li>Adaptee(적응 대상자): Target과 호환되지 않는 인터페이스입니다.&lt;/li>
&lt;li>Adapter(적응자): Adaptee를 Target으로 변환하는 클래스입니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Adapter를 구현하는 방법은 상속을 이용한 방법과 위임(인스턴스)을 이용한 방법으로 나뉘지만 &lt;code>Is-A&lt;/code>보단 &lt;code>Has-A&lt;/code>가 더 좋은 방법이므로 위임을 이용한 방법을 사용하도록 합니다. &lt;a
class="underline-lsre"
href="https://www.google.com/search?q=is-a&amp;#43;has-a&amp;#43;relationship"
target="_blank" rel="noopener noreferrer nofollow"
>Is-A Has-A Relationship&lt;/a
>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>예시를 통해 자세히 알아보겠습니다. 시스템 내에서 사용 중인 로깅 인터페이스가 있다고 가정해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Logger {
func log(message: String)
func warn(message: String)
func error(message: String)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Logger&lt;/code>는 Adapter Pattern의 구성 요소 중 Target 역할을 수행합니다. 이를 채택하는 클래스 &lt;code>MyLogger&lt;/code>를 구현합니다. &lt;code>MyLogger&lt;/code>는 Swift의 &lt;code>print()&lt;/code>함수를 이용하여 Termianl 환경에서 로그를 출력합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct MyLogger: Logger {
func log(message: String) {
print(&amp;#34;[LOG] \(message)&amp;#34;)
}
func warn(message: String) {
print(&amp;#34;[WARN] \(message)&amp;#34;)
}
func error(message: String) {
print(&amp;#34;[ERROR] \(message)&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Client 역할을 수행하는 &lt;code>App&lt;/code> 클래스에서 Logger 구현체를 주입받아 시스템 전체에 걸쳐 사용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// App.swift
final class App {
private let logger: Logger
init(logger: Logger) {
self.logger = logger
}
func doSomething() {
logger.log(message: &amp;#34;doSomething&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// main.swift
let app = App(logger: MyLogger())
app.doSomething()
// output:
// [LOG] doSomething&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>MyLogger&lt;/code>는 swift의 &lt;code>print()&lt;/code> 함수에 의존하고 있습니다. 이제 외부 라이브러리를 통해 terminal 환경이 아닌 외부로 로그 정보를 보내려고 합니다. 외부 라이브러리 &lt;code>ExternalLogger&lt;/code>는 다음 인터페이스를 제공합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">enum LogLevel {
case debug
case info
case warn
case error
}
struct ExternalLogger {
func log(level: LogLevel, message: String) {
// 로그를 외부로 전송합니다.
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>언뜻 보기에도 &lt;code>ExternalLogger&lt;/code>는 &lt;code>Logger&lt;/code>와 호환되지 않는 것을 알 수 있습니다. 이럴 때 Adapter 클래스를 추가하여 호환성을 확보할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct ExternalLoggerAdapter: Logger {
private let logger = ExternalLogger()
func log(message: String) {
logger.log(level: .info, message: message)
}
func warn(message: String) {
logger.log(level: .warn, message: message)
}
func error(message: String) {
logger.log(level: .error, message: message)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let app = App(logger: ExternalLoggerAdapter())
app.doSomething()&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇게 Adapter 역할을 수행하는 중간자 클래스를 추가하여 세부 구현에 어떠한 변경도 없이 세부 구현에 어떠한 변경도 없이 확장에 성공하였습니다. 이런 식으로 Adapter 구조체를 추가하면 변경이 아닌 확장(OCP - 개방 폐쇄 원칙)이 되어 Side Effect도 없을 뿐더러 Unit Test를 작성하기도 쉬워집니다.&lt;/p></description></item><item><title>Iterator Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/1/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/1/</guid><description>&lt;p>&lt;strong>Iterator Pattern&lt;/strong>은 순회 로직을 순회자(Iterator) 객체로 분리합니다. 이러한 추상화 작업을 통해 순회 불가능한 객체더라도 인터페이스만 구현한다면 순회 가능한 객체로 만들 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Iterator Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>예를 들어, 자료구조 중 배열은 메모리 구조의 특징 덕분에 0..&amp;lt;배열크기 범위로 인덱스를 증가시키며 요소에 접근할 수 있습니다. 허나 리스트의 경우엔 순회 로직을 직접 구현하지 않는 한 인덱스를 이용한 순회가 불가능합니다. 리스트 클래스를 순회 가능한 객체로 만들기 위해선 별도의 구현을 추가해야 합니다. 여기서 Iterator Pattern을 적용한다면 리스트 클래스의 세부 구현을 변경하지 않고도 순회 가능한 객체로 확장할 수 있습니다.&lt;/p>
&lt;p>Iterator Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Iterator(반복자): 순회 로직을 추상화한 인터페이스입니다. 다음 요소를 반환하는 &lt;code>next()&lt;/code> 메서드와 현재 요소가 마지막 요소인지 확인하는 &lt;code>hasNext()&lt;/code> 메서드를 포함합니다.&lt;/li>
&lt;li>ConcreteIterator(구체적인 반복자): Iterator 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;li>Aggregate(집합체): 순회 가능한 객체임을 나타내는 인터페이스입니다. ConcreteIterator 객체를 생성하여 반환하는 &lt;code>makeIterator()&lt;/code> 메서드를 포함하기도 합니다. (aka. Iterable)&lt;/li>
&lt;li>ConcreteAggregate(구체적인 집합체): Aggregate 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 Iterator Pattern 예제를 Swift로 작성해보았습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Iterable&amp;lt;Element&amp;gt; {
associatedtype Element where Element == Iter.Element
associatedtype Iter: Iterator
func makeIterator() -&amp;gt; Iter;
}
protocol Iterator&amp;lt;Element&amp;gt; {
associatedtype Element
mutating func next() -&amp;gt; Element?
}
struct Book {
private(set) var name: String
}
struct BookShelf {
private var books: [Book] = []
var count: Int { books.count }
func book(at index: Int) -&amp;gt; Book {
return books[index]
}
mutating func add(book: Book) {
books.append(book)
}
}
extension BookShelf: Iterable {
typealias Element = Book
typealias Iter = BookShelfIterator
func makeIterator() -&amp;gt; Iter {
return BookShelfIterator(self)
}
}
struct BookShelfIterator: Iterator {
typealias Element = Book
private let bookShelf: BookShelf
private var index: Int
init(_ bookShelf: BookShelf) {
self.bookShelf = bookShelf
index = 0
}
mutating func next() -&amp;gt; Element? {
if bookShelf.count &amp;gt; index {
defer { index &amp;#43;= 1 }
return bookShelf.book(at: index)
}
return nil
}
}
var bookShelf = BookShelf()
bookShelf.add(book: Book(name: &amp;#34;Book1&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book2&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book3&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book4&amp;#34;))
var iterator = bookShelf.makeIterator()
while let book = iterator.next() {
print(book.name)
}
// output:
// Book1
// Book2
// Book3
// Book4&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>Swift에서는 &lt;code>nil&lt;/code> 값을 제공하므로 &lt;code>hasNext()&lt;/code> 메서드 대신 &lt;code>next()&lt;/code> 메서드가 &lt;code>nil&lt;/code>을 반환하면 순회를 종료하도록 구현합니다.&lt;/p>
&lt;/blockquote>
&lt;p>코드에 따르면 각 구조체는 다음 역할을 따릅니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Iterator&lt;/code>: Iterator&lt;/li>
&lt;li>&lt;code>BookShelfIterator&lt;/code>: ConcreteIterator&lt;/li>
&lt;li>&lt;code>Iterable&lt;/code>: Aggregate&lt;/li>
&lt;li>&lt;code>BookShelf&lt;/code>: ConcreteAggregate&lt;/li>
&lt;/ul>
&lt;p>이렇게 순회를 담당하는 로직을 별도의 클래스로 분리하여 확장성을 높이는 것이 Iterator Pattern의 핵심입니다. 인터페이스를 활용한 이러한 확장성 및 다형성 덕분에 &lt;code>Iterator&lt;/code> 인터페이스만 구현하고 있으면 모든 순회가 필요한 로직에 적용할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이미 Swift에서는 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol&lt;/a
> 프로토콜을 제공하여 어떠한 클래스든 &lt;code>IteratorProtocol&lt;/code>을 채택하여 &lt;code>for in&lt;/code> 구문에 활용할 수 있습니다. (Aggregate 역할을 &lt;code>Sequence&lt;/code> 프로토콜이 수행합니다.)&lt;/p>
&lt;p>Apple 공식 문서의 예제를 가져왔습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct Countdown: Sequence {
let start: Int
func makeIterator() -&amp;gt; CountdownIterator {
return CountdownIterator(self)
}
}
struct CountdownIterator: IteratorProtocol {
let countdown: Countdown
var times = 0
init(_ countdown: Countdown) {
self.countdown = countdown
}
mutating func next() -&amp;gt; Int? {
let nextNumber = countdown.start - times
guard nextNumber &amp;gt; 0 else { return nil }
times &amp;#43;= 1
return nextNumber
}
}
let countdown3 = Countdown(start: 3)
for count in countdown3 {
print(&amp;#34;\(count)...&amp;#34;)
}
// output:
// 3..
// 2..
// 1..&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Countdown&lt;/code>은 ConcreteAggregate 역할을 수행하며, &lt;code>CountdownIterator&lt;/code>는 ConcreteIterator 역할을 수행합니다. 이렇게 순회 로직을 분리하는 방식으로 Collection 형식이 아니라 하더라도 순회 로직을 추가함으로서 순회 가능한 객체를 만들 수 있습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/design-patterns/iterator"
target="_blank" rel="noopener noreferrer nofollow"
>Iterator Pattern : Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol : Apple&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Understanding Delegate Pattern</title><link>https://jinyongp.dev/posts/uikit/1/</link><pubDate>Tue, Aug 01 03:32:29 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/uikit/1/</guid><description>&lt;h2 id="introduce-delegate-pattern" class="flex items-center gap-3">Introduce Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduce Delegate Pattern" href="#introduce-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>UIKit에서는 여러가지 UI 관련 View를 제공합니다. 이 중에선 동작에 필요한 세부 구현은 숨겨진 채로 특정 상황이 발생했을 때만 ViewController에게 데이터를 전달하는 UIView가 있습니다.&lt;/p>
&lt;p>예를 들어 &lt;code>UITextField&lt;/code>의 경우, 사용자가 입력창을 눌렀을 때 OS에게 키보드를 열 것을 명령하며 사용자가 입력한 값을 &lt;code>UITextField&lt;/code>에 전달하는 동작이 구현되어 있을 것입니다. 하지만 ViewController에선 이러한 세부 동작은 알 필요 없이 특정 상황이 발생했을 때만 데이터를 전달 받아 이용하면 됩니다.&lt;/p>
&lt;p>UIkit에서는 이렇게 세부 구현은 숨긴 채로 특정 상황이 발생했음을 알리거나 동작의 제어를 위임하기 위해 Delegate Pattern을 활용하고 있습니다. &lt;code>UITextField&lt;/code>는 &lt;code>UITextFieldDelegate&lt;/code> 프로토콜을 통해 이를 구현하고 있으며, 이를 채택한 ViewController는 다음의 메서드를 구현하여 데이터를 전달받고 동작을 제어할 수 있습니다.&lt;/p>
&lt;p>&lt;code>UITextFieldDelegate&lt;/code>를 채택하여 구현할 수 있는 메서드 목록은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 편집을 시작할 때 호출합니다. Bool 값을 반환하여 편집을 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldBeginEditing(_:) -&amp;gt; Bool
// 편집이 시작된 직후 호출됩니다.
optional func textFieldDidBeginEditing(_:)
// 편집이 종료될 때 호출됩니다. Bool 값을 반환하여 편집을 중지할지 여부를 결정할 수 있습니다.
optional func textFieldShouldEndEditing(_:) -&amp;gt; Bool
// 편집이 종료된 직후 호출됩니다.
optional func textFieldDidEndEditing(_:)
// 텍스트 필드의 문자열이 변경될 때 호출됩니다. Bool 값을 반환하여 변경을 허용할지 여부를 결정할 수 있습니다.
optional func textField(_:shouldChangeCharactersIn:replacementString:) -&amp;gt; Bool
// 텍스트 필드의 선택 영역이 변경될 때 호출됩니다.
optional func textFieldDidChangeSelection(_:)
// 텍스트를 삭제할 때 호출됩니다. Bool 값을 반환하여 삭제를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldClear(_:) -&amp;gt; Bool
// 텍스트 필드의 리턴 키가 눌렸을 때 호출됩니다. Bool 값을 반환하여 리턴 키를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldReturn(_:) -&amp;gt; Bool&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>&lt;code>optional&lt;/code> 키워드로 정의되어 있으니 ViewController는 이 중에서 필요한 메서드만 구현하면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>정의한 메서드가 호출되려면 &lt;code>UITextField&lt;/code> 인스턴스의 &lt;code>delegate&lt;/code> 프로퍼티에 ViewController를 할당해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class ViewController: UIViewController {
private let textField = UITextField()
override func viewDidLoad() {
super.viewDidLoad()
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
// ...
}
func textFieldDidBeginEditing(_ textField: UITextField) {
// ...
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이런 식으로 Delegate Pattern을 통해 동작의 제어권을 위임받을 수 있습니다.&lt;/p>
&lt;h2 id="understand-delegate-pattern" class="flex items-center gap-3">Understand Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Understand Delegate Pattern" href="#understand-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>그렇다면 Delegate Pattern은 어떤 식으로 동작하기에 다른 객체에게 동작의 제어권을 위임할 수 있는걸까요? 간단한 &lt;code>Delegate&lt;/code> 프로토콜을 구현하여 동작을 확인해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool
func textFieldDidBeginEditing(_ textField: UITextField)
}
class UITextField {
var delegate: UITextFieldDelegate?
func userTextFieldTapped() {
guard let delegate else { return }
if delegate.textFieldShouldBeginEditing(self) {
// OS에게 키보드 열기 요청
delegate.textFieldDidBeginEditing(self)
}
}
}
class ViewController {
let textField = UITextField()
func viewDidLoad() {
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
print(#function)
return true
}
func textFieldDidBeginEditing(_ textField: UITextField) {
print(#function)
}
}
let controller = ViewController()
controller.viewDidLoad()
controller.textField.userTextFieldTapped()
// output:
// textFieldShouldBeginEditing(_:)
// textFieldDidBeginEditing(_:)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>소스 코드가 공개되어 있지 않으므로 정확한 세부 구현은 알 수 없으나 Delegate 패턴을 활용한 내부 모습은 대략 위와 비슷할 것으로 추정합니다.&lt;/p>
&lt;p>&lt;code>UITextField&lt;/code>의 경우 외부로부터 주입 받은 &lt;code>delegate&lt;/code> 객체를 통해 &lt;code>textFieldShouldBeginEditing&lt;/code>를 호출하여 동작의 제어권을 위임한 모습입니다. &lt;code>textFieldShouldBeginEditing&lt;/code>에서 &lt;code>false&lt;/code>를 반환하면 &lt;code>textFieldDidBeginEditing&lt;/code>는 호출되지 않을 것입니다.&lt;/p>
&lt;p>이러한 원리를 응용하여 Custom Delegate를 추가할 수 있습니다. &lt;a
class="underline-lsre"
href="https://jinyongp.dev/learn/nbcamp/5#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>Delegate Pattern 적용하기&lt;/a
>&lt;/p></description></item><item><title>Refactoring for Performance (Canvas API)</title><link>https://jinyongp.dev/posts/d3js/4/</link><pubDate>Fri, Apr 22 14:18:15 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/4/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>저번 시리즈에서 필요한 기능은 전부 구현해보았지만, &lt;code>svg&lt;/code> 요소의 개수가 증가할수록 성능이 하락하는 모습을 확인했습니다. 50개의 &lt;code>nodes&lt;/code>에 대해 DevTools로 측정해본 결과, 렌더링 연산에 굉장히 많은 CPU, GPU 작업을 필요로 하고 있었습니다.&lt;/p>
&lt;p>&lt;img src="https://jinyongp.dev/image/posts/d3js/4/d3-force-svg-50-performance.png" alt="SVG 50 Performance">&lt;/p>
&lt;p>이를 해결하기 위해서 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API"
target="_blank" rel="noopener noreferrer nofollow"
>Canvas API&lt;/a
>를 이용할 수 있습니다. Canvas API를 이용하면 d3-selection을 다룰 일은 거의 없습니다. 특히나 이번처럼 단순히 원과 선만 그리면 되는 작업에서는 그리기 더욱 쉽습니다. 대신 zoom과 drag는 구현 방식에 차이가 있어 다소 어려운 점도 있습니다. 그럼 바로 코드와 함께 저번 시간에 작성한 내용을 Canvas API로 리팩토링해보도록 하겠습니다.&lt;/p>
&lt;p>이번 시리즈에선 저번 시리즈에서 완성했던 &lt;code>network&lt;/code> class를 이용합니다.&lt;/p>
&lt;hr>
&lt;h2 id="drawing-canvas" class="flex items-center gap-3">Drawing Canvas &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Drawing Canvas" href="#drawing-canvas"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Canvas API는 말 그대로 &lt;a
class="underline-lsre"
href="https://ko.wikipedia.org/wiki/%EC%BA%94%EB%B2%84%EC%8A%A4"
target="_blank" rel="noopener noreferrer nofollow"
>캔버스&lt;/a
>로 볼 수 있습니다. 그 위에 그림을 그리고 수정이 필요하다면 전부 지우고 다시 그리면 됩니다. 애니메이션이라면 매 프레임마다 지우고 그리기를 반복합니다. 이처럼 d3-force 또한 매 틱마다 반복하면 됩니다.&lt;/p>
&lt;blockquote>
&lt;p>d3.js에 대해서 중점적으로 다루는 프로젝트이므로 Canvas API에 대해 자세한 언급은 없습니다. 이에 대한 내용은 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API"
target="_blank" rel="noopener noreferrer nofollow"
>공식 문서&lt;/a
>를 참고 바랍니다.&lt;/p>
&lt;/blockquote>
&lt;p>Svg 방식에서는 &lt;code>svg&lt;/code> 요소를 생성하고 &lt;code>tick&lt;/code>에서 위치를 변경하는 방식으로 구현했습니다. Canvas 방식에선 그냥 그려주기만 하면 됩니다. 이를 위해 &lt;code>canvas&lt;/code>와 &lt;code>ctx&lt;/code>를 생성하고 &lt;code>tick&lt;/code> 이벤트를 등록해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas = d3.select(&amp;#34;body&amp;#34;)
.append(&amp;#34;canvas&amp;#34;)
.attr(&amp;#34;width&amp;#34;, this.size.w)
.attr(&amp;#34;height&amp;#34;, this.size.h)
.style(&amp;#34;display&amp;#34;, &amp;#34;block&amp;#34;);
this.ctx = this.canvas.node().getContext(&amp;#34;2d&amp;#34;);
this.nodeRadius = 8;
this.simulation = d3
.forceSimulation()
.on(&amp;#34;tick&amp;#34;, this.drawCanvas.bind(this));
}
drawCanvas() {
this.ctx.clearRect(0, 0, this.size.w, this.size.h);
this.ctx.save();
this.drawLinks();
this.drawNodes();
this.ctx.restore();
}
drawNodes() {
console.log(&amp;#34;Drawing Nodes!&amp;#34;);
}
drawLinks() {
console.log(&amp;#34;Drawing Links!&amp;#34;);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>drawCanvas()&lt;/code>, &lt;code>drawNodes()&lt;/code> 그리고 &lt;code>drawLinks()&lt;/code> 함수 내에선 이제 d3-selection 없이 &lt;code>ctx&lt;/code>만으로 그림을 그립니다. 먼저 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>ctx.clearRect()&lt;/code>&lt;/a
>로 &lt;code>canvas&lt;/code>를 전부 지워줍니다. 그리고 &lt;code>drawNodes()&lt;/code>와 &lt;code>drawLinks()&lt;/code>를 호출하여 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 그려줍니다. 이 때, &lt;code>links&lt;/code>를 먼저 그려줘야만 &lt;code>nodes&lt;/code> 뒤에 그려집니다.&lt;/p>
&lt;p>&lt;code>links&lt;/code>는 굉장히 간단하게 그릴 수 있습니다. &lt;code>links&lt;/code>를 순회하면서 선을 그려줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">drawLinks() {
this.links.forEach(({ source, target }) =&amp;gt; {
this.ctx.beginPath();
this.ctx.moveTo(source.x, source.y);
this.ctx.lineTo(target.x, target.y);
this.ctx.stroke();
});
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>nodes&lt;/code>는 저번 시리즈에서 그렸던 것처럼 원 중앙에 &lt;code>id&lt;/code>가 위치하도록 작성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">drawNodes() {
this.nodes.forEach(({ id, x, y }) =&amp;gt; {
this.ctx.beginPath();
this.ctx.arc(x, y, this.nodeRadius, 0, 2 * Math.PI);
this.ctx.lineWidth = 3;
this.ctx.strokeStyle = &amp;#34;blue&amp;#34;;
this.ctx.stroke();
this.ctx.fillStyle = &amp;#34;#fff&amp;#34;;
this.ctx.fill();
this.ctx.textAlign = &amp;#34;center&amp;#34;;
this.ctx.textBaseline = &amp;#34;middle&amp;#34;;
this.ctx.fillStyle = &amp;#34;#000&amp;#34;;
this.ctx.fillText(id, x, y);
});
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>d3-selection 없이 오로지 canvas만 이용하므로 쉽게 그릴 수 있습니다.&lt;/p>
&lt;hr>
&lt;h2 id="panning-and-zooming" class="flex items-center gap-3">Panning and Zooming &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Panning and Zooming" href="#panning-and-zooming"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom을 연결해서 화면을 이동하고 확대, 축소할 수 있도록 구현하겠습니다. Svg 방식에선 요소의 &lt;code>transform&lt;/code> 속성을 변경하여 직접 이동했다면, canvas 방식에선 전부 지우고 위치 이동 후 다시 그려주는 방식으로 구현합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.transform = d3.zoomIdentity;
this.zoom = d3.zoom()
.scaleExtent([0.1, 5])
.on(&amp;#39;zoom&amp;#39;, ({ transform }) =&amp;gt; {
this.transform = transform;
this.drawCanvas();
});
this.canvas.call(this.zoom);
}
drawCanvas() {
this.ctx.clearRect(0, 0, this.size.w, this.size.h);
this.ctx.save();
this.ctx.translate(this.transform.x, this.transform.y);
this.ctx.scale(this.transform.k, this.transform.k);
this.drawLinks();
this.drawNodes();
this.ctx.restore();
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoomIdentity"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>d3.zoomIdentity&lt;/code>&lt;/a
>는 &lt;code>{ k: 1, x: 0, y: 0 }&lt;/code>인 객체입니다. 이를 이용해 &lt;code>transform&lt;/code> 변수를 생성한 뒤, &lt;code>zoom&lt;/code> 이벤트로 얻은 &lt;code>transform&lt;/code>을 저장합니다. 그 후, &lt;code>drawCanvas()&lt;/code>를 호출하여 &lt;code>ctx.translate()&lt;/code>와 &lt;code>ctx.scale()&lt;/code> 함수를 이용해 변경한 위치에 그리도록 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="focusing" class="flex items-center gap-3">Focusing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Focusing" href="#focusing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>특정 요소를 클릭했을 때, 해당 요소를 포커싱하는 동작을 구현해보도록 하겠습니다. Canvas는 개별 요소를 선택할 수 없어서 요소에 커서 스타일을 적용하거나 클릭 이벤트를 적용하는데 어려움이 있습니다. 하지만, d3.js에서 제공하는 기능의 조합으로 쉽게 구현할 수 있습니다.&lt;/p>
&lt;p>개별 요소가 아닌 &lt;code>canvas&lt;/code> 자체에 클릭 이벤트를 등록합니다. 그렇게 얻은 &lt;code>event&lt;/code>로부터 클릭 좌표를 얻어 해당 위치에 존재하는 &lt;code>node&lt;/code>를 찾고, 해당 &lt;code>node&lt;/code>로 이동하고 확대합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas.on(&amp;#34;click&amp;#34;, ({ x, y }) =&amp;gt; {
const node = this.findNode(x, y);
if (!node) return;
this.canvas
.transition()
.duration(500)
.call(this.zoom.translateTo, node.x, node.y)
.transition()
.call(this.zoom.scaleTo, 3);
});
}
findNode(x, y) {
const [ix, iy] = this.transform.invert([x, y]);
return this.simulation.find(ix, iy, this.nodeRadius);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>canvas&lt;/code>에 &lt;code>click&lt;/code> 이벤트를 등록하여 &lt;code>event&lt;/code> 객체로부터 클릭한 위치인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표를 얻었습니다.&lt;/p>
&lt;p>&lt;code>findNode()&lt;/code> 메서드는 주어진 좌표에 &lt;code>node&lt;/code>가 존재하는지 확인하고 해당 &lt;code>node&lt;/code>를 반환합니다. &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#transform_invert"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>transform.invert()&lt;/code>&lt;/a
>는 주어진 절대 좌표에 현재 &lt;code>transform&lt;/code> 좌표값을 포함하여 계산하고 반환합니다. 이를 이용해야만 변경된 &lt;code>transform&lt;/code>을 적용한 좌표를 얻을 수 있습니다. &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_find"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.find()&lt;/code>&lt;/a
>는 주어진 좌표에서 가장 가까이에 위치한 &lt;code>node&lt;/code>를 검색하여 반환합니다. &lt;code>node&lt;/code>의 반지름을 제공하여 해당 요소를 클릭해야만 &lt;code>node&lt;/code>를 찾을 수 있도록 하였습니다.&lt;/p>
&lt;p>&lt;code>node&lt;/code>를 찾았다면, &lt;code>zoom.translate&lt;/code>로 해당 &lt;code>node&lt;/code> 위치로 이동한 후 확대합니다.&lt;/p>
&lt;hr>
&lt;h2 id="dragging" class="flex items-center gap-3">Dragging &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Dragging" href="#dragging"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-drag를 연결하여 요소를 드래그하는 기능을 추가해보도록 하겠습니다. Svg 방식에서는 &lt;code>circles&lt;/code>에 drag를 부착하여 모든 요소에 대해 이벤트를 등록했습니다. Canvas 방식에서는 그런 방법이 불가능하기 때문에, &lt;code>canvas&lt;/code>에 등록하면서 동시에 클릭한 요소를 검색하는 &lt;code>subject&lt;/code>를 설정해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.drag = d3
.drag()
.subject(({ x, y }) =&amp;gt; this.findNode(x, y))
.on(&amp;#34;start&amp;#34;, () =&amp;gt; {
this.canvas.style(&amp;#34;cursor&amp;#34;, &amp;#34;grabbing&amp;#34;);
this.simulation.alphaTarget(0.1).restart();
})
.on(&amp;#34;drag&amp;#34;, (event) =&amp;gt; {
const [x, y] = d3.pointer(event);
event.subject.fx = this.transform.invertX(x);
event.subject.fy = this.transform.invertY(y);
})
.on(&amp;#34;end&amp;#34;, ({ subject }) =&amp;gt; {
this.canvas.style(&amp;#34;cursor&amp;#34;, &amp;#34;default&amp;#34;);
this.simulation.alphaTarget(0);
subject.fx = null;
subject.fy = null;
});
this.canvas.call(this.drag);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag#drag_subject"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>drag.subject()&lt;/code>&lt;/a
>는 드래그하려는 주체 &lt;code>node&lt;/code>를 선택할 때 이용합니다. &lt;code>findNode()&lt;/code> 함수로 검색한 &lt;code>node&lt;/code>를 &lt;code>subject&lt;/code>로 설정합니다. 설정 이후, &lt;code>event&lt;/code> 객체에서 &lt;code>subject&lt;/code> property에 선택한 &lt;code>node&lt;/code>가 등록됩니다.&lt;/p>
&lt;p>Drag 이벤트에 등록한 함수는 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag#drag-events"
target="_blank" rel="noopener noreferrer nofollow"
>첫 번째 인자로 &lt;code>event&lt;/code> 객체&lt;/a
>를 가집니다. Canvas 방식의 경우 개별 요소가 아닌 canvas에 등록되었기 때문에 &lt;code>event.x&lt;/code>와 &lt;code>event.y&lt;/code>의 값이 canvas 기준으로 생성됩니다. 클릭 위치 기반으로 좌표를 가져오기 위해 &lt;code>event.sourceEvent&lt;/code> 객체를 이용해야하므로 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection#pointer"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>d3.pointer()&lt;/code>를 이용&lt;/a
>해 좌표를 가져옵니다. 그리고 &lt;code>transform&lt;/code>을 적용하여 &lt;code>subject&lt;/code>의 고정 좌표를 변경합니다.&lt;/p>
&lt;p>&lt;code>start&lt;/code>와 &lt;code>end&lt;/code> 이벤트에서 &lt;code>cursor&lt;/code> 스타일을 변경해주고 있습니다. 다만, 요소에 마우스를 올렸을 때도 스타일을 변경해주기 위해 &lt;code>pointermove&lt;/code> 이벤트를 추가해주었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas.on(&amp;#34;pointermove&amp;#34;, ({ x, y, buttons }) =&amp;gt; {
if (buttons) return;
const node = this.findNode(x, y);
this.canvas.style(&amp;#34;cursor&amp;#34;, node ? &amp;#34;pointer&amp;#34; : &amp;#34;default&amp;#34;);
});
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>event.buttons&lt;/code>는 현재 마우스를 클릭한 상태인지 판별하여 드래그 중일 땐 무시하도록 합니다. &lt;code>node&lt;/code>가 위치하는 곳에서만 &lt;code>pointer&lt;/code> 스타일을 갖도록 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>저번 시리즈에서 작성한 코드를 Canvas로 작성해보았습니다. 이제 요소의 개수를 많이 추가하더라도 성능 하락의 모습을 보이지 않는 걸 확인할 수 있습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="qBpwbbR" data-editable="true" data-user="jinyongp" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/qBpwbbR">
D3 Force (w/ Canvas)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>성능 향상을 위해 여태까지 작업했던 내용을 Canvas API로 다시 작성해보았습니다. 단순히 그려보는 건 쉬웠지만 zoom과 drag 기능을 적용하는 건 여러 시행착오를 거쳐야했고 다양한 함수를 적용할 필요가 있어 svg 구현 방식보다 어려움을 겪었습니다.&lt;/p>
&lt;p>성능을 측정해보겠습니다. 50개의 &lt;code>node&lt;/code>를 테스트했던 svg 방식과 달리 200개의 &lt;code>node&lt;/code>를 생성하고 측정해봤음에도 굉장한 성능 향상을 보여줍니다. 대부분은 함수 실행 시간이고 랜더링 연산은 거의 영향을 미치지 않습니다.&lt;/p>
&lt;p>&lt;img src="https://jinyongp.dev/image/posts/d3js/4/d3-force-canvas-200-performance.png" alt="Canvas 200 Performance">&lt;/p>
&lt;p>지금까지 d3-force, selection, zoom, drag 등 다양한 d3.js 모듈을 사용해보았고 Canvas API로 작성해보며 성능 향상 또한 진행해보았습니다. d3.js에는 이 외에도 무수히 많은 모듈이 있습니다. 데이터를 시각화하는데 무궁무궁진 잠재력을 지닌만큼 더 다양하게 활용해보며 여러 프로젝트에서 활용해보시면 좋을 듯 싶습니다. 긴 글 읽어주셔서 감사합니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
target="_blank" rel="noopener noreferrer nofollow"
>MDN - CanvasRenderingContext2D&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Panning, Zooming and Dragging</title><link>https://jinyongp.dev/posts/d3js/3/</link><pubDate>Thu, Apr 21 11:16:27 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/3/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom"
target="_blank" rel="noopener noreferrer nofollow"
>d3-zoom&lt;/a
>과 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag"
target="_blank" rel="noopener noreferrer nofollow"
>d3-drag&lt;/a
>는 사용자가 마우스 클릭 혹은 터치로 화면을 제어하거나 요소를 이동하는 기능을 제공합니다.&lt;/p>
&lt;p>이번 시리즈 또한 마찬가지로 저번 시리즈에 구현했던 코드에 d3-zoom과 d3-drag를 결합하는 걸 목표로 하여 그에 필요한 부분만 다루도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="d3-zoom" class="flex items-center gap-3">d3-zoom &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="d3-zoom" href="#d3-zoom"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom은 사용자가 화면을 드래그 혹은 스크롤하여 현재 보는 범위를 이동, 확대, 축소하는 기능을 제공합니다. 혹은, 특정 요소를 선택했을 때 그 위치로 이동하면서 포커스하는 효과를 줄 수도 있습니다.&lt;/p>
&lt;h3 id="panning-and-zooming" class="flex items-center gap-3">Panning and Zooming &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Panning and Zooming" href="#panning-and-zooming"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>d3-zoom은 d3-selection과 연계하여 구현합니다. &lt;code>Selection&lt;/code> 객체에 zoom 기능을 제공하기 위해 &lt;code>d3.zoom()&lt;/code> 함수를 호출하여 전달합니다. 저번 시리즈에서 생성한 &lt;code>root&lt;/code> 요소를 가져와 zoom 기능을 추가해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const zoom = d3
.zoom()
.on(&amp;#39;zoom&amp;#39;, (event) =&amp;gt; {
console.log(&amp;#39;Zoom and Drag!&amp;#39;);
});
root.call(zoom);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>d3.zoom()&lt;/code> 함수는 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 생성하여 반환합니다. &lt;code>root.call(zoom)&lt;/code>을 호출함으로써 인자로 받은 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom/blob/1bccd3fd56ea24e9658bd7e7c24e9b89410c8967/src/zoom.js#L72-L83"
target="_blank" rel="noopener noreferrer nofollow"
>객체에 여러 property와 event를 등록&lt;/a
>하게 됩니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection#selection_call"
target="_blank" rel="noopener noreferrer nofollow"
>selection.call()&lt;/a
>은 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 인자로 받습니다. &lt;code>root.call(zoom)&lt;/code>은 다음 코드와 동일합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">zoom(root);&lt;/code>&lt;/pre>
&lt;/div>
&lt;/blockquote>
&lt;p>&lt;code>root&lt;/code> 요소를 드래그하거나 스크롤을 해보면 이벤트에 등록한 함수가 실행됩니다. &lt;code>zoom&lt;/code> 이벤트에 등록할 함수를 작성하여 요소를 이동시켜봅시다.&lt;/p>
&lt;p>전달한 함수는 &lt;code>event&lt;/code> 객체를 매개변수로 가집니다. 클릭 이동인지 스크롤인지에 따라 종류가 달라집니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">// MouseEvent
sourceEvent: MouseEvent {...}
target: ƒ y(t)
transform: Jx {k: x.xx, x: x.xx, y: x.xx}
type: &amp;#34;zoom&amp;#34;
// WheelEvent
sourceEvent: WheelEvent {...}
target: ƒ y(t)
transform: Jx {k: x.xx, x: x.xx, y: x.xx}
type: &amp;#34;zoom&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이 중에서 scale factor인 &lt;code>k&lt;/code> 와 translation 값인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code>를 얻을 수 있는 &lt;code>transform&lt;/code> 객체를 이용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">.on(&amp;#39;zoom&amp;#39;, ({ transform }) =&amp;gt; {
nodeGroup.attr(&amp;#39;transform&amp;#39;, transform);
linkGroup.attr(&amp;#39;transform&amp;#39;, transform);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>저번 시리즈에서 생성한 &lt;code>nodeGroup&lt;/code>과 &lt;code>linkGroup&lt;/code>은 &lt;code>svg&lt;/code> 요소를 가지는 &lt;code>Selection&lt;/code> 객체로 &lt;code>transform&lt;/code> 속성을 변경하여 위치와 크기를 조절할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>transform&lt;/code>은 객체인데 그대로 전달할 수 있는 이유는 적용될 때 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#transform_toString"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>transform.toString()&lt;/code>함수가 호출되어 &lt;code>&amp;quot;translate(x,y) scale(k)&amp;quot;&lt;/code> 형태의 문자열로 변환&lt;/a
>되기 때문입니다.&lt;/p>
&lt;/blockquote>
&lt;p>화면을 드래그하여 이동하고 스크롤하여 확대, 축소할 수 있습니다.&lt;/p>
&lt;h3 id="focusing" class="flex items-center gap-3">Focusing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Focusing" href="#focusing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>그럼 특정 요소를 클릭했을 때 해당 요소를 포커스하는 동작에 대해 구현해보겠습니다. 일단 &lt;code>Selection&lt;/code> 객체에 이벤트를 등록하기 위해선 &lt;code>selection.on()&lt;/code> 메서드를 호출합니다. 저번 시리즈에서 생성한 &lt;code>circles&lt;/code>를 가져오겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">circles.on(&amp;#39;click&amp;#39;, (event, node) =&amp;gt; {
console.log(&amp;#39;Click!&amp;#39;);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>click&lt;/code> 이벤트에 등록한 함수는 &lt;code>event&lt;/code>와 &lt;code>node&lt;/code> 객체를 매개변수로 가집니다. &lt;code>node&lt;/code>의 현재 위치 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표로 이동 및 확대해야 하므로 이를 이용합니다.&lt;/p>
&lt;p>사용자의 조작이 아닌 코드를 통해 특정 좌표로 이동하고 확대하기 위해선 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoom_translateTo"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>zoom.translateTo&lt;/code>&lt;/a
>와 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoom_scaleTo"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>zoom.scaleTo&lt;/code>&lt;/a
> 함수를 이용합니다. 해당 함수는 첫 번째 인자로 &lt;code>Selection&lt;/code> 객체를 전달받으므로 &lt;code>selection.call()&lt;/code> 함수로 호출할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">circles.on(&amp;#39;click&amp;#39;, (_, { x, y }) =&amp;gt; {
root
.transition()
.duration(500)
.call(zoom.translateTo, x, y)
.transition()
.call(zoom.scaleTo, 3);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>circles&lt;/code> 요소를 클릭하면 클릭한 &lt;code>circle&lt;/code>의 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표를 가져옵니다. 그리고 &lt;code>zoom.translateTo&lt;/code>와 &lt;code>zoom.scaleTo&lt;/code>가 &lt;code>root&lt;/code> 요소의 zoom 상태를 변경합니다. &lt;code>transition&lt;/code>과 &lt;code>duration&lt;/code>은 zoom이 이동할 때 transition 효과를 주어 보다 자연스러운 움직임을 제공합니다.&lt;/p>
&lt;hr>
&lt;h2 id="d3-drag" class="flex items-center gap-3">d3-drag &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="d3-drag" href="#d3-drag"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-drag는 요소를 클릭하여 드래그하는 기능을 제공합니다.&lt;/p>
&lt;h3 id="dragging" class="flex items-center gap-3">Dragging &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Dragging" href="#dragging"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>d3-drag 또한 d3-selection에 기능을 제공합니다. &lt;code>d3.drag()&lt;/code> 함수는 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 생성하여 반환합니다. 추가로, 드래그하기 위해서 필요한 세 가지 이벤트를 등록해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const drag = d3
.drag()
.on(&amp;#34;start&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Drag Start!&amp;#39;);
})
.on(&amp;#34;drag&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Dragging!&amp;#39;);
})
.on(&amp;#34;end&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Drag End!&amp;#39;);
});
circles.call(drag);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>요소를 클릭하면 &lt;code>start&lt;/code> 이벤트가 발생하고, 클릭 후 드래그하면 &lt;code>drag&lt;/code> 이벤트 그리고 클릭을 떼면 &lt;code>end&lt;/code> 이벤트가 발생합니다. 이벤트에 등록한 모든 함수는 클릭 이벤트 객체와 클릭한 요소의 정보를 매개변수로 가집니다.&lt;/p>
&lt;p>요소를 클릭하여 드래그할 때 simulation은 계속 실행 중인 상태여야 합니다. d3-force 시리즈에서 언급한 내용으로 simulation을 종료하지 않고 계속 실행하려면 &lt;code>alphaTarget&lt;/code>을 이용해야 합니다.&lt;/p>
&lt;p>또한, 요소가 다른 요소와 상관없이 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_nodes"
target="_blank" rel="noopener noreferrer nofollow"
>특정 고정 좌표에 위치하도록 하려면 &lt;code>fx&lt;/code>와 &lt;code>fy&lt;/code> 값을 설정&lt;/a
>해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const drag = d3
.drag()
.on(&amp;#39;start&amp;#39;, (event, node) =&amp;gt; {
nodeGroup.style(&amp;#39;cursor&amp;#39;, &amp;#39;grabbing&amp;#39;);
simulation.alphaTarget(0.1).restart();
})
.on(&amp;#39;drag&amp;#39;, (event, node) =&amp;gt; {
node.fx = event.x;
node.fy = event.y;
})
.on(&amp;#39;end&amp;#39;, (event, node) =&amp;gt; {
nodeGroup.style(&amp;#39;cursor&amp;#39;, &amp;#39;grab&amp;#39;);
simulation.alphaTarget(0);
node.fx = null;
node.fy = null;
});
circles.call(drag);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>클릭할 때 &lt;code>alphaTarget&lt;/code>을 &lt;code>alphaMin&lt;/code>보다 크게 설정하여 simulation이 절대 종료되지 않도록 합니다. &lt;code>alphaTarget&lt;/code> 값이 클수록 다른 요소의 움직임이 커집니다. 클릭을 종료하면 다시 되돌려놓습니다.&lt;/p>
&lt;p>클릭하여 드래그를 시작하면 &lt;code>fx&lt;/code>와 &lt;code>fy&lt;/code> 값을 현재 마우스의 위치로 설정합니다. 클릭을 종료하면 &lt;code>null&lt;/code>로 설정하여 고정 위치를 제거합니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom과 d3-drag를 추가해보았습니다. &lt;code>Network&lt;/code> class를 작성하여 코드를 정리했고 실시간으로 &lt;code>alpha&lt;/code>와 &lt;code>zoom&lt;/code> 상태를 확인하고 제어할 수 있도록 구현하였습니다. &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 추가할 수 있도록 구현하였습니다. 비어있는 채로 &lt;code>ADD&lt;/code>를 클릭하면 새로운 요소가 임의의 요소에 연결됩니다. 그리고 &lt;code>node&lt;/code>의 아이디를 DOM에 그려 &lt;code>node&lt;/code>의 데이터를 어떻게 DOM에 적용할 수 있는지 보여줬습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="mdpoWxa" data-user="jinyongp" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/mdpoWxa">
D3 Force, Zoom, Drag (w/ SVG)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom과 d3-drag를 기존 프로젝트에 연결하는 코드를 작성해보면서 개념과 구현 방법에 대해 알아보았습니다. 여기서 사용해본 기능 말고도 d3는 정말 많은 기능을 제공합니다. 공식 문서에 예시가 살짝 아쉽긴 하지만, 직접 사용해보면서 그 유틸성을 확인해보았으면 합니다.&lt;/p>
&lt;p>&lt;code>ADD&lt;/code> 버튼을 눌러 계속 요소를 추가하다보면 점점 프레임이 떨어지면서 성능이 하락하는 모습을 볼 수 있습니다. 이 문제는 HTML5 Canvas API가 해결할 수 있습니다. 허나, 이 방법도 그리기엔 쉬울지 몰라도 오늘 적용한 zoom과 drag 기능을 추가하는데엔 어려움이 있습니다. 다음 시리즈는 지금까지 구현한 내용을 Canvas API로 리팩토링하면서 전부 알아보도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom"
target="_blank" rel="noopener noreferrer nofollow"
>d3-zoom&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag"
target="_blank" rel="noopener noreferrer nofollow"
>d3-drag&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-transition"
target="_blank" rel="noopener noreferrer nofollow"
>d3-transition&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Data Driven Transformation of DOM</title><link>https://jinyongp.dev/posts/d3js/2/</link><pubDate>Sat, Apr 16 02:47:11 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/2/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection"
target="_blank" rel="noopener noreferrer nofollow"
>d3-selection&lt;/a
>은 데이터를 기반으로 DOM을 조작할 수 있는 다양한 기능을 제공합니다.&lt;/p>
&lt;p>이번 시리즈는 d3-force와 연계하여 Github Follower, Following 관계망 그리기를 목표로 하고 있으므로 구현 과정에서 필요한 부분에 대해서만 다루도록 하겠습니다.&lt;/p>
&lt;p>들어가기 전에 &lt;code>Selection&lt;/code> 객체에 대해 알아봅시다. d3-selection으로 선택한 요소는 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection/blob/main/src/selection/index.js"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>groups&lt;/code>와 &lt;code>parents&lt;/code> property를 갖는 &lt;code>Selection&lt;/code> 객체&lt;/a
>를 생성합니다. &lt;code>Selection&lt;/code> 객체는 선택한 요소를 제어할 수 있는 다양한 메서드를 제공합니다.&lt;/p>
&lt;ul>
&lt;li>요소 선택: selection, select, selectAll, selectChild, selectChildren, filter, merge&lt;/li>
&lt;li>요소 변경: attr, classed, style, property, text, html, append, insert, remove, clone, sort, order, raise, lower&lt;/li>
&lt;li>데이터 연결: data, join, enter, exit, datum&lt;/li>
&lt;li>이벤트 핸들링: on, dispatch&lt;/li>
&lt;li>제어 흐름: each, call, empty, nodes, size, [Symbol.iterator]()&lt;/li>
&lt;/ul>
&lt;p>d3-selection을 이용하여 선택한 요소에 데이터를 연결하고 그 데이터를 기반으로 요소를 제어할 수 있습니다.&lt;/p>
&lt;p>이제 코드와 함께 d3-selection을 이용하여 간단한 그래프를 그려보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="creating-and-editing" class="flex items-center gap-3">Creating and Editing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Creating and Editing" href="#creating-and-editing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>관계망에 사용할 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 브라우저에 그려주기 위해 d3-selection으로 &lt;code>svg&lt;/code>를 생성하고 크기를 설정해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const root = d3
.select(&amp;#39;body&amp;#39;) // === d3.select(document.body)
.append(&amp;#39;svg&amp;#39;)
.attr(&amp;#39;width&amp;#39;, &amp;#39;100%&amp;#39;)
.attr(&amp;#39;height&amp;#39;, &amp;#39;100%&amp;#39;)
.style(&amp;#39;display&amp;#39;, &amp;#39;block&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>body&lt;/code> 요소를 선택하고 하위에 &lt;code>svg&lt;/code> 요소를 추가했습니다. 그리고 &lt;code>attr&lt;/code> 메서드와 &lt;code>style&lt;/code> 메서드로 &lt;code>svg&lt;/code>의 속성과 스타일을 지정했습니다. &lt;code>root&lt;/code>엔 &lt;code>svg&lt;/code> 요소를 담고 있는 &lt;code>Selection&lt;/code> 객체가 할당됩니다.&lt;/p>
&lt;p>&lt;code>root&lt;/code> 아래 &lt;code>links&lt;/code>와 &lt;code>nodes&lt;/code>를 각각 묶을 &lt;code>g&lt;/code> 요소를 생성합니다. (&lt;code>linkGroup&lt;/code>을 먼저 생성해야 뒤에 배치됩니다.)&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const linkGroup = root.append(&amp;#39;g&amp;#39;).attr(&amp;#39;id&amp;#39;, &amp;#39;links&amp;#39;);
const nodeGroup = root.append(&amp;#39;g&amp;#39;).attr(&amp;#39;id&amp;#39;, &amp;#39;nodes&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>id&lt;/code>는 별 다른 역할 없이 식별을 위해 추가해주었습니다.&lt;/p>
&lt;hr>
&lt;h2 id="joining-data" class="flex items-center gap-3">Joining Data &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Joining Data" href="#joining-data"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이제 DOM 요소에 데이터를 연결해봅시다. &lt;code>nodeGroup&lt;/code> 아래 &lt;code>circle&lt;/code>을 배치하고 &lt;code>nodes&lt;/code> 데이터를 연결합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const circles = nodeGroup
.selectAll(&amp;#39;circle&amp;#39;)
.data(nodes)
.join(&amp;#39;circle&amp;#39;)
.attr(&amp;#39;r&amp;#39;, 5)
.attr(&amp;#39;fill&amp;#39;, &amp;#39;blue&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>얼핏 보면 말이 되는 듯하지만 아직 생성도 하지 않은 &lt;code>circle&lt;/code>을 왜 선택하고 있는지 의문이 생깁니다. 각 단계가 생성하는 &lt;code>Selection&lt;/code> 객체를 보고 흐름을 이해해봅시다.&lt;/p>
&lt;p>&lt;code>nodeGroup.selectAll('circle')&lt;/code>은 당연히 빈 &lt;code>Selection&lt;/code> 객체를 반환합니다.&lt;/p>
&lt;blockquote>
&lt;p>💡 당연히 비어있는 &lt;code>Selection&lt;/code> 객체를 받을건데 왜 &lt;code>selectAll&lt;/code>을 쓸까요?&lt;/p>
&lt;p>이후에 &lt;code>nodes&lt;/code>를 추가해야 할 상황이 생긴다면, 기존에 생성되었던 &lt;code>circle&lt;/code> 요소와 &lt;code>nodes&lt;/code>를 비교하여 추가된 &lt;code>node&lt;/code>의 개수만큼 &lt;code>circle&lt;/code> 요소를 추가합니다. 즉, 비교를 위해 선택하는 요소와 생성하는 요소는 동일해야 합니다.&lt;/p>
&lt;/blockquote>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: [NodeList(0)]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>.data(nodes)&lt;/code>는 빈 &lt;code>Selection&lt;/code> 객체에 &lt;code>nodes&lt;/code> 배열의 길이만큼 연결합니다. &lt;code>jt&lt;/code> 객체는 &lt;code>__data__&lt;/code> property에 &lt;code>node&lt;/code> 정보를 갖고 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_enter: [Array(5)]
0: (5) [jt, jt, jt, jt, jt]
_exit: [Array(0)]
0: []
_groups: [Array(5)]
0: (5) [empty × 5]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_enter: Array(1)
0: Array(5)
0: jt {...}
1: jt {...}
2: jt {...}
3: jt {...}
4: jt
namespaceURI: &amp;#34;http://www.w3.org/2000/svg&amp;#34;
ownerDocument: document
__data__: {id: 5, index: 4, x:...}
_exit: [Array(0)]
_groups: [Array(5)]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>.join('circle')&lt;/code>은 &lt;code>.enter().append('circle')&lt;/code>과 동일한 단축 표현입니다. &lt;code>.enter()&lt;/code>까지 실행한 결과는 아래와 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: (5) [jt, jt, jt, jt, jt]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: Array(5)
0: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
1: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
2: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
3: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
4: jt
namespaceURI: &amp;#34;http://www.w3.org/2000/svg&amp;#34;
ownerDocument: document
__data__: {id: 5, index: 4, x: ...}
...
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>enter().append('circle')&lt;/code>까지 실행한 결과는 아래와 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: Array(5)
0: circle
1: circle
2: circle
3: circle
4: circle
__data__: {id: 5, index: 4, x:...}
...
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>circle&lt;/code> 요소가 연결되었고 &lt;code>circle&lt;/code> 내부에 &lt;code>__data__&lt;/code>가 결합되었습니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;code>ticked&lt;/code> 함수 내부에서 DOM 요소와 결합한 &lt;code>node&lt;/code> 객체의 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표 데이터를 이용해 요소를 화면 상에 그려보았습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="MWrxgPB" data-user="jinyongp" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/MWrxgPB">
D3 Force (w/ SVG)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-selection의 개념과 데이터 결합 방법과 흐름에 대해 살펴보았습니다. 저번과 달리 많은 개념에 대해 알아보진 않았지만, 요소를 선택하고 속성을 변경하고 데이터를 결합하는 정말 필요한 내용만 다루면서 d3-force와 연동하여 간단한 그래프를 그려볼 수 있었습니다.&lt;/p>
&lt;p>&lt;code>node&lt;/code>의 데이터가 많아질수록 d3-selection을 더욱 적극적으로 이용할 예정이므로, 그 때를 위해 이번엔 이 정도로 하고 다음 시리즈에선 d3-zoom과 d3-drag를 이용하여 상호작용하는 방법에 대해 알아보겠습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection"
target="_blank" rel="noopener noreferrer nofollow"
>d3-selection&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://bost.ocks.org/mike/join/"
target="_blank" rel="noopener noreferrer nofollow"
>Thinking with Joins&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://lucidar.me/en/d3.js/part-07-data-binding"
target="_blank" rel="noopener noreferrer nofollow"
>D3.js Tutorial - Data Binding&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Simulating Physical Forces</title><link>https://jinyongp.dev/posts/d3js/1/</link><pubDate>Thu, Apr 14 14:20:46 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/1/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force"
target="_blank" rel="noopener noreferrer nofollow"
>d3-force&lt;/a
>는 입자(&lt;code>nodes&lt;/code>) 간에 가해지는 물리적 힘(forces)을 simulation하여 입자의 좌표값을 계산하고 제공합니다.&lt;/p>
&lt;p>코드와 함께 &lt;a
class="underline-lsre"
href="#simulation"
>Simulation&lt;/a
>과 &lt;a
class="underline-lsre"
href="#forces"
>Forces&lt;/a
>에 대해 이해해봅시다.&lt;/p>
&lt;hr>
&lt;h2 id="simulationhttpsgithubcomd3d3-forcesimulation" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation"
target="_blank" rel="noopener noreferrer nofollow"
>Simulation&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Simulation" href="#simulationhttpsgithubcomd3d3-forcesimulation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Simulation은 &lt;code>nodes&lt;/code>에 가해지는 물리적 힘을 계산합니다. &lt;code>d3.forceSimulation()&lt;/code> 함수로 simulation을 생성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const simulation = d3.forceSimulation();&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation에 그래프의 정점 목록인 &lt;code>nodes&lt;/code>와 간선 목록인 &lt;code>links&lt;/code>를 등록할 수 있습니다.&lt;/p>
&lt;h3 id="nodes" class="flex items-center gap-3">Nodes &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Nodes" href="#nodes"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>먼저 &lt;code>nodes&lt;/code>에 대해 알아봅시다. Simulation은 입력한 &lt;code>node&lt;/code> 객체에 계산 결과값을 추가합니다. &lt;code>nodes&lt;/code> 배열에서 각 &lt;code>node&lt;/code>를 인덱스로 관리해도 되지만, 보기 어려우므로 고유 식별자 &lt;code>id&lt;/code>를 추가하겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const nodes = [...Array(5)].map((_, i) =&amp;gt; ({ id: i &amp;#43; 1 }));
// [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }]
simulation.nodes(nodes);
// nodes [
// {
// id: 1,
// index: 0,
// vx: x.xx,
// vy: x.xx,
// x: x.xx,
// y: x.xx,
// }
// , ...
// ]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation은 &lt;code>node&lt;/code>에 &lt;code>index&lt;/code>와 함께 좌표값인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 그리고 속도값인 &lt;code>vx&lt;/code>, &lt;code>vy&lt;/code>를 추가합니다. 원본 &lt;code>node&lt;/code> 객체 자체를 수정해야하므로 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"
target="_blank" rel="noopener noreferrer nofollow"
>non-extensible한 객체&lt;/a
>는 사용할 수 없습니다. 만약 불변성 유지가 필요하다면 객체를 복사하여 전달해야 합니다.&lt;/p>
&lt;h3 id="links" class="flex items-center gap-3">Links &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Links" href="#links"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>그럼 이제 &lt;code>links&lt;/code>를 등록해봅시다. d3-force에서 &lt;code>link&lt;/code> 객체는 방향성을 지닌 간선이므로 &lt;code>source&lt;/code>와 &lt;code>target&lt;/code>을 가진 객체로 선언합니다. &lt;code>nodes&lt;/code>와 달리 각 property는 객체가 아닌 &lt;code>node&lt;/code>를 식별할 &lt;code>id&lt;/code>를 갖습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const links = [
{ source: 1, target: 4 },
{ source: 3, target: 4 },
{ source: 2, target: 5 },
{ source: 4, target: 1 },
{ source: 5, target: 4 },
];
simulation.force(&amp;#39;link&amp;#39;, d3.forceLink(links).id(({ id }) =&amp;gt; id));
// links [
// {
// index: 1,
// source: {
// id: 3
// index: 2
// vx: x.xx,
// vy: x.xx,
// x: x.xx,
// y: x.xx,
// },
// target: {
// ...
// },
// }, ...
// ]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>나중에 &lt;a
class="underline-lsre"
href="#forces"
>Forces&lt;/a
> 챕터에서 다시 만나겠지만, &lt;code>links&lt;/code>는 &lt;code>nodes&lt;/code>에 작용할 힘을 제공하므로 &lt;code>force&lt;/code>로 추가합니다. &lt;code>links&lt;/code>를 simulation에 추가하면 &lt;code>source&lt;/code>, &lt;code>target&lt;/code>에 설정된 &lt;code>id&lt;/code>를 동일한 &lt;code>id&lt;/code>를 가진 &lt;code>node&lt;/code> 객체로 대체합니다. (코드에 나와 있듯 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#link_id"
target="_blank" rel="noopener noreferrer nofollow"
>link.id()&lt;/a
> 함수로 지정해야 합니다.)&lt;/p>
&lt;h3 id="tick" class="flex items-center gap-3">Tick &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Tick" href="#tick"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Simulation에 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 등록해봤습니다. &lt;code>tick&lt;/code> 이벤트에 핸들러 함수를 등록하여 매 &lt;code>tick&lt;/code>마다 실행할 코드를 작성할 수 있습니다. Simulation은 생성 직후 곧바로 실행됩니다. 필요하다면 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_stop"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.stop()&lt;/code>&lt;/a
> 함수로 정지하거나 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_restart"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.restart()&lt;/code>&lt;/a
>로 재시작할 수 있습니다.&lt;/p>
&lt;p>&lt;code>tick&lt;/code> 이벤트 핸들러를 등록하여 &lt;code>node&lt;/code>에 저장된 결과값을 확인해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(nodes[0]);
});
// 첫 번째 tick: {id: 1, index: 0, x: 5.826695986913618, y: -4.292216192303559, vy: -4.292216192303559, …}
// 두 번째 tick: {id: 1, index: 0, x: 4.820993020602418, y: -8.04960224695047, vy: -3.7573860546469113, …}
// 세 번째 tick: {id: 1, index: 0, x: 4.188865598751164, y: -10.465829270778734, vy: -2.4162270238282635, …}
// 네 번째 tick: {id: 1, index: 0, x: 3.823314491169919, y: -11.82585404923582, vy: -1.3600247784570867, …}
// ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation은 &lt;code>tick&lt;/code> 단위마다 좌표값을 계산합니다. 우린 simulation에 의해 &lt;code>tick&lt;/code>마다 계산된 절대 좌표값(x, y)를 화면에 그려주기만 하면 됩니다. 그리는 건 나중에 d3-selection과 함께 알아보겠습니다.&lt;/p>
&lt;h3 id="alpha" class="flex items-center gap-3">Alpha &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Alpha" href="#alpha"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Simulation을 얼마나 진행할 지 결정하는 &lt;code>alpha&lt;/code>, &lt;code>alphaMin&lt;/code>, &lt;code>alphaDecay&lt;/code>, &lt;code>alphaTarget&lt;/code>, &lt;code>velocityDecay&lt;/code> 속성에 대해 알아보겠습니다. 문서에 주어진 &lt;code>alpha&lt;/code>의 정의는 설명도 부실하고 이해하기 꽤 어려우니 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force/blob/main/src/simulation.js"
target="_blank" rel="noopener noreferrer nofollow"
>구현 코드&lt;/a
>를 보며 동작 방식을 알아봅시다. 주어진 속성의 초기값은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">var simulation,
alpha = 1,
alphaMin = 0.001,
alphaDecay = 1 - Math.pow(alphaMin, 1 / 300) // 0.02276277904418933
alphaTarget = 0,
velocityDecay = 0.6,
// ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alpha&lt;/code>는 매 &lt;code>tick&lt;/code>마다 &lt;code>alpha += (alphaTarget - alpha) * alphaDecay&lt;/code>로 계산되어 감소합니다. 또한, 매 &lt;code>tick&lt;/code>마다 &lt;code>alpha&lt;/code>와 &lt;code>alphaMin&lt;/code>를 비교합니다. &lt;code>alpha&lt;/code>가 &lt;code>alphaMin&lt;/code>보다 작아질 때까지 simulation을 실행합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9772372209558107 = 1 &amp;#43; (0 - 1) * 0.02276277904418933;
// 002: 0.9549925860214359 = alpha &amp;#43; (alphaTarget - alpha) * alphaDecay
// ...
// 300: 0.0009999999999999966 종료: alphaMin(0.001) 미만
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alphaTarget&lt;/code>은 &lt;code>alpha&lt;/code>의 도달 목표입니다. &lt;code>alpha&lt;/code>는 &lt;code>alphaTarget&lt;/code>에 도달할 때까지 감소합니다. &lt;code>alphaTarget&lt;/code>이 &lt;code>alphaMin&lt;/code>보다 크다면 &lt;code>alpha&lt;/code>가 &lt;code>alphaMin&lt;/code>에 도달할 수 없으므로 simulation은 종료되지 않고 계속 실행됩니다. 나중에 d3-drag를 적용할 때 이용할 수 있습니다.&lt;/p>
&lt;p>아래 코드에서 &lt;code>alphaTarget&lt;/code>으로 &lt;code>alpha&lt;/code>가 &lt;code>1&lt;/code>부터 &lt;code>0.5&lt;/code>까지 감소하도록 설정했습니다. 하지만 &lt;code>alpha&lt;/code>가 &lt;code>0.6&lt;/code> 미만으로 감소했을 때 simulation이 종료되므로 &lt;code>0.5&lt;/code>까지 감소할 일은 없습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.alphaMin(0.6).alphaTarget(0.5);
simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9886186104779053
// 002: 0.9774962930107179
// ...
// 070: 0.5997631157484438 종료: alphaMin(0.6) 미만
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>아래 코드에선 &lt;code>alpha&lt;/code>가 &lt;code>0.4&lt;/code> 이하로 감소해야만 종료됩니다. 하지만, &lt;code>alphaTarget&lt;/code>에 의해 &lt;code>0.4&lt;/code>보다 작아질 수 없습니다. 고로, simulation이 종료되지 않습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.alphaMin(0.4).alphaTarget(0.5);
simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9886186104779053
// 002: 0.9774962930107179
// ...
// 300: 0.5005000000000002
// 301: 진행 중...
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alphaDecay&lt;/code>는 &lt;code>alpha&lt;/code>의 감소량입니다. 수가 클수록 &lt;code>alpha&lt;/code>는 &lt;code>alphaMin&lt;/code>에 빠르게 도달합니다.&lt;/p>
&lt;p>&lt;code>velocityDecay&lt;/code>는 &lt;code>node.vx&lt;/code>, &lt;code>node.vy&lt;/code> 값의 감소량입니다. 구현 코드에선 &lt;code>node.x += node.vx *= velocityDecay;&lt;/code>로 작성되어 있는데, &lt;code>node.vx *= velocityDecay&lt;/code>를 먼저 연산하고 &lt;code>node.x += node.vx&lt;/code>를 연산합니다. &lt;code>0&lt;/code>으로 설정하면 simulation이 종료될 때까지 속도를 계속 유지합니다.&lt;/p>
&lt;hr>
&lt;h2 id="forceshttpsgithubcomd3d3-forceforces" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#forces"
target="_blank" rel="noopener noreferrer nofollow"
>Forces&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Forces" href="#forceshttpsgithubcomd3d3-forceforces"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Forces는 simulation에서 &lt;code>node&lt;/code>에 적용할 물리적 힘입니다. 척력 혹은 인력을 적용하거나, 일정 거리를 유지하게끔 합니다. 몇가지 모듈을 이용해 force를 적용할 수 있습니다. Links, many-body, centering, collision, positioning에 대해 알아봅시다.&lt;/p>
&lt;h3 id="linkshttpsgithubcomd3d3-forcelinks" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#links"
target="_blank" rel="noopener noreferrer nofollow"
>Links&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Links" href="#linkshttpsgithubcomd3d3-forcelinks"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Link force는 &lt;code>node&lt;/code>를 연결하고 일정 거리를 유지하는 힘입니다. 위에서 언급했듯 &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceLink()&lt;/code>로 생성합니다. 이 과정에서 &lt;code>distance&lt;/code>와 &lt;code>strength&lt;/code>를 이용해 거리와 거리를 유지할 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceLink = d3
.forceLink(links)
.id(({ id }) =&amp;gt; id)
.distance(100)
.strength(1);
simulation.force(&amp;#39;link&amp;#39;, forceLink);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>strength&lt;/code>는 &lt;code>distance&lt;/code>로 설정한 일정 거리를 유지하는 힘입니다. &lt;code>0&lt;/code>부터 &lt;code>1&lt;/code> 사이를 추천합니다&lt;/p>
&lt;h3 id="many-bodyhttpsgithubcomd3d3-forcemany-body" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#many-body"
target="_blank" rel="noopener noreferrer nofollow"
>Many-Body&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Many-Body" href="#many-bodyhttpsgithubcomd3d3-forcemany-body"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Many Body force는 &lt;code>nodes&lt;/code>에 척력 혹은 인력을 적용합니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceManyBody()&lt;/code>로 생성합니다. 이 또한, &lt;code>strength&lt;/code>로 적용할 힘을 결정합니다. 전달한 수가 양수라면 인력, 음수라면 척력입니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceManyBody = d3
.forceManyBody()
.strength(-300);
simulation.force(&amp;#39;manyBody&amp;#39;, forceManyBody);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>참고로 많은 예시에서 &lt;code>force('manyBody', forceManyBody)&lt;/code>가 아닌 &lt;code>force('charge', forceCharge)&lt;/code>로 되어있지만 이름은 전혀 중요하지 않습니다. 단순히 식별자 역할을 수행하므로 다른 force와 구분만 가능하면 됩니다.&lt;/p>
&lt;h3 id="centeringhttpsgithubcomd3d3-forcecentering" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#centering"
target="_blank" rel="noopener noreferrer nofollow"
>Centering&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Centering" href="#centeringhttpsgithubcomd3d3-forcecentering"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Centering force는 &lt;code>nodes&lt;/code>의 중심이 지정한 좌표(x, y)에 위치하도록 합니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceCenter()&lt;/code>로 생성합니다. Viewport 상에서 정중앙에 위치해야 할 때 적용합니다. &lt;code>strength&lt;/code>를 이용하면 부드러운 움직임이 가능합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceCenter = d3
.forceCenter(width / 2, height / 2)
.strength(0.1);
simulation.force(&amp;#39;center&amp;#39;, forceCenter);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>resize&lt;/code> 이벤트 혹은 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"
target="_blank" rel="noopener noreferrer nofollow"
>ResizeObserver&lt;/a
>로 크기 변경을 감지하고 &lt;code>nodes&lt;/code>가 항상 중앙에 위치하도록 할 수 있습니다.&lt;/p>
&lt;h3 id="collisionhttpsgithubcomd3d3-forcecollision" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#collision"
target="_blank" rel="noopener noreferrer nofollow"
>Collision&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Collision" href="#collisionhttpsgithubcomd3d3-forcecollision"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Collision force는 &lt;code>nodes&lt;/code>가 서로 겹치는 것을 방지하는 힘입니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceCollide()&lt;/code>로 생성합니다. &lt;code>node&lt;/code>를 점이 아닌 원으로 취급하여 충돌 여부를 확인하고 &lt;code>radius&lt;/code>로 원의 반지름을 결정합니다. &lt;code>strength&lt;/code>로 겹칠 때 서로 밀어낼 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceCollide = d3
.forceCollide()
.radius(5)
.strength(0.8);
simulation.force(&amp;#39;collide&amp;#39;, forceCollide);&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="positioninghttpsgithubcomd3d3-forcepositioning" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#positioning"
target="_blank" rel="noopener noreferrer nofollow"
>Positioning&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Positioning" href="#positioninghttpsgithubcomd3d3-forcepositioning"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Positioning force는 지정한 좌표(x, y)로 &lt;code>nodes&lt;/code>를 밀어내는 힘입니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceX()&lt;/code> 그리고 &lt;code>d3.forceY()&lt;/code>로 생성합니다. &lt;code>strength&lt;/code>로 밀어내는 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceX = d3.forceX().strength(1);
const forceY = d3.forceY(height / 2);
simulation.force(&amp;#39;x&amp;#39;, forceX).force(&amp;#39;y&amp;#39;, forceY);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>d3.forceRadial()&lt;/code> 함수는 원형을 기준으로 밀어내는 힘을 생성합니다. &lt;code>strength&lt;/code>로 밀어내는 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceRadial = d3
.forceRadial(100, width / 2, height / 2)
.strength(0.5);
simulation.force(&amp;#39;radial&amp;#39;, forceRadial);&lt;/code>&lt;/pre>
&lt;/div>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-force의 개념과 동작 방식을 코드와 함께 살펴보았습니다. d3-force의 simulation, tick을 조절할 수 있는 alpha 그리고 force의 종류에 대해서 알아봤습니다. 처음 볼 땐 어려워보일 수 있겠지만 알아야 할 개념이 그리 많지 않고 이해하기 쉬운 코드와 패턴으로 금방 익힐 수 있었습니다.&lt;/p>
&lt;p>아직 d3-selection를 다루지 않아 계산 결과값으로 그래프를 그려보진 않았습니다만, 다음 시간에 d3-selection을 학습하면서 SVG로 그래프를 그려보고 이후 d3-zoom과 d3-drag를 적용해보도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force"
target="_blank" rel="noopener noreferrer nofollow"
>d3-force&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://stackoverflow.com/q/46426072/9735184"
target="_blank" rel="noopener noreferrer nofollow"
>What is the difference between alphaTarget and alphaMin?&lt;/a
>&lt;/li>
&lt;/ul></description></item></channel></rss>