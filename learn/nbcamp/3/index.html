<!doctype html><html lang=ko><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://jinyongp.dev><meta name=naver-site-verification content="c36f259891f25bc92e3884c1ceb626a0aaa76146"><meta name=author content="jinyongp"><meta property="og:site_name" content="jinyongp.dev"><meta property="og:title" content="[내배캠] Swift 기초 개인 과제"><meta property="og:type" content="website"><meta property="og:url" content="https://jinyongp.dev/learn/nbcamp/3/"><meta property="og:description" content="Swift 기초를 학습하고 간단한 계산기를 제작하는 과제를 수행했습니다."><meta name=description content="Swift 기초를 학습하고 간단한 계산기를 제작하는 과제를 수행했습니다."><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PFTW4CN")</script><title>[내배캠] Swift 기초 개인 과제</title><link rel=icon href=https://jinyongp.dev/favicon.png><link rel=stylesheet href=https://jinyongp.dev/main.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><style>:root{--accent:65 105 225;--font:Raleway}</style><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/hybrid.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.highlightAll(),hljs.configure({ignoreUnescapedHTML:!0})</script><script src=/js/main.js></script></head><body><nav class=shadow-md><div class="layout flex justify-between text-gray-600"><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=/>Home</a></li><li class=hover:text-accent><a href=/posts>Posts</a></li><li class=hover:text-accent><a href=/series>Series</a></li><li class=hover:text-accent><a href=/learn class=text-accent>Learn</a></li></ul><ul class="flex gap-4 py-4"><li class=hover:text-accent><a class=text-lg href=mailto:dev.jinyongp@gmail.com><i><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><path d="M64 112c-8.8.0-16 7.2-16 16v22.1L220.5 291.7c20.7 17 50.4 17 71.1.0L464 150.1V128c0-8.8-7.2-16-16-16H64zM48 212.2V384c0 8.8 7.2 16 16 16H448c8.8.0 16-7.2 16-16V212.2L322 328.8c-38.4 31.5-93.7 31.5-132 0L48 212.2zM0 128C0 92.7 28.7 64 64 64H448c35.3.0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3.0-64-28.7-64-64V128z"/></svg></i></a></li><li class=hover:text-accent><a class=text-lg href=https://github.com/jinyongp/><i><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></i></a></li></ul></div></nav><main class=pb-24><div class=layout><header class=text-center><h1 class="mt-16 mb-12">[내배캠] Swift 기초 개인 과제</h1><div class="flex justify-between items-center"><div><a href=https://jinyongp.dev/tags/nbcamp><kbd class="text-sm bg-accent text-white rounded px-1 py-0.5">nbcamp</kbd></a>
<a href=https://jinyongp.dev/tags/swift><kbd class="text-sm bg-accent text-white rounded px-1 py-0.5">swift</kbd></a></div><h6>Written on Jul 19, 2023</h6></div><hr class=my-4></header><article class="content [&_hr]:my-4"><p>본 캠프가 시작되고 2주차가 되었습니다.</p><p>이번 주차에선 Swift를 학습하고 간단한 연산 기능을 제공하는 계산기를 만들어 보는 과제를 수행했습니다.</p><p>캠프에서는 자기주도적 학습 방식을 추구하기 때문에 주어지는 학습 자료 외에도 스스로 조사하고 학습해야 합니다.
주어지는 학습자료만으로는 깊게 학습할 수 없었기에 공식 문서와 다른 강의를 병행하며 부족한 부분을 채워야 합니다.</p><p>저는 캠프 참여 이전에 이러한 부분을 인지하고 있었으므로 자세한 문법이나 이론 관련한 내용은 <a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8?gad=1&amp;gclid=Cj0KCQjw8NilBhDOARIsAHzpbLDMCagwbVBR_-ZFhM3GKE2eX1sD38Wr2Sa5WN2ZL07NSM1FPGZ54b0aAn__EALw_wcB">앨런 Swift 문법 마스터 스쿨</a> 과정을 병행하며 보충했습니다.</p><p>과제를 수행하기에 충분한 문법과 이론을 학습했고, 이를 기반으로 CLI에서 실행할 수 있는 간단한 계산기 툴을 작성했습니다.</p><h3 id=requirements>Requirements</h3><ul><li>1단계: 덧셈, 뺄셈, 곱셈, 나눗셈 연산 기능을 제공하는 Calculator 클래스 구현</li><li>2단계: 1단계에서 구현한 Calculator 클래스를에 나머지 연산 기능 추가</li><li>3단계: 각 연산을 개별 연산 클래스로 분리하고 Calculator와 연결 (feat. 단일 책임 원칙)</li><li>4단계: 연산 클래스를 추상화한 추상 클래스 작성 (feat. 결합도, 의존성 역전 원칙)</li></ul><h3 id=directory-structure>Directory Structure</h3><pre><code class=language-text>.
├── Sources/
│  ├── Operators/
│  │  ├── AddOperator.swift
│  │  ├── SubOperator.swift
│  │  ├── MulOperator.swift
│  │  ├── DivOperator.swift
│  │  ├── ModOperator.swift
│  │  └── Operator.swift
│  ├── Calculator.swift
│  └── main.swift
├── Package.swift
└── README.md
</code></pre><h3 id=implementation>Implementation</h3><h4 id=setup>Setup</h4><p>과제에서는 단순히 연산 후 출력하는 걸 요구하고 있지만, 저는 <code>readLine</code> 함수를 활용하여 사용자로부터 입력을 받아 계속 연산이 가능하도록 구현했습니다.</p><p>실행 가능한 파일로 작성하기 위해 <code>https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode</code> 문서를 참고하여 프로젝트를 생성했습니다.</p><pre><code class=language-sh>$ swift package init --type executable
</code></pre><p>위 명령어를 실행하면 현재 위치한 폴더에 <code>Package.swift</code> 파일을 생성합니다.</p><pre><code class=language-swift>// swift-tools-version: 5.8
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: &quot;calculator-cli&quot;,
    targets: [
        // Targets are the basic building blocks of a package, defining a module or a test suite.,
        // Targets can depend on other targets in this package and products from dependencies.
        .executableTarget(
            name: &quot;calc&quot;,
            path: &quot;Sources&quot;
        ),
    ]
)
</code></pre><p>이 파일에서 프로젝트에 대한 의존성 관리 및 빌드 설정 등을 할 수 있습니다.</p><p><code>Sources</code> 폴더에 <code>main.swift</code> 또한 생성되므로 <code>swift run</code> 명령어를 실행하여 프로젝트를 실행할 수 있습니다.</p><h4 id=impl-operator-protocol>Impl Operator protocol</h4><p>각 연산에 대한 클래스의 명세를 정하기 위해 <code>Operator</code> 프로토콜을 작성했습니다.</p><pre><code class=language-swift>protocol Operator {
    func operate&lt;Operand&gt;(_ lhs: Operand, _ rhs: Operand) -&gt; Operand
}
</code></pre><p>이를 토대로 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 클래스를 작성했습니다.</p><pre><code class=language-swift>class AddOperator: Operator {
    func operate&lt;Operand&gt;(_ lhs: Operand, _ rhs: Operand) -&gt; Operand {
        return lhs + rhs
    }
}
</code></pre><p>여기서 <code>lhs + rhs</code> 에서 <code>Binary operator '+' cannot be applied to two 'Operand' operands</code> 에러가 발생합니다. <code>Operand</code> 타입이 덧셈 기능을 제공하는지 모르기 때문입니다.</p><p>이를 해결하려면 <code>Operand</code> 타입이 연산 가능한 타입만 올 수 있도록 제약을 걸 필요가 있습니다. <code>Calculable</code> 프로토콜을 추가하여 이를 준수하는 타입만 올 수 있도록 제약을 걸었습니다.</p><pre><code class=language-swift>protocol Operator {
    func operate&lt;Operand: Calculable&gt;(_ lhs: Operand, _ rhs: Operand) -&gt; Operand
}

protocol Calculable {
    static func +(lhs: Self, rhs: Self) -&gt; Self
    static func -(lhs: Self, rhs: Self) -&gt; Self
    static func *(lhs: Self, rhs: Self) -&gt; Self
    static func /(lhs: Self, rhs: Self) -&gt; Self
    static func %(lhs: Self, rhs: Self) -&gt; Self
}

extension Int: Calculable {}
</code></pre><p><code>Calculable</code> 프로토콜을 추가하고 <code>Int</code> 타입이 이를 준수하도록 확장(extension)했습니다.</p><p>하지만, 위와 같은 방식으로 <code>Double</code> 타입을 확장했을 때, <code>Type 'Double' does not conform to protocol 'Calculable'</code> 에러가 발생합니다. 실수 타입인 <code>Double</code>은 나머지 연산에 대한 동작이 정의되어 있지 않기 때문입니다. 단순히 정수 타입으로 동작하도록 확장해줍니다.</p><pre><code class=language-swift>extension Double: Calculable {
    static func %(lhs: Self, rhs: Self) -&gt; Self {
        return Double(Int(lhs) % Int(rhs))
    }
}
</code></pre><pre><code class=language-swift>class ModOperator: Operator {
    func operate&lt;Operand&gt;(_ lhs: Operand, _ rhs: Operand) -&gt; Operand where Operand : Calculable {
        return lhs % rhs
    }
}
</code></pre><p>이로써 나머지 연산에 대해서도 <code>Double</code> 타입을 사용할 수 있게 되었고, <code>Operator</code> 프로토콜을 준수하는 <code>ModOperator</code> 클래스를 작성할 수 있게 되었습니다. (SPR. 단일 책임 원칙)</p><h4 id=impl-calculator-class>Impl Calculator class</h4><p>작성한 연산자를 언제든 사용할 수 있는 형태로 하여 Dictionary 형태로 외부에서 주입할 수 있도록 작성했습니다.</p><p><code>_result</code>는 여태까지 연산한 결과를 갖고 있는 저장 프로퍼티이고, <code>calculate</code> 메서드를 호출하여 연산을 수행합니다.</p><pre><code class=language-swift>import Foundation

class Calculator&lt;T: Calculable&gt; {
    private var _result: T
    private var _operators: [String: Operator]

    init(defaultValue: T? = nil, operators: [String: Operator] = [:]) {
        _result = defaultValue ?? Calculator.zero()
        _operators = operators
    }

    var result: T { _result }
    var operators: [String] { Array(_operators.keys) }

    @discardableResult
    func calculate(_ operand: T, name: String) -&gt; T {
        guard let operation = _operators[name] else { return _result }
        _result = operation.operate(_result, operand)
        return _result
    }
}
</code></pre><pre><code class=language-swift>let calculator = Calculator&lt;Double&gt;(
    operators: [
        &quot;+&quot;: AddOperator(),
        &quot;-&quot;: SubOperator(),
        &quot;*&quot;: MulOperator(),
        &quot;/&quot;: DivOperator(),
        &quot;%&quot;: ModOperator(),
    ]
)

calculator.calculate(10, name: &quot;+&quot;)
</code></pre><p>이로써 <code>Calculator</code>가 더이상 구체적인 클래스가 아닌 추상화된 프로토콜에 의존합니다. (DIP. 의존성 역전 원칙)</p><h3 id=trouble-shooting>Trouble Shooting</h3><h4 id=1-0으로-초기화할-때-제네릭-타입으로-변환할-수-없는-문제>1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제</h4><p>계산기이니 <code>clear</code> 메서드를 작성했고, 이는 결과를 0으로 초기화하는 단순한 작업을 수행합니다. <code>Int</code> 타입은 0으로 초기화하는 반면에 <code>Double</code>은 0.0으로 초기화해야 했기 때문입니다. 제네릭 타입으로부터 이를 확인할 수 있는 방법은 없었지만, 0과 0.0 이외에 경우는 없다고 가정하고 nullish coalescing operator를 사용하여 해결했습니다.</p><pre><code class=language-swift>private static func zero() -&gt; T {
    return 0 as? T ?? 0.0 as! T
}
</code></pre><h4 id=2-첫-문자를-제외한-문자열-가져오기>2. 첫 문자를 제외한 문자열 가져오기</h4><p>Swift에서 문자열을 조작하기란 다른 언어에 비해 번거로운 점이 많았습니다&mldr; index 또한 단순히 숫자가 아니라 String.Index를 생성하여 전달해야했고, 주어진 Index로부터 어느정도 떨어졌는지하는 방식으로 문자열을 가져와야했습니다.</p><p>첫 문자를 제외하고 문자열을 가져오려면 다음 방식으로 가져와야 합니다.</p><pre><code class=language-swift>let input: String = &quot;Hello, World!&quot;
input[input.index(input.startIndex, offsetBy: 1)...] // ello, World!
</code></pre><ol><li><code>input.index</code> 메서드를 호출하여 <code>String.Index</code> 타입의 인덱스를 생성합니다. 이때, <code>input.startIndex</code>를 기준으로 <code>offsetBy</code> 만큼 떨어진 인덱스를 생성합니다.</li><li><a href=https://developer.apple.com/documentation/swift/partialrangefrom>PartialRangeFrom</a> 문법을 활용하여 해당 인덱스부터 문자열을 가져옵니다.</li></ol><p>나중에 알게된 내용인데 단순하게 <code>dropFirst</code> 메서드를 활용해도 됩니다.</p><pre><code class=language-swift>input.dropFirst() // ello, World!
</code></pre><p>문자열 관련 메서드는 대개 <code>Self.SubSequence</code> 타입을 반환합니다. 잘라낸 문자열을 저장하기 위헤 새로운 메모리 공간을 할당하는 것이 아닌 기존의 문자열에서 필요한 부분에 직접 접근하기 때문입니다. 따라서, 문자열로서 사용하고 싶다면 <code>String</code>으로 변환해야 합니다.</p><h3 id=retrospective>Retrospective</h3><p>객체 지향 프로그래밍의 5대 원칙 중 단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)을 적용하여 계산기를 구현해보았습니다. 원칙을 적용해보기 위해 프로토콜로 명세를 작성하고 이를 준수하는 클래스는 작성하는 작업을 진행하면서 코드의 중복을 제거하고 확정성 높은 프로그램을 작성할 수 있었습니다.</p><p>앞으로 이외에도 적용할 수 있는 원칙을 찾아보고 적합한 디자인 패턴 및 기법을 추가로 학습하여 적용해보려고 합니다.</p></article><script src=https://giscus.app/client.js data-repo=jinyongp/jinyongp.dev data-repo-id=R_kgDOHJDtcg data-category=Comments data-category-id=DIC_kwDOHJDtcs4CXf7o data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=ko crossorigin=anonymous async></script></div></main><footer class="absolute bottom-0 w-full"><div class="flex justify-center py-8"><p class=[&_a]:text-accent>© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a>.</p></div></footer><div id=js-scroll-back-to-top class="back-to-top hide fixed bottom-10 right-10 rounded-full w-10 h-10 bg-accent grid place-items-center cursor-pointer"><i class=text-white><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512"><path d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3.0l-160 160c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3.0s12.5-32.8.0-45.3l-160-160z"/></svg></i></div></body></html>