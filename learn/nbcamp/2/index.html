<!doctype html><html lang=ko><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://jinyongp.dev><meta name=naver-site-verification content="c36f259891f25bc92e3884c1ceb626a0aaa76146"><meta name=author content="jinyongp"><meta property="og:site_name" content="jinyongp.dev"><meta property="og:title" content="[내배캠] 첫번째 팀 프로젝트"><meta property="og:type" content="website"><meta property="og:url" content="https://jinyongp.dev/learn/nbcamp/2/"><meta property="og:description" content="사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다."><meta name=description content="사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다."><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PFTW4CN")</script><title>[내배캠] 첫번째 팀 프로젝트</title><link rel=icon href=https://jinyongp.dev/favicon.png><link rel=stylesheet href=https://jinyongp.dev/main.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><style>:root{--accent:65 105 225;--font:Raleway}</style><script src=https://kit.fontawesome.com/62c573b42c.js crossorigin=anonymous></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/rainbow.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.highlightAll(),hljs.configure({ignoreUnescapedHTML:!0})</script><script src=/js/main.js></script></head><body><nav class=shadow-md><div class="layout flex justify-between text-gray-600"><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=/>Home</a></li><li class=hover:text-accent><a href=/posts>Posts</a></li><li class=hover:text-accent><a href=/series>Series</a></li><li class=hover:text-accent><a href=/learn class=text-accent>Learn</a></li></ul><ul class="flex gap-4 py-4"><li class=hover:text-accent><a href=mailto:dev.jinyongp@gmail.com><i class="fa-solid fa-square-envelope text-xl"></i></a></li><li class=hover:text-accent><a href=https://github.com/jinyongp/><i class="fa-brands fa-github-square text-xl"></i></a></li></ul></div></nav><main class=pb-24><div class=layout><header class=text-center><h1 class="mt-16 mb-12">[내배캠] 첫번째 팀 프로젝트</h1><div class="flex justify-between items-center"><div><a href=https://jinyongp.dev/tags/nbcamp><kbd class="text-sm bg-accent text-white rounded px-1 py-0.5">nbcamp</kbd></a>
<a href=https://jinyongp.dev/tags/flutter><kbd class="text-sm bg-accent text-white rounded px-1 py-0.5">flutter</kbd></a></div><h6>Written on Jul 19, 2023</h6></div><hr class=my-4></header><article class="content [&_hr]:my-4"><p>사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다.</p><p>4일간 진행한 프로젝트로 목적은 앱 개발 전반의 과정을 익히기 위함이지만, 보다 팀원분들과의 소통과 협업 관점에 비중으로 두고 프로젝트를 진행하였습니다.</p><p>프로젝트의 주제는 팀과 팀원의 소개를 담은 앱을 작성하는 것으로, 각자 자신의 소개를 담은 상세 페이지를 작성하고 합치기로 결정하였습니다.
저는 상세 페이지와 더불어 메인 페이지와 각 상세 페이지에서 쓰일 댓글 관리 서비스를 맡았습니다.</p><p>그 중에서도 댓글 관리 서비스를 어떻게 구현했는지 정리해보고자 합니다.</p><p><a href=https://github.com/nbcamp/introduce-e1if>프로젝트 저장소</a></p><h2 id=의존성-주입을-위해-인터페이스-적용하기>의존성 주입을 위해 인터페이스 적용하기</h2><p>사전캠프에서도 다뤘지만, Service 단에서 <code>shared_preferences</code>를 사용하기 위해 서비스 파일 내에서 직접 불러와서 사용해주는 방식이 아니라 <code>main.dart</code>에서 <code>save</code>와 <code>load</code> 함수를 주입해주는 방식으로 구현했었습니다.</p><p>허나, 아래처럼 <code>save</code> 혹은 <code>load</code> 둘 다 구현해야하는 걸 강제할 수 없었습니다. 또한, <code>shared_preferences</code>외에 다른 걸로 변경할 때도 번거롭습니다</p><pre><code class=language-ts>void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  SharedPreferences pref await SharedPreferences.getInstance();
  runApp(MultiProvider(
    providers: [
      ChangeNotifierProvider(
        create: (_) =&gt; MemoService(
          save: (String payload) async =&gt; await pref.setString(&quot;memo&quot;, payload),
          // load: () async =&gt; pref.getString(&quot;memo&quot;), // 에러를 발생시키지 않음
        ),
      ),
    ],
    child: const MyApp(),
  ));
}
</code></pre><p>이를 해결하기 위해 <code>IO</code> 인터페이스를 구현했습니다.</p><pre><code class=language-ts>abstract class IO {
  Future&lt;void&gt; save(String payload);
  Future&lt;String?&gt; load();
}
</code></pre><p>dart에서는 인터페이스를 생성하기 위해 <code>abstract class</code> 키워드를 사용해야 합니다. <code>IO</code> 인터페이스는 <code>save</code>와 <code>load</code> 함수에 대한 명세를 제공합니다. 이를 <code>CommentService</code>에 적용합니다.</p><pre><code class=language-ts>class CommentService extends ChangeNotifier {
  final Map&lt;String, List&lt;Comment&gt;&gt; _comments = {};

  IO? io;

  CommentService({this.io}) {
    //
  }

  ...
}
</code></pre><p>이제 <code>io</code> 인스턴스를 외부에서 주입해줄 수 있습니다. <code>shared_preferences</code>를 사용할 예정이므로 <code>SharedPreferencesIO</code> 클래스를 생성합니다.</p><pre><code class=language-tsx>class SharedPreferencesIO implements IO {
  late Future&lt;SharedPreferences&gt; pref;

  SharedPreferencesIO() {
    pref = SharedPreferences.getInstance();
  }

  @override
  Future&lt;String?&gt; load() {
    return pref.then((pref) =&gt; pref.getString('comments'));
  }

  @override
  Future&lt;void&gt; save(String payload) async {
    pref.then((pref) =&gt; pref.setString('comments', payload));
  }
}
</code></pre><pre><code class=language-ts>void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(MultiProvider(
    providers: [
      ChangeNotifierProvider(
        create: (_) =&gt; CommentService(
          io: SharedPreferencesIO(),
        ),
      ),
    ],
    child: MainApp(),
  ));
}
</code></pre><p>구현한 <code>SharedPreferencesIO</code> 클래스를 <code>main.dart</code>에서 <code>CommentService</code>에 주입해줍니다.</p><p>이로써, <code>save</code>와 <code>load</code> 모두 구현해야 함을 강제할 수 있게 되었고, <code>IO</code> 인터페이스를 상속하는 클래스를 여러 개 추가하여 상황에 따라 교체할 수 있어 확장성을 높였습니다.</p><h2 id=데이터-송수신-로직-추상화하기>데이터 송수신 로직 추상화하기</h2><p><code>CommentService</code>에서 내부적으로 데이터를 저장하고 불러오는 <code>_save</code>와 <code>_load</code> 함수가 있었습니다.</p><pre><code class=language-ts>Future&lt;void&gt; _save() {
  if (save == null) return Future.value();

  String payload = jsonEncode(_memos.map((m) =&gt; m.toJson()).toList());
  return save!(payload);
}

Future&lt;void&gt; _load() async {
  if (load == null) return;

  String? payload = await load!();
  if (payload == null) return;
  _memos.clear();

  _memos.addAll(jsonDecode(payload).map((e) =&gt; Memo.fromJson(e)));
}
</code></pre><p>여기서 데이터를 String 타입의 payload로 만들거나, 반대로 payload를 데이터로 변환하는 작업을 수행했었습니다.
언뜻보면 null 체크를 하고 종료하는 부분이나 payload를 처리하는 부분은 중복된 부분이기에 별도의 함수로 분리하고 싶었습니다.</p><p>그래서 <code>DataHandler</code> 추상 클래스르 작성하였습니다.</p><pre><code class=language-ts>mixin DataHandler {
  IO? io;

  Future&lt;void&gt; import(String payload);
  Future&lt;String&gt; export();

  Future&lt;void&gt; save() async {
    if (io == null) return Future.value();
    var payload = await export();
    io?.save(payload);
  }

  Future&lt;void&gt; load() async {
    if (io == null) return Future.value();
    var payload = await io!.load();
    if (payload == null) return;
    import(payload);
  }
}
</code></pre><p>dart에서 mixin을 활용하여 추상 클래스를 작성할 수 있습니다.
<code>save</code>와 <code>load</code> 함수는 이미 구현되어 있어 동일한 작업을 수행하지만, <code>import</code>와 <code>export</code> 함수는 재정의가 필요합니다. 이를 <code>CommentService</code>에 적용합니다.</p><pre><code class=language-ts>class UseState {
  final List&lt;Comment&gt; comments;
  final void Function(List&lt;Comment&gt; Function()) setState;

  UseState({
    required this.comments,
    required this.setState,
  });
}

class CommentService extends ChangeNotifier with DataHandler {
  final Map&lt;String, List&lt;Comment&gt;&gt; _comments = {};

  CommentService({IO? io}) {
    this.io = io;

    try {
      load().then((_) =&gt; notifyListeners());
    } catch (error) {
      // ignore
    }
  }

  UseState useState(String name) {
    return UseState(
      comments: List.unmodifiable(_comments[name] ?? []),
      setState: (newComments) {
        _comments[name] = newComments();
        notifyListeners();
        save();
      },
    );
  }

  @override
  Future&lt;void&gt; import(String payload) async {
    jsonDecode(payload).forEach((key, values) {
      if (values is! List) return;
      _comments[key] = values.map((value) =&gt; Comment.fromJson(value)).toList();
    });
  }

  @override
  Future&lt;String&gt; export() async {
    return jsonEncode(
      _comments.map(
        (key, values) =&gt; MapEntry(
          key,
          values.map((comment) =&gt; comment.toJson()).toList(),
        ),
      ),
    );
  }
}
</code></pre><p><code>mixin</code>을 상속하기 위해선 <code>with</code> 키워드를 사용해야 합니다. <code>DataHandler</code>를 상속하면서 <code>CommentService</code>에서 구현해야 하는 함수들을 재정의합니다.
<code>import</code>와 <code>export</code> 함수는 단순히 JSON 형태의 stringify와 parse 작업을 수행합니다. 이로써 상속을 통해 중복 코드를 제거하고 함수의 역할을 분리할 수 있었습니다.</p></article><script src=https://giscus.app/client.js data-repo=jinyongp/jinyongp.dev data-repo-id=R_kgDOHJDtcg data-category=Comments data-category-id=DIC_kwDOHJDtcs4CXf7o data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=ko crossorigin=anonymous async></script></div></main><footer class="absolute bottom-0 w-full"><div class="flex justify-center py-8"><p class=[&_a]:text-accent>© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a>.</p></div></footer><div id=js-scroll-back-to-top class="back-to-top hide fixed bottom-10 right-10 rounded-full w-10 h-10 bg-accent grid place-items-center cursor-pointer"><i class="fa-solid fa-arrow-up text-white"></i></div></body></html>