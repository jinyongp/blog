<!doctype html><html lang=ko-kr><head><link rel=canonical href=https://jinyongp.dev><meta name=naver-site-verification content="c36f259891f25bc92e3884c1ceb626a0aaa76146"><meta name=author content="jinyongp"><meta property="og:site_name" content="jinyongp.dev"><meta property="og:title" content="[내배캠] Swift 기초 개인 과제"><meta property="og:type" content="website"><meta property="og:url" content="https://jinyongp.dev/study/nbcamp/3/"><meta property="og:description" content="Swift 기초를 학습하고 간단한 계산기를 제작하는 과제를 수행했습니다."><meta name=description content="Swift 기초를 학습하고 간단한 계산기를 제작하는 과제를 수행했습니다."><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PFTW4CN")</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[내배캠] Swift 기초 개인 과제</title><link rel=icon href=https://jinyongp.dev/favicon.png><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:RoyalBlue;--border-width:5px}</style><link rel=stylesheet href=https://jinyongp.dev/css/main.css><link rel=stylesheet href=https://jinyongp.dev/css/custom.css><link rel=stylesheet href=https://jinyongp.dev/css/content.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark-dimmed.min.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css crossorigin=anonymous><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js></script>
<script>hljs.highlightAll(),hljs.configure({ignoreUnescapedHTML:!0})</script><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://kit.fontawesome.com/62c573b42c.js crossorigin=anonymous></script>
<script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><meta name=generator content="Hugo 0.115.3"><script async src="https://www.googletagmanager.com/gtag/js?id=G-SH0YPW4E1C"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SH0YPW4E1C")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>[내배캠] Swift 기초 개인 과제</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/blog>Blog</a></li><li><a href=/study>Study</a></li><li><a href=/projects>Projects</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:dev.jinyongp@gmail.com><i class="fa-solid fa-square-envelope"></i></a></li><li class=navbar-icon><a href=https://github.com/jinyongp/><i class="fa-brands fa-github-square"></i></a></li></ul></div></div></nav><main><div><h2>[내배캠] Swift 기초 개인 과제</h2><h5>Swift 기초를 학습하고 간단한 계산기를 제작하는 과제를 수행했습니다.</h5><a href=https://jinyongp.dev/tags/nbcamp><kbd class=item-tag>nbcamp</kbd></a>
<a href=https://jinyongp.dev/tags/swift><kbd class=item-tag>swift</kbd></a></div><aside id=TOC_Study><span>History</span><nav id=TableOfContents><ul><li><ul><li><a href=#requirements>Requirements</a></li><li><a href=#directory-structure>Directory Structure</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#trouble-shooting>Trouble Shooting</a></li><li><a href=#retrospective>Retrospective</a></li></ul></li></ul></nav></aside><div align=start class=content><p>본 캠프가 시작되고 2주차가 되었습니다.</p><p>이번 주차에선 Swift를 학습하고 간단한 연산 기능을 제공하는 계산기를 만들어 보는 과제를 수행했습니다.</p><p>캠프에서는 자기주도적 학습 방식을 추구하기 때문에 주어지는 학습 자료 외에도 스스로 조사하고 학습해야 합니다.
주어지는 학습자료만으로는 깊게 학습할 수 없었기에 공식 문서와 다른 강의를 병행하며 부족한 부분을 채워야 합니다.</p><p>저는 캠프 참여 이전에 이러한 부분을 인지하고 있었으므로 자세한 문법이나 이론 관련한 내용은 <a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8?gad=1&amp;gclid=Cj0KCQjw8NilBhDOARIsAHzpbLDMCagwbVBR_-ZFhM3GKE2eX1sD38Wr2Sa5WN2ZL07NSM1FPGZ54b0aAn__EALw_wcB" target=_blank rel="noopener noreferrer">앨런 Swift 문법 마스터 스쿨</a> 과정을 병행하며 보충했습니다.</p><p>과제를 수행하기에 충분한 문법과 이론을 학습했고, 이를 기반으로 CLI에서 실행할 수 있는 간단한 계산기 툴을 작성했습니다.</p><h3 id=requirements>Requirements</h3><ul><li>1단계: 덧셈, 뺄셈, 곱셈, 나눗셈 연산 기능을 제공하는 Calculator 클래스 구현</li><li>2단계: 1단계에서 구현한 Calculator 클래스를에 나머지 연산 기능 추가</li><li>3단계: 각 연산을 개별 연산 클래스로 분리하고 Calculator와 연결 (feat. 단일 책임 원칙)</li><li>4단계: 연산 클래스를 추상화한 추상 클래스 작성 (feat. 결합도, 의존성 역전 원칙)</li></ul><h3 id=directory-structure>Directory Structure</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── Sources/
</span></span><span style=display:flex><span>│  ├── Operators/
</span></span><span style=display:flex><span>│  │  ├── AddOperator.swift
</span></span><span style=display:flex><span>│  │  ├── SubOperator.swift
</span></span><span style=display:flex><span>│  │  ├── MulOperator.swift
</span></span><span style=display:flex><span>│  │  ├── DivOperator.swift
</span></span><span style=display:flex><span>│  │  ├── ModOperator.swift
</span></span><span style=display:flex><span>│  │  └── Operator.swift
</span></span><span style=display:flex><span>│  ├── Calculator.swift
</span></span><span style=display:flex><span>│  └── main.swift
</span></span><span style=display:flex><span>├── Package.swift
</span></span><span style=display:flex><span>└── README.md
</span></span></code></pre></div><h3 id=implementation>Implementation</h3><h4 id=setup>Setup</h4><p>과제에서는 단순히 연산 후 출력하는 걸 요구하고 있지만, 저는 <code>readLine</code> 함수를 활용하여 사용자로부터 입력을 받아 계속 연산이 가능하도록 구현했습니다.</p><p>실행 가능한 파일로 작성하기 위해 <code>https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode</code> 문서를 참고하여 프로젝트를 생성했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ swift package init --type executable
</span></span></code></pre></div><p>위 명령어를 실행하면 현재 위치한 폴더에 <code>Package.swift</code> 파일을 생성합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// swift-tools-version: 5.8</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The swift-tools-version declares the minimum version of Swift required to build this package.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>PackageDescription</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> package = Package(
</span></span><span style=display:flex><span>    name: <span style=color:#e6db74>&#34;calculator-cli&#34;</span>,
</span></span><span style=display:flex><span>    targets: [
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Targets are the basic building blocks of a package, defining a module or a test suite.,</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Targets can depend on other targets in this package and products from dependencies.</span>
</span></span><span style=display:flex><span>        .executableTarget(
</span></span><span style=display:flex><span>            name: <span style=color:#e6db74>&#34;calc&#34;</span>,
</span></span><span style=display:flex><span>            path: <span style=color:#e6db74>&#34;Sources&#34;</span>
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>이 파일에서 프로젝트에 대한 의존성 관리 및 빌드 설정 등을 할 수 있습니다.</p><p><code>Sources</code> 폴더에 <code>main.swift</code> 또한 생성되므로 <code>swift run</code> 명령어를 실행하여 프로젝트를 실행할 수 있습니다.</p><h4 id=impl-operator-protocol>Impl Operator protocol</h4><p>각 연산에 대한 클래스의 명세를 정하기 위해 <code>Operator</code> 프로토콜을 작성했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Operator</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>operate</span>&lt;Operand&gt;(<span style=color:#66d9ef>_</span> lhs: Operand, <span style=color:#66d9ef>_</span> rhs: Operand) -&gt; Operand
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이를 토대로 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 클래스를 작성했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddOperator</span>: Operator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>operate</span>&lt;Operand&gt;(<span style=color:#66d9ef>_</span> lhs: Operand, <span style=color:#66d9ef>_</span> rhs: Operand) -&gt; Operand {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>+</span> rhs
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>여기서 <code>lhs + rhs</code> 에서 <code>Binary operator '+' cannot be applied to two 'Operand' operands</code> 에러가 발생합니다. <code>Operand</code> 타입이 덧셈 기능을 제공하는지 모르기 때문입니다.</p><p>이를 해결하려면 <code>Operand</code> 타입이 연산 가능한 타입만 올 수 있도록 제약을 걸 필요가 있습니다. <code>Calculable</code> 프로토콜을 추가하여 이를 준수하는 타입만 올 수 있도록 제약을 걸었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Operator</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>operate</span>&lt;Operand: Calculable&gt;(<span style=color:#66d9ef>_</span> lhs: Operand, <span style=color:#66d9ef>_</span> rhs: Operand) -&gt; Operand
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Calculable</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>+</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>-</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>*</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>/</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>%</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Int</span>: Calculable {}
</span></span></code></pre></div><p><code>Calculable</code> 프로토콜을 추가하고 <code>Int</code> 타입이 이를 준수하도록 확장(extension)했습니다.</p><p>하지만, 위와 같은 방식으로 <code>Double</code> 타입을 확장했을 때, <code>Type 'Double' does not conform to protocol 'Calculable'</code> 에러가 발생합니다. 실수 타입인 <code>Double</code>은 나머지 연산에 대한 동작이 정의되어 있지 않기 때문입니다. 단순히 정수 타입으로 동작하도록 확장해줍니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Double</span>: Calculable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>%</span>(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Double(Int(lhs) <span style=color:#f92672>%</span> Int(rhs))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ModOperator</span>: Operator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>operate</span>&lt;Operand&gt;(<span style=color:#66d9ef>_</span> lhs: Operand, <span style=color:#66d9ef>_</span> rhs: Operand) -&gt; Operand <span style=color:#66d9ef>where</span> Operand : Calculable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>%</span> rhs
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이로써 나머지 연산에 대해서도 <code>Double</code> 타입을 사용할 수 있게 되었고, <code>Operator</code> 프로토콜을 준수하는 <code>ModOperator</code> 클래스를 작성할 수 있게 되었습니다. (SPR. 단일 책임 원칙)</p><h4 id=impl-calculator-class>Impl Calculator class</h4><p>작성한 연산자를 언제든 사용할 수 있는 형태로 하여 Dictionary 형태로 외부에서 주입할 수 있도록 작성했습니다.</p><p><code>_result</code>는 여태까지 연산한 결과를 갖고 있는 저장 프로퍼티이고, <code>calculate</code> 메서드를 호출하여 연산을 수행합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Foundation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Calculator</span>&lt;T: Calculable&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> _result: T
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> _operators: [String: Operator]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(defaultValue: T? = <span style=color:#66d9ef>nil</span>, operators: [String: Operator] = [:]) {
</span></span><span style=display:flex><span>        _result = defaultValue ?? Calculator.zero()
</span></span><span style=display:flex><span>        _operators = operators
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result: T { _result }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> operators: [String] { Array(_operators.keys) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @discardableResult
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#66d9ef>_</span> operand: T, name: String) -&gt; T {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> operation = _operators[name] <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> _result }
</span></span><span style=display:flex><span>        _result = operation.operate(_result, operand)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> calculator = Calculator&lt;Double&gt;(
</span></span><span style=display:flex><span>    operators: [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;+&#34;</span>: AddOperator(),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;-&#34;</span>: SubOperator(),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;*&#34;</span>: MulOperator(),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;/&#34;</span>: DivOperator(),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;%&#34;</span>: ModOperator(),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>calculator.calculate(<span style=color:#ae81ff>10</span>, name: <span style=color:#e6db74>&#34;+&#34;</span>)
</span></span></code></pre></div><p>이로써 <code>Calculator</code>가 더이상 구체적인 클래스가 아닌 추상화된 프로토콜에 의존합니다. (DIP. 의존성 역전 원칙)</p><h3 id=trouble-shooting>Trouble Shooting</h3><h4 id=1-0으로-초기화할-때-제네릭-타입으로-변환할-수-없는-문제>1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제</h4><p>계산기이니 <code>clear</code> 메서드를 작성했고, 이는 결과를 0으로 초기화하는 단순한 작업을 수행합니다. <code>Int</code> 타입은 0으로 초기화하는 반면에 <code>Double</code>은 0.0으로 초기화해야 했기 때문입니다. 제네릭 타입으로부터 이를 확인할 수 있는 방법은 없었지만, 0과 0.0 이외에 경우는 없다고 가정하고 nullish coalescing operator를 사용하여 해결했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>zero</span>() -&gt; T {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span>? T ?? <span style=color:#ae81ff>0.0</span> <span style=color:#66d9ef>as</span>! T
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-첫-문자를-제외한-문자열-가져오기>2. 첫 문자를 제외한 문자열 가져오기</h4><p>Swift에서 문자열을 조작하기란 다른 언어에 비해 번거로운 점이 많았습니다&mldr; index 또한 단순히 숫자가 아니라 String.Index를 생성하여 전달해야했고, 주어진 Index로부터 어느정도 떨어졌는지하는 방식으로 문자열을 가져와야했습니다.</p><p>첫 문자를 제외하고 문자열을 가져오려면 다음 방식으로 가져와야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> input: String = <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>input[input.index(input.startIndex, offsetBy: <span style=color:#ae81ff>1</span>)...] <span style=color:#75715e>// ello, World!</span>
</span></span></code></pre></div><ol><li><code>input.index</code> 메서드를 호출하여 <code>String.Index</code> 타입의 인덱스를 생성합니다. 이때, <code>input.startIndex</code>를 기준으로 <code>offsetBy</code> 만큼 떨어진 인덱스를 생성합니다.</li><li><a href=https://developer.apple.com/documentation/swift/partialrangefrom target=_blank rel="noopener noreferrer">PartialRangeFrom</a> 문법을 활용하여 해당 인덱스부터 문자열을 가져옵니다.</li></ol><p>나중에 알게된 내용인데 단순하게 <code>dropFirst</code> 메서드를 활용해도 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>input.dropFirst() <span style=color:#75715e>// ello, World!</span>
</span></span></code></pre></div><p>문자열 관련 메서드는 대개 <code>Self.SubSequence</code> 타입을 반환합니다. 잘라낸 문자열을 저장하기 위헤 새로운 메모리 공간을 할당하는 것이 아닌 기존의 문자열에서 필요한 부분에 직접 접근하기 때문입니다. 따라서, 문자열로서 사용하고 싶다면 <code>String</code>으로 변환해야 합니다.</p><h3 id=retrospective>Retrospective</h3><p>객체 지향 프로그래밍의 5대 원칙 중 단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)을 적용하여 계산기를 구현해보았습니다. 원칙을 적용해보기 위해 프로토콜로 명세를 작성하고 이를 준수하는 클래스는 작성하는 작업을 진행하면서 코드의 중복을 제거하고 확정성 높은 프로그램을 작성할 수 있었습니다.</p><p>앞으로 이외에도 적용할 수 있는 원칙을 찾아보고 적합한 디자인 패턴 및 기법을 추가로 학습하여 적용해보려고 합니다.</p></div><script src=https://giscus.app/client.js data-repo=jinyongp/jinyongp.dev data-repo-id=R_kgDOHJDtcg data-category=Comments data-category-id=DIC_kwDOHJDtcs4CXf7o data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=ko crossorigin=anonymous async></script></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a> and <a href=https://github.com/calintat/minimal target=_blank rel="noopener noreferrer">Minimal</a>.</p></footer></body></html>