<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jinyongp.dev</title><link>https://jinyongp.dev/</link><description>Recent content on jinyongp.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>dev.jinyongp@gmail.com (Jinyong Park)</managingEditor><webMaster>dev.jinyongp@gmail.com (Jinyong Park)</webMaster><copyright>Copyright 2023. Jinyong Park. All rights reserved.</copyright><lastBuildDate>Wed, Sep 13 02:37:04 2023 +0000</lastBuildDate><atom:link href="https://jinyongp.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>SwiftFormat로 코드 품질 높이기</title><link>https://jinyongp.dev/posts/xcode/1/</link><pubDate>Wed, Sep 13 02:37:04 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/xcode/1/</guid><description>&lt;h2 id="들어가기-전에" class="flex items-center gap-3">들어가기 전에 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="들어가기 전에" href="#%eb%93%a4%ec%96%b4%ea%b0%80%ea%b8%b0-%ec%a0%84%ec%97%90"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Swift 언어로 개발하며 애플이 제공하는 프레임워크나 라이브러리를 활용하기 위해서 Xcode IDE 말고는 다른 선택지가 없습니다. 웹 개발을 해오면서 항상 VSCode만 사용해왔었는데, iOS 앱 개발을 시작하고 Xcode에 적응하면서 여러가지 불편한 점이 있었습니다.&lt;/p>
&lt;p>그 중 하나는 VSCode에서 기본으로 제공되는 Code Formatter가 Xcode에는 없다는 건데요. 모든 코드를 드래그한 뒤, &lt;kbd>Ctrl ⌃&lt;/kbd>
+ &lt;kbd>I&lt;/kbd>
를 눌러 Tab Indent를 맞추는 정도의 포맷팅은 가능하지만 공백을 없애거나 만들어주는 등 세부적인 format 기능을 설정할 수 없고 제공하지 않는게 참 불편했습니다. 이를 해소하기 위해 Swift 언어의 formatter 도구를 찾아봤습니다.&lt;/p>
&lt;p>Code Formatter는 코드를 정해진 규칙(널리 쓰이는 컨벤션)에 맞춰 자동으로 정렬해주는 기능을 제공하는 도구입니다. 웹 개발 생태계에서는 다양한 formatter를 사용했었고 더 나아가 코드의 문제를 미리 찾고 방지할 수 있도록 도와주는 linter까지 활용하며 코드의 품질을 높였습니다. Swift에서도 마찬가지로 이러한 기능을 제공하는 도구가 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftFormat&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/realm/SwiftLint"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftLint&lt;/a
>&lt;/li>
&lt;/ul>
&lt;p>SwiftLint에 대해선 나중에 기회가 된다면 알아보도록 하고, 이 글에선 SwiftFormat을 설치하는 방법과 Xcode에서 사용하는 방법에 대해 알아보려고 합니다.&lt;/p>
&lt;h2 id="swiftformat-설치하기" class="flex items-center gap-3">SwiftFormat 설치하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="SwiftFormat 설치하기" href="#swiftformat-%ec%84%a4%ec%b9%98%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat"
target="_blank" rel="noopener noreferrer nofollow"
>SwiftFormat&lt;/a
> 저장소에서 설치 가능한 패키지는 기본적으로 Command Line 도구로 제공하고 있습니다. Xcode 용 &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat#xcode-source-editor-extension"
target="_blank" rel="noopener noreferrer nofollow"
>설치 가이드&lt;/a
>를 따라 설치해보도록 하겠습니다.&lt;/p>
&lt;p>MacOS를 사용하는 개발자라면 &lt;a
class="underline-lsre"
href="https://brew.sh/"
target="_blank" rel="noopener noreferrer nofollow"
>Homebrew&lt;/a
>를 반드시 사용하고 계시리라 생각합니다. &lt;code>brew&lt;/code> 명령어로 설치해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ brew install --cask swiftformat-for-xcode&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Homebrew를 사용하고 있지 않다면, 저장소의 &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat/releases"
target="_blank" rel="noopener noreferrer nofollow"
>Releases&lt;/a
>에서 설치한 다음 Applications 폴더로 옮겨줍니다.&lt;/p>
&lt;h2 id="swiftformat-적용하기" class="flex items-center gap-3">SwiftFormat 적용하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="SwiftFormat 적용하기" href="#swiftformat-%ec%a0%81%ec%9a%a9%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>설치를 완료하셨다면 Spotlight를 열고 &lt;code>SwiftFormat for Xcode&lt;/code>를 한번 실행합니다. (혹은, Applications 폴더에서 직접 실행해주세요.)&lt;/p>
&lt;blockquote>
&lt;p>저는 기본으로 제공되는 Spotlight 대신 &lt;a
class="underline-lsre"
href="https://raycast.com/"
target="_blank" rel="noopener noreferrer nofollow"
>Raycast&lt;/a
>를 사용하고 있습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Open SwiftFormat using Spotlight" src="https://jinyongp.dev/image/posts/xcode/1/open-swiftformat.png" />
&lt;img class="mx-auto" alt="SwiftFormat for Xcode - About" src="https://jinyongp.dev/image/posts/xcode/1/swiftformat-for-xcode-about.png" />
&lt;/div>
&lt;p>실행하며 프로그램이 열리면 About 화면에서 설치 방법을 보여주고 있습니다. 이를 따라 설치를 진행해보겠습니다.&lt;/p>
&lt;p>다시 Spotlight를 열어 MacOS의 System Settings(설정)를 열고 Extensions(확장)를 검색합니다.&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Open Extensions Setting" src="https://jinyongp.dev/image/posts/xcode/1/open-extensions.png" />
&lt;img class="mx-auto" alt="Activate SwiftFormat on Settings" src="https://jinyongp.dev/image/posts/xcode/1/activate-swiftformat.png" />
&lt;/div>
&lt;p>Xcode Source Editor를 클릭하면 SwiftFormat 항목이 있습니다. 체크하여 활성화합니다.&lt;/p>
&lt;p>이제 Xcode를 실행하면 상단 Menubar의 Editor 최하단에 SwiftFormat 항목이 추가된 걸 확인할 수 있습니다. Format File를 클릭하면 현재 열려있는 파일을 포맷팅합니다.&lt;/p>
&lt;h2 id="단축키-등록하기" class="flex items-center gap-3">단축키 등록하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="단축키 등록하기" href="#%eb%8b%a8%ec%b6%95%ed%82%a4-%eb%93%b1%eb%a1%9d%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>매번 Format File을 실행할 수는 없으니, 단축키를 등록하여 해당 명령어를 손쉽게 실행할 수 있도록 해보겠습니다.&lt;/p>
&lt;p>설정을 열고 keyboard를 검색한 뒤, Keyboard Shortcuts -&amp;gt; App Shortcuts를 클릭합니다.&lt;/p>
&lt;div class="grid" style="grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0px;">
&lt;img class="mx-auto" alt="Search keyboard" src="https://jinyongp.dev/image/posts/xcode/1/search-keyboard.png" />
&lt;img class="mx-auto" alt="Open App Shortcuts" src="https://jinyongp.dev/image/posts/xcode/1/open-app-shortcuts.png" />
&lt;/div>
&lt;p>&lt;kbd>+&lt;/kbd>
버튼을 눌러 새로운 단축키를 추가합니다.&lt;/p>
&lt;ul>
&lt;li>Application을 Xcode.app으로 설정합니다.&lt;/li>
&lt;li>Menu Title을 &lt;code>Editor-&amp;gt;SwiftFormat-&amp;gt;Format File&lt;/code>을 오타에 주의하며 작성합니다.&lt;/li>
&lt;li>Keyboard Shortcuts를 클릭하고 원하는 단축키를 누릅니다. 저는 &lt;kbd>⌘&lt;/kbd>
+ &lt;kbd>S&lt;/kbd>
로 설정했습니다. (사용 중인 Xcode의 기존 단축키와 겹치는지 확인해주세요.)&lt;/li>
&lt;li>&lt;code>Done&lt;/code>를 눌러 저장합니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img class="mx-auto" alt="Set Xcode Shortcut" src="https://jinyongp.dev/image/posts/xcode/1/set-xcode-shortcut.png" />
&lt;/p>
&lt;p>마지막으로 Xcode를 재실행하여 아래처럼 망가진 코드를 작성한 뒤, 설정했던 단축키를 눌러 포맷팅이 잘 동작하는지 확인해봅니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// before
func foo () {
print (&amp;#34;test&amp;#34;)}
// ... ⌘ &amp;#43; S
// after
func foo() {
print(&amp;#34;test&amp;#34;)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>엉망으로 작성되어 있던 코드가 깔끔하게 정렬된 것을 확인할 수 있습니다.&lt;/p>
&lt;h2 id="마치며" class="flex items-center gap-3">마치며 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="마치며" href="#%eb%a7%88%ec%b9%98%eb%a9%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>SwiftFormat for Xcode의 rules 탭을 선택하면 세부적인 규칙 설정이 가능합니다. 세세한 규칙 설정에 따라 단순히 간격 조정이나 괄호 유무 뿐만 아니라 Swift의 문법에 따라 불필요한 코드를 제거해주기도 하고, 컨벤션에 맞게 코드를 수정해주기도 합니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="SwiftFormat for Xcode - Rules" src="https://jinyongp.dev/image/posts/xcode/1/swiftformat-for-xcode-rules.png" />
&lt;/p>
&lt;p>한 예로 stringOutlet이라는 설정이 있는데, 기본적으로 활성화되어 있습니다. 이 설정은 &lt;code>@IBOutlet&lt;/code>에서 &lt;code>weak&lt;/code> 키워드를 제거합니다. &lt;a
class="underline-lsre"
href="https://github.com/nicklockwood/SwiftFormat/issues/740#issuecomment-692558057"
target="_blank" rel="noopener noreferrer nofollow"
>해당 이슈&lt;/a
>를 확인해보면 WWDC2015에서 추천했던 방식으로 오히려 &lt;code>weak&lt;/code>를 제거하는 것으로 약간의 성능 향상을 얻을 수 있다고 말합니다.&lt;/p>
&lt;p>이렇듯 Code Formatter를 적용하면 단순히 코드를 깔끔히 작성하는 것을 넘어서 성능 향상과 잠재적 버그를 사전에 방지하는 등의 긍정적인 효과를 얻을 수 있습니다.&lt;/p></description></item><item><title>[내배캠] UIKit 심화 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/7/</link><pubDate>Mon, Sep 04 16:52:52 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/7/</guid><description/></item><item><title>[내배캠] UIKit 입문 팀 과제</title><link>https://jinyongp.dev/learn/nbcamp/6/</link><pubDate>Mon, Sep 04 16:52:52 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/6/</guid><description>&lt;p>개인 과제 때 학습한 내용을 토대로 2023년 8월 14일부터 8월 21일까지 UIKit을 활용하여 팀 과제로서 Pinterest App을 클론 코딩해보았습니다.&lt;/p>
&lt;p>이번 과제는 팀원의 의견을 수렴하여 스토리보드 없이 코드로 UI를 작성하기로 결정하였습니다. 그렇기에 과제 요구조건에 부합하는 최소한의 UI와 기능을 개발하기로 했습니다.&lt;/p>
&lt;p>아무래도 팀 과제이고 팀원 개개인의 역량이 모두 다르다보니 갑자기 어려운 내용을 진행하게 되면 따라오지 못하는 팀원이 있어 걱정이 들었습니다. 팀 프로젝트를 수행하기 전 2주 간 개인 프로젝트를 진행하면서 팀원들의 역량을 잘 측정했다고 생각했는데, 제가 기대하던 것보다도 더 어려움을 겪고 있는 팀원이 있어 역할을 분배하는데 있어 어려움을 겪었습니다.&lt;/p></description></item><item><title>Prototype Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/6/</link><pubDate>Fri, Aug 18 14:05:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/6/</guid><description>&lt;p>&lt;strong>Prototype Pattern&lt;/strong>은&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Prototype Pattern&lt;/code>은 GoF의 분류 체계에서 생성(Creational) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Prototype Pattern은 객체를 생성하는 방법 중 하나입니다. 객체를 생성하는 방법은 크게 두 가지로 나눌 수 있습니다. 첫 번째는 객체를 생성하는 방법을 명시적으로 구현하는 것이고, 두 번째는 객체를 생성하는 방법을 추상화하는 것입니다. Prototype Pattern은 후자에 속합니다. 객체를 생성하는 방법을 추상화하여 객체를 생성하는 방법을 명시적으로 구현하는 것보다 유연하게 객체를 생성할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>간단한 예제를 통해 Singleton Pattern에 대해 알아봅시다. 사용자 인증 정보를 관리하는 &lt;code>AuthService&lt;/code>를 구현했습니다. 프로그램 전반에서 해당 서비스에 접근하여 사용자 정보를 불러오거나 업데이트할 수 있습니다.&lt;/p></description></item><item><title>Singleton Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/5/</link><pubDate>Wed, Aug 16 13:24:46 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/5/</guid><description>&lt;p>&lt;strong>Singleton Pattern&lt;/strong>은 클래스가 오직 하나의 인스턴스만 가지고 있음을 보장합니다. 프로그램 전반에 걸쳐 인스턴스를 공용으로 사용하고자 할 때나, 굳이 인스턴스를 여러 개 생성할 필요가 없을 때 사용합니다. 서버나 DB 혹은 입출력 장치와 같이 외부와 통신하는 역할을 수행하는 클래스에서 주로 사용합니다. UIKit에서도 자주 등장하는 패턴 중 하나입니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Singleton Pattern&lt;/code>은 GoF의 분류 체계에서 생성(Creational) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Singleton Pattern은 단순히 인스턴스를 하나만 생성할 수 있는 클래스만 있으면 됩니다.&lt;/p>
&lt;hr>
&lt;p>간단한 예제를 통해 Singleton Pattern에 대해 알아봅시다. 사용자 인증 정보를 관리하는 &lt;code>AuthService&lt;/code>를 구현했습니다. 프로그램 전반에서 해당 서비스에 접근하여 사용자 정보를 불러오거나 업데이트할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct User {
var id: String
var name: String
}
final class AuthService {
private(set) var user: User?
func login(email: String, password: String) {
// 서버에 로그인을 요청하여 사용자 정보를 불러옴
user = User(id: &amp;#34;1&amp;#34;, name: &amp;#34;jinyongp&amp;#34;)
}
func logout() {
// 서버에 로그아웃을 요청
user = nil
}
func update(user: User) {
// 서버에 사용자 정보 변경을 요청
self.user = user
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇게 Singleton이 아닌 방식으로 구현한다면 &lt;code>AuthService&lt;/code>로부터 사용자 정보를 불러올 때 사용자 정보가 매번 초기화됩니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 로그인을 통해 사용자 정보 저장
let authService = AuthService()
authService.login(email: &amp;#34;dev.jinyongp@gmail.com&amp;#34;, password: &amp;#34;PASSWORD&amp;#34;)
print(authService.user?.name) // jinyongp&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 다른 곳에서 사용자 정보를 불러오고자 인스턴스를 생성하면 사용자 정보가 없음
let authService = AuthService()
print(authService.user?.name) // nil&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이를 Singleton Pattern을 적용하여 해결해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class AuthService {
static let shared = AuthService()
private init() { print(&amp;#34;인스턴스 생성&amp;#34;) }
private(set) var user: User?
func login(email: String, password: String) {
// 서버에 로그인을 요청하여 사용자 정보를 불러옴
user = User(id: &amp;#34;1&amp;#34;, name: &amp;#34;jinyongp&amp;#34;)
}
func logout() {
// 서버에 로그아웃을 요청
user = nil
}
func update(user: User) {
// 서버에 요청
self.user = user
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>static&lt;/code> 키워드를 활용하여 &lt;code>shared&lt;/code>라는 타입 속성을 추가했습니다. &lt;code>shared&lt;/code>는 &lt;code>AuthService&lt;/code>의 생성자를 실행하여 인스턴스를 얻습니다. 그리고 새로운 인스턴스 생성을 막기 위해 &lt;code>private init() {}&lt;/code>을 추가했습니다. 이제 외부에서 생성자를 호출할 수 없고, &lt;code>shared&lt;/code> 속성으로만 인스턴스를 얻을 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Swift에서 타입 속성은 lazy로 동작합니다. 즉, 타입 속성에 처음 접근할 때 생성자를 실행합니다. 그렇기에 &lt;code>shared&lt;/code>를 사용하지 않는다면 인스턴스가 생성되지 않습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 로그인을 통해 사용자 정보 저장
let authService = AuthService.shared
authService.login(email: &amp;#34;dev.jinyongp@gmail.com&amp;#34;, password: &amp;#34;PASSWORD&amp;#34;)
print(authService.user?.name) // jinyongp&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 동일한 인스턴스를 가지므로 다른 곳에서 사용자 정보를 볼러올 수 있음
let authService = AuthService.shared
print(authService.user?.name) // jinyongp&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이제 &lt;code>AuthService&lt;/code>의 인스턴스는 하나만 생성됨을 보장하고 인스턴스의 데이터를 유지할 수 있습니다.&lt;/p></description></item><item><title>Understanding Coordinator Pattern</title><link>https://jinyongp.dev/posts/uikit/2/</link><pubDate>Tue, Aug 15 05:56:30 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/uikit/2/</guid><description>&lt;p>AnyObject 사용이유&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://stackoverflow.com/a/64186834"
target="_blank" rel="noopener noreferrer nofollow"
>https://stackoverflow.com/a/64186834&lt;/a
>&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://zeddios.medium.com/coordinator-pattern-bf4a1bc46930"
target="_blank" rel="noopener noreferrer nofollow"
>Coordinator Pattern - Zedd&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://somevitalyz123.medium.com/coordinator-pattern-with-tab-bar-controller-33e08d39d7d"
target="_blank" rel="noopener noreferrer nofollow"
>Coordinator pattern with Tab Bar Controller&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Factory Method Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/4/</link><pubDate>Sun, Aug 13 14:15:28 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/4/</guid><description>&lt;p>&lt;strong>Factory Method Pattern&lt;/strong>은 앞서 알아본 Template Method Pattern과 유사합니다. 특정 인스턴스를 생성하는 메서드를 템플릿 메서드로 정의한 것 뿐입니다. 그렇기에 Template Method Pattern의 특징 그대로 인스턴스를 생성하는 공통된 로직을 템플릿화하여 재사용할 수 있습니다. 동일한 유형의 다양한 객체를 생성하는데 여러 단계의 처리나 조건부 로직이 필요할 때 패턴을 적용해볼 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Factory Method Pattern&lt;/code>은 GoF의 분류 체계에서 생성(Creational) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Factory Method Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Product(제품): Factory Method로 생성되는 객체의 인터페이스를 결정합니다.&lt;/li>
&lt;li>Creator(생산자): Product 역할을 생성하는 추상 클래스입니다.&lt;/li>
&lt;li>ConcreteProduct(구체적인 제품): Product 역할의 인스턴스를 실제로 생성합니다.&lt;/li>
&lt;li>ConcreteCreator(구체적인 생산자): Product 역할의 인스턴스를 생성하는 클래스입니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 예제를 Swift 코드로 작성해봅시다.&lt;/p>
&lt;p>먼저 &lt;code>Product&lt;/code> 프로토콜을 정의합니다. 모든 &lt;code>Product&lt;/code>는 이름(&lt;code>name&lt;/code>)을 가지고 가장 무난한 &lt;code>use()&lt;/code> 메서드를 제공한다고 가정해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Product {
var name: String { get }
func use()
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>그리고 Creator 역할을 수행하는 &lt;code>Factory&lt;/code> 프로토콜을 정의합니다. 제품 &lt;code>Product&lt;/code>를 생성하는 역할을 수행하는 &lt;code>Factory&lt;/code>는 &lt;code>create()&lt;/code> factory method를 가집니다. &lt;code>create()&lt;/code> 메서드는 &lt;code>Product&lt;/code>를 생성하고 &lt;code>register()&lt;/code> 메서드를 호출하며 하위 클래스에서 정의한 구체적인 동작을 수행하는 등 복잡한 로직을 수행한다고 가정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Factory {
func createProduct(owner: String) -&amp;gt; Product
func register(product: Product)
}
extension Factory {
func create(owner: String) -&amp;gt; Product {
let product: Product = createProduct(owner: owner)
register(product: product)
return product
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>생산하고자 하는 ConcreteProduct인 &lt;code>IDCard&lt;/code> 클래스를 정의합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class IDCard: Product {
var name: String { &amp;#34;[ID Card: \(owner)]&amp;#34; }
private(set) var owner: String
init(owner: String) {
print(&amp;#34;카드를 생성합니다. (소유자: \(owner))&amp;#34;)
self.owner = owner
}
func use() {
print(&amp;#34;\(self.name) 사용&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>IDCard&lt;/code> 클래스는 &lt;code>Factory&lt;/code>에 전혀 의존하고 있지 않습니다. 그렇기에 하나의 Product를 생산하는 Factory는 여러 종류가 될 수 있다고 예상할 수 있습니다.&lt;/p>
&lt;p>&lt;code>IDCard&lt;/code>를 생산하기 위해 구체적인 내용을 담고 있는 &lt;code>IDCardFactory&lt;/code> 클래스를 정의합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class IDCardFactory: Factory {
func createProduct(owner: String) -&amp;gt; Product {
return IDCard(owner: owner)
}
func register(product: Product) {
print(&amp;#34;\(product.name) 등록&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이를 토대로 &lt;code>IDCardFactory&lt;/code>를 통해 제품을 생산하는 예제를 작성해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let factory: Factory = IDCardFactory()
let products = [
factory.create(owner: &amp;#34;Kim&amp;#34;),
factory.create(owner: &amp;#34;Park&amp;#34;),
factory.create(owner: &amp;#34;Son&amp;#34;),
]
for product in products {
product.use()
}
// output:
// 카드를 생성합니다. (소유자: Kim)
// [ID Card: Kim] 등록
// 카드를 생성합니다. (소유자: Park)
// [ID Card: Park] 등록
// 카드를 생성합니다. (소유자: Son)
// [ID Card: Son] 등록
// [ID Card: Kim] 사용
// [ID Card: Park] 사용
// [ID Card: Son] 사용&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>단순히 객체를 생성하기 위해 틀을 만드는 건 함수로도 충분할 수 있습니다. 허나, 프로토콜과 클래스를 활용하여 객체 생성 로직과 사용 로직을 분리할 수 있었습니다. 또한, 객체의 생성과 관련된 공통 로직을 묶고 하위 클래스에서 재정의한 복잡한 로직을 하위 클래스에서 재정의할 수 있게 되어 변경에 있어 유연성을 얻을 수 있었습니다.&lt;/p></description></item><item><title>Template Method Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/3/</link><pubDate>Sat, Aug 12 09:52:24 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/3/</guid><description>&lt;p>&lt;strong>Template Method Pattern&lt;/strong>은 특정 알고리즘을 반복적으로 사용하고 있을 때 중복을 제거하기 위하여 적용해볼 수 있습니다. 공통 알고리즘을 묶을 템플릿 메서드를 포함할 추상 클래스를 정의하고, 하위 클래스에서 구체적인 내용을 작성하는 패턴입니다. 해당 패턴을 통해 코드 중복을 제거하고 공통된 알고리즘을 재사용할 수 있습니다. 템플릿 메서드의 변경이 필요하다면 하위 클래스에서 재정의를 통해 인터페이스의 변경 없이 세부 구현을 변경할 수도 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Template Method Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Template Method Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>AbstractClass(추상 클래스): 템플릿 메서드를 정의하고 하위 클래스에서 구현할 메서드를 정의합니다.&lt;/li>
&lt;li>ConcreteClass(구현 클래스): 추상 클래스에서 정의한 추상 메서드를 구현합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 예제를 Swift 코드로 작성해봅시다. AbstractClass 역할을 수행하는 &lt;code>AbstractDisplay&lt;/code> 클래스를 정의합니다. &lt;code>AbstractDisplay&lt;/code> 클래스는 템플릿 메서드인 &lt;code>display&lt;/code> 메서드를 정의하고 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol AbstractDisplay {
func open()
func write()
func close()
}
extension AbstractDisplay {
func display() {
open()
for _ in 0..&amp;lt;5 {
write()
}
close()
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>AbstractClass&lt;/code>는 추상 클래스이므로 구현되어 있는 메서드가 존재하고 인스턴스를 생성할 수 없어야 합니다. &lt;code>protocol&lt;/code>과 &lt;code>extension&lt;/code> 키워드를 활용하여 추상 클래스를 정의하였습니다. &lt;code>display&lt;/code> 템플릿 메서드를 사용하고 싶다면, &lt;code>AbstractClass&lt;/code>를 채택하고 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class CharDisplay: AbstractDisplay {
private let char: Character
init(char: Character) {
self.char = char
}
func open() {
print(&amp;#34;&amp;lt;&amp;lt;&amp;#34;, terminator: &amp;#34;&amp;#34;)
}
func write() {
print(char, terminator: &amp;#34;&amp;#34;)
}
func close() {
print(&amp;#34;&amp;gt;&amp;gt;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = CharDisplay(char: &amp;#34;H&amp;#34;)
display.display()
// output:
// &amp;lt;&amp;lt;HHHHH&amp;gt;&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>AbstractDisplay&lt;/code>를 채택하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>open&lt;/code>, &lt;code>write&lt;/code>, &lt;code>close&lt;/code> 메서드를 구현하고 있습니다. &lt;code>CharDisplay&lt;/code> 클래스는 &lt;code>display&lt;/code> 메서드를 구현하지 않았지만, &lt;code>AbstractDisplay&lt;/code>의 &lt;code>display&lt;/code> 메서드를 사용할 수 있습니다.&lt;/p>
&lt;p>또 다른 클래스를 정의해봅니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class StringDisplay: AbstractDisplay {
private let string: String
private let width: Int
init(string: String) {
self.string = string
self.width = string.count
}
func open() {
printLine()
}
func write() {
print(&amp;#34;|\(string)|&amp;#34;)
}
func close() {
printLine()
}
private func printLine() {
print(&amp;#34;&amp;#43;\(String(repeating: &amp;#34;-&amp;#34;, count: width))&amp;#43;&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let display: AbstractDisplay = StringDisplay(string: &amp;#34;Hello, World&amp;#34;)
display.display()
// output:
// &amp;#43;-------------&amp;#43;
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// |Hello, World|
// &amp;#43;-------------&amp;#43;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇듯 하나의 공통적인 로직을 템플릿화하여 코드의 중복을 없앨 수 있고, 추상 클래스를 상속(채택)하는 방식으로 인하여 상위 클래스 형식의 변수에 하위 클래스 인스턴스 중 어느 것을 대입해도 제대로 동작해야 한다는 원칙인 &lt;code>리스코프 치환 원칙(LSP, Liskov Substitution Principle)&lt;/code>을 만족합니다.&lt;/p>
&lt;p>Swift에서는 &lt;code>extension&lt;/code> 키워드의 존재로 인터페이스를 변경하지 않고도 쉽게 새로운 공통 로직을 언제든 추가할 수 있습니다.&lt;/p></description></item><item><title>[내배캠] UIKit 입문 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/5/</link><pubDate>Fri, Aug 11 06:52:27 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/5/</guid><description>&lt;p>2023년 7월 31일부터 8월 11일까지 UIKit의 기초적인 내용을 학습하고 간단한 ToDo App을 만들어보았습니다.&lt;/p>
&lt;p>기본으로 제공되는 강의도 있었지만 프로젝트를 진행하기에 내용이 그리 충분치 않았기에 별도의 강의를 수강하면서 과제를 수행하였습니다. &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨&lt;/a
> 과정을 어느 정도 수강하면 무료로 제공해주는 &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8-%ec%95%b1%eb%a7%8c%eb%93%a4%ea%b8%b0"
target="_blank" rel="noopener noreferrer nofollow"
>15개 앱을 만들면서 근본원리부터 배우는 UIKit&lt;/a
> 강의를 병행하였습니다. 프로젝트의 요구 조건을 충족하기 위해 필요한 몇몇 지식을 습득했습니다.&lt;/p>
&lt;ul>
&lt;li>UIKit의 기본적인 구조와 사용법&lt;/li>
&lt;li>리스트를 표시하는 방법 (UITableView)&lt;/li>
&lt;li>페이지 간 이동 및 데이터 전달 방법 (Segue)&lt;/li>
&lt;li>Alert 표시 및 사용자로부터 입력 받는 방법 (UIAlertController)&lt;/li>
&lt;/ul>
&lt;h3 id="project-structure" class="flex items-center gap-3">Project Structure &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Project Structure" href="#project-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">TodoApp/
├── LaunchScreen.storyboard
├── Main.storyboard
├── Models/
│ └── TodoItem.swift
├── Services/
│ └── TodoService.swift
├── Views/
│ ├── ViewController.swift
│ ├── CompletesViewController.swift
│ └── TodoTableViewCell.swift
├── Info.plist
├── AppDelegate.swift
└── SceneDelegate.swift&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Views&lt;/code>: UI를 담당하는 클래스를 가집니다.&lt;/li>
&lt;li>&lt;code>Models&lt;/code>: 데이터 모델 구조체를 가집니다.&lt;/li>
&lt;li>&lt;code>Services&lt;/code>: 데이터를 관리하는 비즈니스 로직을 담은 클래스를 가집니다&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="storyboard" class="flex items-center gap-3">Storyboard &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Storyboard" href="#storyboard"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;img class="mx-auto" alt="Storyboard" src="https://jinyongp.dev/image/learn/nbcamp/5/storyboard.png" />
&lt;/p>
&lt;div class="flex gap-2 md:gap-5 justify-center">
&lt;img class="shadow-md" src="https://jinyongp.dev/image/learn/nbcamp/5/main-page.png" width="23%" alt="Main Page">
&lt;img class="shadow-md" src="https://jinyongp.dev/image/learn/nbcamp/5/completes-page.png" width="23%" alt="Completes Page">
&lt;img class="shadow-md" src="https://jinyongp.dev/image/learn/nbcamp/5/add-new-item.png" width="23%" alt="Completes Page">
&lt;img class="shadow-md" src="https://jinyongp.dev/image/learn/nbcamp/5/edit-item.png" width="23%" alt="Completes Page">
&lt;/div>
&lt;h3 id="implementation" class="flex items-center gap-3">Implementation &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Implementation" href="#implementation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="todoitem" class="flex items-center gap-3">TodoItem &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoItem" href="#todoitem"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoItem {
var id: String
var content: String
var createdAt: UInt
var completedAt: UInt?
var completed: Bool { completedAt != nil }
init(content: String) {
self.id = UUID().uuidString
self.content = content
self.createdAt = UInt(Date().timeIntervalSince1970)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>배열에서 인스턴스를 가져오는 과정에서 값의 복사가 아닌 참조를 가져오길 원했습니다. 그런 이유로 &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>를 사용했고, 상속할 여지가 없으므로 &lt;code>final&lt;/code> 키워드를 붙여 Dynamic Dispatch 대신 Static Dispatch 방식을 채택하였습니다.&lt;/p>
&lt;h4 id="todoservice" class="flex items-center gap-3">TodoService &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoService" href="#todoservice"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoService {
static var shared: TodoService = .init()
private init() {}
private(set) var items: [TodoItem] = [
TodoItem(content: &amp;#34;New를 눌러 새로운 항목을 추가해보세요!&amp;#34;),
TodoItem(content: &amp;#34;여기를 눌러 할 일 내용을 변경해보세요!&amp;#34;),
TodoItem(content: &amp;#34;체크박스를 눌러 할 일을 완료해보세요!&amp;#34;),
TodoItem(content: &amp;#34;Completes를 눌러 완료 내역을 확인하세요!&amp;#34;),
]
func add(content: String) {
items.append(TodoItem(content: content))
}
func update(index: Int, content: String) {
items[index].content = content
}
func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>TodoService&lt;/code>의 경우, 대부분의 &lt;code>Views&lt;/code>에서 사용될 예정이므로 하나의 &lt;code>Items&lt;/code>만 생성되어야 함을 보장하기 위해 Singleton 패턴을 적용하였습니다.&lt;/p>
&lt;h4 id="viewcontroller" class="flex items-center gap-3">ViewController &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="ViewController" href="#viewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>&lt;code>ViewController&lt;/code>의 경우 Main Page의 View와 Logic을 담당합니다. UI 관련 로직은 생략했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class ViewController: UIViewController {
@IBOutlet weak var titleLabel: UILabel!
@IBOutlet weak var tableView: UITableView!
@IBOutlet weak var newButton: UIButton!
@IBOutlet weak var completesButton: UIButton!
private var todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { !$0.completed } }
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
func initializeUI() {
// ...
}
@IBAction func newButtonTapped(_ sender: UIButton) {
// ...
}
}
extension ViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;TodoCell&amp;#34;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let index = indexPath.row
let item = items[index]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { [weak self] cell in
guard let self else { return }
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
cell.onLabelTapped = { [weak self] label in
guard let self else { return }
let alert = UIAlertController(title: &amp;#34;Edit Todo Item&amp;#34;, message: nil, preferredStyle: .alert)
let confirmAction = UIAlertAction(title: &amp;#34;Edit&amp;#34;, style: .default) { [weak alert] _ in
let text = alert?.textFields?[0].text ?? &amp;#34;&amp;#34;
if text.isEmpty { return }
label.text = text
self.todoService.update(index: index, content: text)
}
let cancelAction = UIAlertAction(title: &amp;#34;Cancel&amp;#34;, style: .cancel) { _ in
self.dismiss(animated: true)
}
alert.addTextField { $0.placeholder = label.text }
alert.addAction(confirmAction)
alert.addAction(cancelAction)
self.present(alert, animated: true)
}
return cell
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>UITableViewDataSource&lt;/code>를 채택하여 TableView를 그리기 위해 필요한 최소 메서드를 구현하였습니다. 완료하지 않은 할 일 목록만 가져와서 표시하고 있습니다. &lt;code>TodoTableViewCell&lt;/code>에 데이터를 전달하고 어떠한 이벤트가 발생했을 때 실행할 함수를 클로저로 전달하고 있습니다. Delegate Pattern을 활용할 수 있겠지만, 단순하게 클로저를 전달하는 방법으로 구현하였습니다.&lt;/p>
&lt;p>완료 버튼을 눌렀을 땐 애니메이션과 함께 목록에서 제거하도록 작성하였고, 라벨을 눌렀을 땐 Alert을 띄워 내용을 수정할 수 있도록 작성하였습니다.&lt;/p>
&lt;h3 id="todotableviewcell" class="flex items-center gap-3">TodoTableViewCell &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="TodoTableViewCell" href="#todotableviewcell"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class TodoTableViewCell: UITableViewCell {
@IBOutlet weak var todoLabel: UILabel!
@IBOutlet weak var completeButton: UIButton!
var onCompleted: ((_: TodoTableViewCell) -&amp;gt; Void)?
var onLabelTapped: ((_: UILabel) -&amp;gt; Void)?
var completed: Bool = false {
didSet {
completeButton.isSelected = completed
let attributedText = NSMutableAttributedString(string: todoLabel.text!)
if completed {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.5, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
} else {
attributedText.addAttribute(NSAttributedString.Key.strikethroughStyle, value: [] as [Any], range: NSMakeRange(0, attributedText.length))
attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: CGColor(gray: 0.0, alpha: 1.0), range: NSMakeRange(0, attributedText.length))
}
todoLabel.attributedText = attributedText
}
}
override func didMoveToSuperview() {
initializeUI()
}
private func initializeUI() {
setupGesture()
}
private func setupGesture() {
let tapGesture = UITapGestureRecognizer(target: self, action: #selector(labelTapped))
todoLabel.isUserInteractionEnabled = true
todoLabel.addGestureRecognizer(tapGesture)
}
@objc
func labelTapped() {
onLabelTapped?(todoLabel)
}
@IBAction func doneButtonTapped(_ sender: UIButton) {
onCompleted?(self)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>TodoTableViewCell&lt;/code>은 완료 여부를 뜻하는 &lt;code>completed&lt;/code>을 감시자 속성으로 가지고 있어, &lt;code>completed&lt;/code>가 변경됨에 따라 라벨에 &lt;code>strikethrough&lt;/code> 스타일을 추가/제거합니다.&lt;/p>
&lt;p>라벨에 Touch Action을 등록하기 위해서 &lt;code>UITapGestureRecognizer&lt;/code>를 추가하였습니다.&lt;/p>
&lt;h3 id="completesviewcontroller" class="flex items-center gap-3">CompletesViewController &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="CompletesViewController" href="#completesviewcontroller"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>메인 페이지에서 &lt;code>completes&lt;/code> 버튼을 누르면 해당 페이지를 표시합니다. 버튼에 직접 등록하는 Segue 방식으로 연결하였습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class CompletesViewController: UIViewController {
@IBOutlet weak var tableView: UITableView!
private let todoService = TodoService.shared
private var items: [TodoItem] { todoService.items.filter { $0.completed } }
var onDismissed: (() -&amp;gt; Void)?
override func viewDidLoad() {
super.viewDidLoad()
tableView.dataSource = self
initializeUI()
}
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
onDismissed?()
}
func initializeUI() {
tableView.backgroundView = {
let label = UILabel()
label.text = &amp;#34;Complete Your Todo!&amp;#34;
label.textAlignment = .center
label.textColor = .gray
return label
}()
}
}
extension CompletesViewController: UITableViewDataSource {
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
UIView.animate(withDuration: 0.2) {
tableView.backgroundView?.layer.opacity = self.items.count &amp;gt; 0 ? 0.0 : 1.0
}
return items.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
guard let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;TodoCell&amp;#34;, for: indexPath) as? TodoTableViewCell else {
return UITableViewCell()
}
let item = items[indexPath.row]
cell.todoLabel.text = item.content
cell.completed = item.completed
cell.selectionStyle = .none
cell.onCompleted = { cell in
self.todoService.toggle(id: item.id)
cell.completed = item.completed
guard let indexPath = tableView.indexPath(for: cell) else { return }
tableView.deleteRows(at: [indexPath], with: .top)
}
return cell
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CompletesViewController&lt;/code>에서도 &lt;code>UITableView&lt;/code>를 사용하므로 &lt;code>ViewController&lt;/code>와 동일한 방식으로 구현하였습니다. 완료 버튼을 눌러 완료를 취소할 수 있도록 하였습니다. 완료를 취소한 후, 변경 내용이 메인 페이지에도 반영되어야 하므로 페이지가 닫힐 때 호출할 &lt;code>onDismissed&lt;/code> 클로저를 추가하였습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;#34;CompletesVC&amp;#34; {
if let vc = segue.destination as? CompletesViewController {
vc.onDismissed = {
self.tableView.reloadData()
}
}
}
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>CompletesViewController&lt;/code> 객체에 클로저를 전달하기 위해 &lt;code>ViewController&lt;/code>에 &lt;code>prepare&lt;/code> 메서드를 구현하였습니다. &lt;code>onDismissed&lt;/code>가 호출되면 메인 페이지의 &lt;code>tableView&lt;/code>를 갱신합니다.&lt;/p>
&lt;h5 id="delegate-패턴-적용" class="flex items-center gap-3">Delegate 패턴 적용 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Delegate 패턴 적용" href="#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h5>&lt;p>클로저 전달 방식 대신 Delegate 패턴을 적용해보았습니다. &lt;code>onDismissed&lt;/code> 클로저를 전달하는 대신 &lt;code>CompletesViewControllerDelegate&lt;/code> 프로토콜을 정의하여 &lt;code>onDismissed&lt;/code> 메서드 동작을 위임하도록 해보았습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">@objc protocol CompletesViewControllerDelegate {
@objc optional func onDismissed()
}
final class CompletesViewController: UIViewController {
var delegate: CompletesViewControllerDelegate?
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
delegate?.onDismissed?()
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension ViewController {
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
if segue.identifier == &amp;#34;CompletesVC&amp;#34; {
if let vc = segue.destination as? CompletesViewController {
vc.delegate = self
}
}
}
}
extension ViewController: CompletesViewControllerDelegate {
func onDismissed() {
tableView.reloadData()
}
} &lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>ViewController&lt;/code>가 &lt;code>prepare&lt;/code> 메서드에서 &lt;code>delegate&lt;/code> 인스턴스를 전달하고, &lt;code>CompletesViewControllerDelegate&lt;/code>를 채택하여 &lt;code>tableView&lt;/code>를 갱신하도록 작성했습니다. 위와 동일하게 동작함을 확인할 수 있습니다.&lt;/p>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Trouble Shooting" href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="1-객체의-속성-변경이-반영되지-않는-문제" class="flex items-center gap-3">1. 객체의 속성 변경이 반영되지 않는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="1. 객체의 속성 변경이 반영되지 않는 문제" href="#1-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%86%8d%ec%84%b1-%eb%b3%80%ea%b2%bd%ec%9d%b4-%eb%b0%98%ec%98%81%eb%90%98%ec%a7%80-%ec%95%8a%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>&lt;code>TodoService&lt;/code>에서 &lt;code>TodoItem&lt;/code>의 속성을 변경할 때 제대로 변경되지 않는 문제가 있었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">func toggle(id: String) {
guard let item = (items.first { $0.id == id }) else { return }
item.completedAt = item.completed ? nil : UInt(Date().timeIntervalSince1970)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>원인은 &lt;code>TodoItem&lt;/code>이 &lt;code>struct&lt;/code> 키워드로 선언되어 있어, &lt;code>first&lt;/code>를 통해 찾은 값을 &lt;code>item&lt;/code> 변수에 할당하는 과정에서 값의 복사가 발생하여 복사된 값의 속성을 변경하더라도 원본 값이 변경되지 않는 문제였습니다. &lt;code>struct&lt;/code> 대신 &lt;code>class&lt;/code>로 선언하는 방식으로 문제를 해결했습니다.&lt;/p>
&lt;h4 id="2-unknown-class-_viewcontroller-in-interface-builder-file-에러" class="flex items-center gap-3">2. Unknown class _ViewController in Interface Builder file. 에러 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2. Unknown class _ViewController in Interface Builder file. 에러" href="#2-unknown-class-_viewcontroller-in-interface-builder-file-%ec%97%90%eb%9f%ac"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>여러 ViewController를 생성하는 과정에서 xcode의 버그로 인해 Module이 제대로 설정되지 않아 발생한 문제였습니다.&lt;/p>
&lt;img class="!my-0 !mx-auto md:!ml-4 md:w-1/3 md:float-right" src="https://jinyongp.dev/image/learn/nbcamp/5/unknown-class-error.png" alt="Unknown Class Error">
&lt;p>Storyboard에서 문제가 발생하는 ViewController를 선택한 뒤, 우측 Inspector Pane의 Identifier Inspector에서 Custom Class 항목의 Module이 None인지 확인합니다. None이라면 프로젝트 이름으로 변경한 뒤 Inherit Module From Target을 활성화합니다.&lt;/p>
&lt;p>참고: &lt;a
class="underline-lsre"
href="https://points.tistory.com/10"
target="_blank" rel="noopener noreferrer nofollow"
>[iOS] Unknown class _ViewController in Interface Builder file.&lt;/a
>&lt;/p>
&lt;h3 id="retrospective" class="flex items-center gap-3">Retrospective &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Retrospective" href="#retrospective"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>UIKit로 개발하면서 여태까지 해왔던 웹 개발과 많은 비교를 하게 되었습니다. UIKit으로 개발하는 건 웹 개발로 비유를 하자면 HTML, CSS 없이 JavaScript로만 모든 UI와 Style을 작성하는 것과 비슷했습니다. 웹에서 HTML과 CSS 그리고 JavaScript가 분리되어 있다는 게 굉장한 장점이구나 다시 한번 느끼게 되었습니다. UIKit의 경우 모든 내용을 선언형이 아닌 명령형으로 작성해야 하기 때문에 각 역할에 맞게 적절하게 코드를 분리하기 위한 노력이 필요함을 절실히 깨달았습니다.&lt;/p>
&lt;p>Storyboard와 코드를 연동하여 작성되어야 하는 부분이 있기 때문에 코드가 실행되는데 눈에 보이는 부분보단 이렇게 동작할 것이다 추론해야 하는 경우가 많았고 에러가 발생해도 추적하기가 굉장히 어려워서 개발 경험이 그리 좋지 않았습니다. 아무래도 UIKit의 대부분이 Objective-C로 작성되어 있어 해당 내용을 알아야만 에러 내용을 통해 원인을 유추할 수 있는 것도 한몫 하다보니 어려웠던 듯 싶습니다. 협업 관점에서 보나 디버깅 관점에서 보나 웬만하면 Storyboard 방식보단 코드 방식의 개발이 더 유리하지 않을까 생각했습니다.&lt;/p>
&lt;p>이후 기초 팀 프로젝트에서는 코드 방식으로 개발을 진행하며 Storyboard 개발 방식과 비교해보고자 합니다.&lt;/p></description></item><item><title>Learning Software Design Pattern (Swift)</title><link>https://jinyongp.dev/series/design-pattern/1/</link><pubDate>Wed, Aug 09 09:45:38 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/design-pattern/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>소프트웨어 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하고 직면하는 문제에 대한 해결책입니다. 반복적으로 마주하는 문제에 대한 해결책을 청사진처럼 만들어두고 필요할 때마다 재사용할 수 있습니다.&lt;/p>
&lt;p>본 시리즈는 &lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>을 참고하여 작성했습니다. 본 서적에선 GoF의 23가지 디자인 패턴을 다루고 있습니다. 하지만 GoF의 분류 체계(생성, 구조, 행위)를 따르지 않고, 다른 관점으로 분류하고 있으므로 이를 따라서 작성했습니다.&lt;/p>
&lt;p>글의 구성은 어떤 문제 혹은 상황에 직면했을 때 적용할 법한 패턴인지, 그리고 Swift 언어를 활용한 예시를 통해 해당 디자인 패턴을 어떻게 구현할 수 있는지에 초점을 맞춰 작성했습니다. 부족한 부분이 있다면 꾸준히 개선해나갈 예정이므로 틀린 내용 혹은 추가되었으면 하는 내용이 있다면 댓글로 남겨주시면 감사하겠습니다.&lt;/p>
&lt;blockquote>
&lt;p>⚠️ 디자인 패턴을 갓 배운 많은 개발자는 문제를 더 간단히 해결할 수 있는 상황임에도 모든 곳에 패턴을 적용해보려는 실수를 범한다고 합니다. 문제를 해결하는데 더 간단한 방법이 있다면 굳이 디자인 패턴을 적용할 필요가 없습니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns/swift"
target="_blank" rel="noopener noreferrer nofollow"
>Design Pattern in Swift&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/ko/design-patterns"
target="_blank" rel="noopener noreferrer nofollow"
>Design pattern : Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문 : 쉽게 배우는 GoF의 23가지 디자인 패턴&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Adapter Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/2/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/2/</guid><description>&lt;p>&lt;strong>Adapter Pattern&lt;/strong>을 활용하면 외부 라이브러리의 인터페이스와 내가 사용하고자 하는 인터페이스가 호환되지 않을 때, 중간에 Adapter를 추가하는 방법으로 호환성을 확보할 수 있습니다. Wrapper Pattern으로 불리기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Adapter Pattern&lt;/code>은 GoF의 분류 체계에서 구조(Structural) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Adapter Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Target(대상): 서비스 내에서 사용 중인 인터페이스입니다.&lt;/li>
&lt;li>Client(의뢰자): Target을 사용하는 클래스입니다.&lt;/li>
&lt;li>Adaptee(적응 대상자): Target과 호환되지 않는 인터페이스입니다.&lt;/li>
&lt;li>Adapter(적응자): Adaptee를 Target으로 변환하는 클래스입니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Adapter를 구현하는 방법은 상속을 이용한 방법과 위임(인스턴스)을 이용한 방법으로 나뉘지만 &lt;code>Is-A&lt;/code>보단 &lt;code>Has-A&lt;/code>가 더 좋은 방법이므로 위임을 이용한 방법을 사용하도록 합니다. &lt;a
class="underline-lsre"
href="https://www.google.com/search?q=is-a&amp;#43;has-a&amp;#43;relationship"
target="_blank" rel="noopener noreferrer nofollow"
>Is-A Has-A Relationship&lt;/a
>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>예시를 통해 자세히 알아보겠습니다. 시스템 내에서 사용 중인 로깅 인터페이스가 있다고 가정해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Logger {
func log(message: String)
func warn(message: String)
func error(message: String)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Logger&lt;/code>는 Adapter Pattern의 구성 요소 중 Target 역할을 수행합니다. 이를 채택하는 클래스 &lt;code>MyLogger&lt;/code>를 구현합니다. &lt;code>MyLogger&lt;/code>는 Swift의 &lt;code>print()&lt;/code>함수를 이용하여 Termianl 환경에서 로그를 출력합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct MyLogger: Logger {
func log(message: String) {
print(&amp;#34;[LOG] \(message)&amp;#34;)
}
func warn(message: String) {
print(&amp;#34;[WARN] \(message)&amp;#34;)
}
func error(message: String) {
print(&amp;#34;[ERROR] \(message)&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Client 역할을 수행하는 &lt;code>App&lt;/code> 클래스에서 Logger 구현체를 주입받아 시스템 전체에 걸쳐 사용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// App.swift
final class App {
private let logger: Logger
init(logger: Logger) {
self.logger = logger
}
func doSomething() {
logger.log(message: &amp;#34;doSomething&amp;#34;)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// main.swift
let app = App(logger: MyLogger())
app.doSomething()
// output:
// [LOG] doSomething&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>MyLogger&lt;/code>는 swift의 &lt;code>print()&lt;/code> 함수에 의존하고 있습니다. 이제 외부 라이브러리를 통해 terminal 환경이 아닌 외부로 로그 정보를 보내려고 합니다. 외부 라이브러리 &lt;code>ExternalLogger&lt;/code>는 다음 인터페이스를 제공합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">enum LogLevel {
case debug
case info
case warn
case error
}
struct ExternalLogger {
func log(level: LogLevel, message: String) {
// 로그를 외부로 전송합니다.
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>언뜻 보기에도 &lt;code>ExternalLogger&lt;/code>는 &lt;code>Logger&lt;/code>와 호환되지 않는 것을 알 수 있습니다. 이럴 때 Adapter 클래스를 추가하여 호환성을 확보할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct ExternalLoggerAdapter: Logger {
private let logger = ExternalLogger()
func log(message: String) {
logger.log(level: .info, message: message)
}
func warn(message: String) {
logger.log(level: .warn, message: message)
}
func error(message: String) {
logger.log(level: .error, message: message)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let app = App(logger: ExternalLoggerAdapter())
app.doSomething()&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이렇게 Adapter 역할을 수행하는 중간자 클래스를 추가하여 세부 구현에 어떠한 변경도 없이 세부 구현에 어떠한 변경도 없이 확장에 성공하였습니다. 이런 식으로 Adapter 구조체를 추가하면 변경이 아닌 확장(OCP - 개방 폐쇄 원칙)이 되어 Side Effect도 없을 뿐더러 Unit Test를 작성하기도 쉬워집니다.&lt;/p></description></item><item><title>Iterator Pattern in Swift</title><link>https://jinyongp.dev/posts/design-pattern/1/</link><pubDate>Wed, Aug 09 06:35:34 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/design-pattern/1/</guid><description>&lt;p>&lt;strong>Iterator Pattern&lt;/strong>은 순회 로직을 순회자(Iterator) 객체로 분리합니다. 이러한 추상화 작업을 통해 순회 불가능한 객체더라도 인터페이스만 구현한다면 순회 가능한 객체로 만들 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Iterator Pattern&lt;/code>은 GoF의 분류 체계에서 행위(Behavioral) 패턴에 속합니다.&lt;/p>
&lt;/blockquote>
&lt;p>예를 들어, 자료구조 중 배열은 메모리 구조의 특징 덕분에 0..&amp;lt;배열크기 범위로 인덱스를 증가시키며 요소에 접근할 수 있습니다. 허나 리스트의 경우엔 순회 로직을 직접 구현하지 않는 한 인덱스를 이용한 순회가 불가능합니다. 리스트 클래스를 순회 가능한 객체로 만들기 위해선 별도의 구현을 추가해야 합니다. 여기서 Iterator Pattern을 적용한다면 리스트 클래스의 세부 구현을 변경하지 않고도 순회 가능한 객체로 확장할 수 있습니다.&lt;/p>
&lt;p>Iterator Pattern을 구현하기 위해 필요한 역할은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>Iterator(반복자): 순회 로직을 추상화한 인터페이스입니다. 다음 요소를 반환하는 &lt;code>next()&lt;/code> 메서드와 현재 요소가 마지막 요소인지 확인하는 &lt;code>hasNext()&lt;/code> 메서드를 포함합니다.&lt;/li>
&lt;li>ConcreteIterator(구체적인 반복자): Iterator 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;li>Aggregate(집합체): 순회 가능한 객체임을 나타내는 인터페이스입니다. ConcreteIterator 객체를 생성하여 반환하는 &lt;code>makeIterator()&lt;/code> 메서드를 포함하기도 합니다. (aka. Iterable)&lt;/li>
&lt;li>ConcreteAggregate(구체적인 집합체): Aggregate 인터페이스를 구현한 객체입니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;a
class="underline-lsre"
href="https://product.kyobobook.co.kr/detail/S000200311846"
target="_blank" rel="noopener noreferrer nofollow"
>Java 언어로 배우는 디자인 패턴 입문&lt;/a
>의 Iterator Pattern 예제를 Swift로 작성해보았습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Iterable&amp;lt;Element&amp;gt; {
associatedtype Element where Element == Iter.Element
associatedtype Iter: Iterator
func makeIterator() -&amp;gt; Iter;
}
protocol Iterator&amp;lt;Element&amp;gt; {
associatedtype Element
mutating func next() -&amp;gt; Element?
}
struct Book {
private(set) var name: String
}
struct BookShelf {
private var books: [Book] = []
var count: Int { books.count }
func book(at index: Int) -&amp;gt; Book {
return books[index]
}
mutating func add(book: Book) {
books.append(book)
}
}
extension BookShelf: Iterable {
typealias Element = Book
typealias Iter = BookShelfIterator
func makeIterator() -&amp;gt; Iter {
return BookShelfIterator(self)
}
}
struct BookShelfIterator: Iterator {
typealias Element = Book
private let bookShelf: BookShelf
private var index: Int
init(_ bookShelf: BookShelf) {
self.bookShelf = bookShelf
index = 0
}
mutating func next() -&amp;gt; Element? {
if bookShelf.count &amp;gt; index {
defer { index &amp;#43;= 1 }
return bookShelf.book(at: index)
}
return nil
}
}
var bookShelf = BookShelf()
bookShelf.add(book: Book(name: &amp;#34;Book1&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book2&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book3&amp;#34;))
bookShelf.add(book: Book(name: &amp;#34;Book4&amp;#34;))
var iterator = bookShelf.makeIterator()
while let book = iterator.next() {
print(book.name)
}
// output:
// Book1
// Book2
// Book3
// Book4&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>Swift에서는 &lt;code>nil&lt;/code> 값을 제공하므로 &lt;code>hasNext()&lt;/code> 메서드 대신 &lt;code>next()&lt;/code> 메서드가 &lt;code>nil&lt;/code>을 반환하면 순회를 종료하도록 구현합니다.&lt;/p>
&lt;/blockquote>
&lt;p>코드에 따르면 각 구조체는 다음 역할을 따릅니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Iterator&lt;/code>: Iterator&lt;/li>
&lt;li>&lt;code>BookShelfIterator&lt;/code>: ConcreteIterator&lt;/li>
&lt;li>&lt;code>Iterable&lt;/code>: Aggregate&lt;/li>
&lt;li>&lt;code>BookShelf&lt;/code>: ConcreteAggregate&lt;/li>
&lt;/ul>
&lt;p>이렇게 순회를 담당하는 로직을 별도의 클래스로 분리하여 확장성을 높이는 것이 Iterator Pattern의 핵심입니다. 인터페이스를 활용한 이러한 확장성 및 다형성 덕분에 &lt;code>Iterator&lt;/code> 인터페이스만 구현하고 있으면 모든 순회가 필요한 로직에 적용할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이미 Swift에서는 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol&lt;/a
> 프로토콜을 제공하여 어떠한 클래스든 &lt;code>IteratorProtocol&lt;/code>을 채택하여 &lt;code>for in&lt;/code> 구문에 활용할 수 있습니다. (Aggregate 역할을 &lt;code>Sequence&lt;/code> 프로토콜이 수행합니다.)&lt;/p>
&lt;p>Apple 공식 문서의 예제를 가져왔습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">struct Countdown: Sequence {
let start: Int
func makeIterator() -&amp;gt; CountdownIterator {
return CountdownIterator(self)
}
}
struct CountdownIterator: IteratorProtocol {
let countdown: Countdown
var times = 0
init(_ countdown: Countdown) {
self.countdown = countdown
}
mutating func next() -&amp;gt; Int? {
let nextNumber = countdown.start - times
guard nextNumber &amp;gt; 0 else { return nil }
times &amp;#43;= 1
return nextNumber
}
}
let countdown3 = Countdown(start: 3)
for count in countdown3 {
print(&amp;#34;\(count)...&amp;#34;)
}
// output:
// 3..
// 2..
// 1..&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Countdown&lt;/code>은 ConcreteAggregate 역할을 수행하며, &lt;code>CountdownIterator&lt;/code>는 ConcreteIterator 역할을 수행합니다. 이렇게 순회 로직을 분리하는 방식으로 Collection 형식이 아니라 하더라도 순회 로직을 추가함으로서 순회 가능한 객체를 만들 수 있습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://refactoring.guru/design-patterns/iterator"
target="_blank" rel="noopener noreferrer nofollow"
>Iterator Pattern : Refactoring Guru&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/iteratorprotocol"
target="_blank" rel="noopener noreferrer nofollow"
>IteratorProtocol : Apple&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Understanding Delegate Pattern</title><link>https://jinyongp.dev/posts/uikit/1/</link><pubDate>Tue, Aug 01 03:32:29 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/uikit/1/</guid><description>&lt;h2 id="introduce-delegate-pattern" class="flex items-center gap-3">Introduce Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduce Delegate Pattern" href="#introduce-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>UIKit에서는 여러가지 UI 관련 View를 제공합니다. 이 중에선 동작에 필요한 세부 구현은 숨겨진 채로 특정 상황이 발생했을 때만 ViewController에게 데이터를 전달하는 UIView가 있습니다.&lt;/p>
&lt;p>예를 들어 &lt;code>UITextField&lt;/code>의 경우, 사용자가 입력창을 눌렀을 때 OS에게 키보드를 열 것을 명령하며 사용자가 입력한 값을 &lt;code>UITextField&lt;/code>에 전달하는 동작이 구현되어 있을 것입니다. 하지만 ViewController에선 이러한 세부 동작은 알 필요 없이 특정 상황이 발생했을 때만 데이터를 전달 받아 이용하면 됩니다.&lt;/p>
&lt;p>UIkit에서는 이렇게 세부 구현은 숨긴 채로 특정 상황이 발생했음을 알리거나 동작의 제어를 위임하기 위해 Delegate Pattern을 활용하고 있습니다. &lt;code>UITextField&lt;/code>는 &lt;code>UITextFieldDelegate&lt;/code> 프로토콜을 통해 이를 구현하고 있으며, 이를 채택한 ViewController는 다음의 메서드를 구현하여 데이터를 전달받고 동작을 제어할 수 있습니다.&lt;/p>
&lt;p>&lt;code>UITextFieldDelegate&lt;/code>를 채택하여 구현할 수 있는 메서드 목록은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// 편집을 시작할 때 호출합니다. Bool 값을 반환하여 편집을 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldBeginEditing(_:) -&amp;gt; Bool
// 편집이 시작된 직후 호출됩니다.
optional func textFieldDidBeginEditing(_:)
// 편집이 종료될 때 호출됩니다. Bool 값을 반환하여 편집을 중지할지 여부를 결정할 수 있습니다.
optional func textFieldShouldEndEditing(_:) -&amp;gt; Bool
// 편집이 종료된 직후 호출됩니다.
optional func textFieldDidEndEditing(_:)
// 텍스트 필드의 문자열이 변경될 때 호출됩니다. Bool 값을 반환하여 변경을 허용할지 여부를 결정할 수 있습니다.
optional func textField(_:shouldChangeCharactersIn:replacementString:) -&amp;gt; Bool
// 텍스트 필드의 선택 영역이 변경될 때 호출됩니다.
optional func textFieldDidChangeSelection(_:)
// 텍스트를 삭제할 때 호출됩니다. Bool 값을 반환하여 삭제를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldClear(_:) -&amp;gt; Bool
// 텍스트 필드의 리턴 키가 눌렸을 때 호출됩니다. Bool 값을 반환하여 리턴 키를 허용할지 여부를 결정할 수 있습니다.
optional func textFieldShouldReturn(_:) -&amp;gt; Bool&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>&lt;code>optional&lt;/code> 키워드로 정의되어 있으니 ViewController는 이 중에서 필요한 메서드만 구현하면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>정의한 메서드가 호출되려면 &lt;code>UITextField&lt;/code> 인스턴스의 &lt;code>delegate&lt;/code> 프로퍼티에 ViewController를 할당해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">final class ViewController: UIViewController {
private let textField = UITextField()
override func viewDidLoad() {
super.viewDidLoad()
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
// ...
}
func textFieldDidBeginEditing(_ textField: UITextField) {
// ...
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이런 식으로 Delegate Pattern을 통해 동작의 제어권을 위임받을 수 있습니다.&lt;/p>
&lt;h2 id="understand-delegate-pattern" class="flex items-center gap-3">Understand Delegate Pattern &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Understand Delegate Pattern" href="#understand-delegate-pattern"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>그렇다면 Delegate Pattern은 어떤 식으로 동작하기에 다른 객체에게 동작의 제어권을 위임할 수 있는걸까요? 간단한 &lt;code>Delegate&lt;/code> 프로토콜을 구현하여 동작을 확인해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool
func textFieldDidBeginEditing(_ textField: UITextField)
}
class UITextField {
var delegate: UITextFieldDelegate?
func userTextFieldTapped() {
guard let delegate else { return }
if delegate.textFieldShouldBeginEditing(self) {
// OS에게 키보드 열기 요청
delegate.textFieldDidBeginEditing(self)
}
}
}
class ViewController {
let textField = UITextField()
func viewDidLoad() {
textField.delegate = self
}
}
extension ViewController: UITextFieldDelegate {
func textFieldShouldBeginEditing(_ textField: UITextField) -&amp;gt; Bool {
print(#function)
return true
}
func textFieldDidBeginEditing(_ textField: UITextField) {
print(#function)
}
}
let controller = ViewController()
controller.viewDidLoad()
controller.textField.userTextFieldTapped()
// output:
// textFieldShouldBeginEditing(_:)
// textFieldDidBeginEditing(_:)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>소스 코드가 공개되어 있지 않으므로 정확한 세부 구현은 알 수 없으나 Delegate 패턴을 활용한 내부 모습은 대략 위와 비슷할 것으로 추정합니다.&lt;/p>
&lt;p>&lt;code>UITextField&lt;/code>의 경우 외부로부터 주입 받은 &lt;code>delegate&lt;/code> 객체를 통해 &lt;code>textFieldShouldBeginEditing&lt;/code>를 호출하여 동작의 제어권을 위임한 모습입니다. &lt;code>textFieldShouldBeginEditing&lt;/code>에서 &lt;code>false&lt;/code>를 반환하면 &lt;code>textFieldDidBeginEditing&lt;/code>는 호출되지 않을 것입니다.&lt;/p>
&lt;p>이러한 원리를 응용하여 Custom Delegate를 추가할 수 있습니다. &lt;a
class="underline-lsre"
href="https://jinyongp.dev/learn/nbcamp/5#delegate-%ed%8c%a8%ed%84%b4-%ec%a0%81%ec%9a%a9"
>Delegate Pattern 적용하기&lt;/a
>&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/uikit/uitextfield"
target="_blank" rel="noopener noreferrer nofollow"
>Apple Developer : UITextField&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/uikit/uitextfielddelegate"
target="_blank" rel="noopener noreferrer nofollow"
>Apple Developer : UITextFieldDelegate&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8-%ec%95%b1%eb%a7%8c%eb%93%a4%ea%b8%b0"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨 (15개 앱을 만들면서 근본 원리부터 배우는 UIKit)&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Git WIP Automation (Git hooks)</title><link>https://jinyongp.dev/posts/git/1/</link><pubDate>Sun, Jul 23 12:06:31 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/git/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2></description></item><item><title>[내배캠] Swift 심화 팀 과제</title><link>https://jinyongp.dev/learn/nbcamp/4/</link><pubDate>Fri, Jul 21 09:25:11 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/4/</guid><description>&lt;p>3주차가 되었습니다!&lt;/p>
&lt;p>이번 주차에서는 팀 프로젝트로서 Swift 심화 내용을 학습하고 간단한 키오스크 CLI 프로그램을 작성했습니다.&lt;/p>
&lt;p>이번에도 저번 개인 프로젝트에서 진행했던대로 터미널 환경에서 Swift 프로젝트를 생성하여 진행했습니다.&lt;/p>
&lt;p>구현한 키오스크 프로그램은 다음의 기능을 제공합니다.&lt;/p>
&lt;ol>
&lt;li>메뉴 화면 및 세부 메뉴 화면 표시&lt;/li>
&lt;li>숫자를 입력하여 메뉴 선택 가능&lt;/li>
&lt;li>메뉴를 장바구니에 추가하고 관리&lt;/li>
&lt;li>장바구니에 있는 메뉴를 주문&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>결과 미리보기&lt;/strong>&lt;/p>
&lt;details class="rounded group my-2">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer hover:text-accent"
>
SHAEKSHACK 메뉴 선택 화면
&lt;span
class="text-xs text-slate-500 hover:text-accent before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ ⭐️ WELCOME SHAKESHACK ⭐️ ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Burger ┃ 앵거스 비프 통살을 다져만든 버거
2. Flat-Top Degs ┃ 참나무칩으로 훈연한 소시지가 들어간 핫 도그
3. Frozen Custard ┃ 매장에서 신선하게 만드는 아이스크림
4. Drink ┃ 매장에서 직접 만드는 상큼한 음료
5. Beer ┃ 뉴욕 브루클린 브루어리에서 양조한 맥주
6. Order ┃ 장바구니를 확인합니다.
7. Exit ┃ 프로그램을 종료합니다
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="peer-hover:text-accent text-xs text-right text-slate-500">
SHAEKSHACK 메뉴 선택 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer hover:text-accent"
>
Burger 메뉴 선택 화면
&lt;span
class="text-xs text-slate-500 hover:text-accent before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ 🍔 Burger MENU 🥤 ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Shack Burger ┃ W 6.9 ┃ 토마토, 양상추, 쉑소스가 토핑된 치즈버거
2. Smoke Burger ┃ W 8.9 ┃ 베이컨, 체리 페퍼, 쉑소스가 들어간 치즈버거
3. Shroom Burger ┃ W 9.4 ┃ 치즈로 속을 채운 베지테리안 버거
4. Shack Stack ┃ W 9.9 ┃ 슈룸 버거, 쉑버거의 맛을 즐길 수 있는 메뉴
5. Cheeseburger ┃ W 6.9 ┃ 포테이토 번, 비프패티, 치즈를 담은 치즈버거
6. Hamburger ┃ W 5.4 ┃ 포테이토 번, 비프패티, 신선한 재료를 담은 버거
0. Back ┃ 홈 화면으로 돌아갑니다.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 3
3. Shroom Burger ┃ W 9.4 ┃ 치즈로 속을 채운 베지테리안 버거
장바구니에 추가할까요? (Y/n): Y
정상적으로 추가되었습니다.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="peer-hover:text-accent text-xs text-right text-slate-500">
Burger 메뉴 선택 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer hover:text-accent"
>
장바구니 화면
&lt;span
class="text-xs text-slate-500 hover:text-accent before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[ ⭐️ WELCOME SHAKESHACK ⭐️ ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Burger ┃ 앵거스 비프 통살을 다져만든 버거
2. Flat-Top Degs ┃ 참나무칩으로 훈연한 소시지가 들어간 핫 도그
3. Frozen Custard ┃ 매장에서 신선하게 만드는 아이스크림
4. Drink ┃ 매장에서 직접 만드는 상큼한 음료
5. Beer ┃ 뉴욕 브루클린 브루어리에서 양조한 맥주
6. Order ┃ 장바구니를 확인합니다.
0. Exit ┃ 프로그램을 종료합니다
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 6&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="peer-hover:text-accent text-xs text-right text-slate-500">
장바구니 화면
&lt;/div>
&lt;/details>
&lt;details class="rounded group my-2">
&lt;summary
class="peer list-none flex items-center justify-between cursor-pointer hover:text-accent"
>
주문 화면
&lt;span
class="text-xs text-slate-500 hover:text-accent before:content-['EXPAND'] before:group-open:content-['COLLAPSE']"
>&lt;/span>
&lt;/summary>
&lt;div class="border-y">
&lt;p>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">[ 🍕 Order List 💳 ]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Buy ┃ 장바구니에 담은 제품을 구매합니다.
2. Clear ┃ 장바구니를 비웁니다.
0. Back ┃ 홈 화면으로 돌아갑니다.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
품목 목록
Shroom Burger x 1
🧾 Total Order Price: 9,400 WON
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
No. 1
결제가 정상적으로 처리되었습니다. 감사합니다.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;/div>
&lt;div class="peer-hover:text-accent text-xs text-right text-slate-500">
주문 화면
&lt;/div>
&lt;/details>
&lt;h3 id="directory-structure" class="flex items-center gap-3">Directory Structure &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Directory Structure" href="#directory-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">.
├── Options/
│ └── Option.swift
├── Services/
│ ├── CoreService.swift
│ ├── OrderService.swift
│ ├── Receipt.swift
│ └── WaitService.swift
├── Viewers/
│ ├── ConsoleViewer.swift
│ └── Viewer.swift
├── App.swift
└── main.swift&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="implementation" class="flex items-center gap-3">Implementation &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Implementation" href="#implementation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>이번 프로젝트에선 enum 형식의 Associated Value를 적극적으로 활용하여 메뉴 화면에 표시될 옵션을 구현했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">enum Option: Equatable, Hashable {
struct Attr {
let id: Int
let name: String
let desc: String
}
case category(attr: Attr, menus: [Option])
case menu(attr: Attr, price: Int)
case order(attr: Attr, actions: [Option])
case action(attr: Attr)
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Option&lt;/code> enum은 재귀적으로 작성되어 메뉴를 선택하면 하위 메뉴가 표시되는 구조입니다. &lt;code>main.swift&lt;/code> 파일에서 세부적인 모든 옵션을 추가하고 &lt;code>App&lt;/code> 클래스에 서비스를 등록합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">import Foundation
let viewer = ConsoleViewer()
let app = App(core: CoreService(
viewer: viewer,
orderService: OrderService(),
waitService: WaitService(
viewer: viewer,
queue: DispatchQueue(
label: &amp;#34;waiting&amp;#34;,
attributes: .concurrent)))
)
app.register(option: .category(
attr: Option.Attr(id: 1, name: &amp;#34;Burger&amp;#34;, desc: &amp;#34;앵거스 비프 통살을 다져만든 버거&amp;#34;),
menus: [
.menu(attr: Option.Attr(id: 1, name: &amp;#34;Shack Burger&amp;#34;, desc: &amp;#34;토마토, 양상추, 쉑소스가 토핑된 치즈버거&amp;#34;), price: 6900),
.menu(attr: Option.Attr(id: 2, name: &amp;#34;Smoke Burger&amp;#34;, desc: &amp;#34;베이컨, 체리 페퍼, 쉑소스가 들어간 치즈버거&amp;#34;), price: 8900),
.menu(attr: Option.Attr(id: 3, name: &amp;#34;Shroom Burger&amp;#34;, desc: &amp;#34;치즈로 속을 채운 베지테리안 버거&amp;#34;), price: 9400),
.menu(attr: Option.Attr(id: 4, name: &amp;#34;Shack Stack&amp;#34;, desc: &amp;#34;슈룸 버거, 쉑버거의 맛을 즐길 수 있는 메뉴&amp;#34;), price: 9900),
.menu(attr: Option.Attr(id: 5, name: &amp;#34;Cheeseburger&amp;#34;, desc: &amp;#34;포테이토 번, 비프패티, 치즈를 담은 치즈버거&amp;#34;), price: 6900),
.menu(attr: Option.Attr(id: 6, name: &amp;#34;Hamburger&amp;#34;, desc: &amp;#34;포테이토 번, 비프패티, 신선한 재료를 담은 버거&amp;#34;), price: 5400),
])
)
// 더욱 많은 메뉴 추가...
app.register(option: .order(
attr: Option.Attr(id: 6, name: &amp;#34;Order&amp;#34;, desc: &amp;#34;장바구니를 확인합니다.&amp;#34;),
actions: [
.action(attr: Option.Attr(id: 1, name: &amp;#34;Buy&amp;#34;, desc: &amp;#34;장바구니에 담은 제품을 구매합니다.&amp;#34;)),
.action(attr: Option.Attr(id: 2, name: &amp;#34;Clear&amp;#34;, desc: &amp;#34;장바구니를 비웁니다.&amp;#34;)),
])
)
app.run()&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>프로토콜을 활용해서&lt;/p></description></item><item><title>[내배캠] Swift 기초 개인 과제</title><link>https://jinyongp.dev/learn/nbcamp/3/</link><pubDate>Wed, Jul 19 04:26:26 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/3/</guid><description>&lt;p>본 캠프가 시작되고 2주차가 되었습니다.&lt;/p>
&lt;p>이번 주차에선 Swift 기초를 학습하고 간단한 연산 기능을 제공하는 CLI 계산기를 만들어 보는 과제를 수행했습니다.&lt;/p>
&lt;h3 id="requirements" class="flex items-center gap-3">Requirements &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Requirements" href="#requirements"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>1단계: 덧셈, 뺄셈, 곱셈, 나눗셈 연산 기능을 제공하는 Calculator 클래스 구현&lt;/li>
&lt;li>2단계: 1단계에서 구현한 Calculator 클래스를에 나머지 연산 기능 추가&lt;/li>
&lt;li>3단계: 각 연산을 개별 연산 클래스로 분리하고 Calculator와 연결 (feat. 단일 책임 원칙)&lt;/li>
&lt;li>4단계: 연산 클래스를 추상화한 추상 클래스 작성 (feat. 결합도, 의존성 역전 원칙)&lt;/li>
&lt;/ul>
&lt;h3 id="directory-structure" class="flex items-center gap-3">Directory Structure &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Directory Structure" href="#directory-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>plaintext
&lt;/small>
&lt;pre>&lt;code class="hljs language-plaintext">.
├── Sources/
│ ├── Operators/
│ │ ├── AddOperator.swift
│ │ ├── SubOperator.swift
│ │ ├── MulOperator.swift
│ │ ├── DivOperator.swift
│ │ ├── ModOperator.swift
│ │ └── Operator.swift
│ ├── Calculator.swift
│ └── main.swift
├── Package.swift
└── README.md&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="implementation" class="flex items-center gap-3">Implementation &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Implementation" href="#implementation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="setup" class="flex items-center gap-3">Setup &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Setup" href="#setup"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>과제에서는 단순히 연산 후 출력하는 걸 요구하고 있지만, 저는 &lt;code>readLine&lt;/code> 함수를 활용하여 사용자로부터 입력을 받아 계속 연산이 가능하도록 구현했습니다.&lt;/p>
&lt;p>실행 가능한 파일로 작성하기 위해 &lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>를 참고하여 프로젝트를 생성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ swift package init --type executable&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>위 명령어를 실행하면 현재 위치한 폴더에 &lt;code>Package.swift&lt;/code> 파일을 생성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">// swift-tools-version: 5.8
// The swift-tools-version declares the minimum version of Swift required to build this package.
import PackageDescription
let package = Package(
name: &amp;#34;calculator-cli&amp;#34;,
targets: [
// Targets are the basic building blocks of a package, defining a module or a test suite.,
// Targets can depend on other targets in this package and products from dependencies.
.executableTarget(
name: &amp;#34;calc&amp;#34;,
path: &amp;#34;Sources&amp;#34;
),
]
)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이 파일에서 프로젝트에 대한 의존성 관리 및 빌드 설정 등을 할 수 있습니다.&lt;/p>
&lt;p>&lt;code>Sources&lt;/code> 폴더에 &lt;code>main.swift&lt;/code> 또한 생성되므로 &lt;code>swift run&lt;/code> 명령어를 실행하여 프로젝트를 실행할 수 있습니다.&lt;/p>
&lt;h4 id="impl-operator-protocol" class="flex items-center gap-3">Impl Operator protocol &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl Operator protocol" href="#impl-operator-protocol"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>각 연산에 대한 클래스의 명세를 정하기 위해 &lt;code>Operator&lt;/code> 프로토콜을 작성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이를 토대로 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 클래스를 작성했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">class AddOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand {
return lhs &amp;#43; rhs
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>여기서 &lt;code>lhs + rhs&lt;/code> 에서 &lt;code>Binary operator '+' cannot be applied to two 'Operand' operands&lt;/code> 에러가 발생합니다. &lt;code>Operand&lt;/code> 타입이 덧셈 기능을 제공하는지 모르기 때문입니다.&lt;/p>
&lt;p>이를 해결하려면 &lt;code>Operand&lt;/code> 타입이 연산 가능한 타입만 올 수 있도록 제약을 걸 필요가 있습니다. &lt;code>Calculable&lt;/code> 프로토콜을 추가하여 이를 준수하는 타입만 올 수 있도록 제약을 걸었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">protocol Operator {
func operate&amp;lt;Operand: Calculable&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand
}
protocol Calculable {
static func &amp;#43;(lhs: Self, rhs: Self) -&amp;gt; Self
static func -(lhs: Self, rhs: Self) -&amp;gt; Self
static func *(lhs: Self, rhs: Self) -&amp;gt; Self
static func /(lhs: Self, rhs: Self) -&amp;gt; Self
static func %(lhs: Self, rhs: Self) -&amp;gt; Self
}
extension Int: Calculable {}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Calculable&lt;/code> 프로토콜을 추가하고 &lt;code>Int&lt;/code> 타입이 이를 준수하도록 확장(extension)했습니다.&lt;/p>
&lt;p>하지만, 위와 같은 방식으로 &lt;code>Double&lt;/code> 타입을 확장했을 때, &lt;code>Type 'Double' does not conform to protocol 'Calculable'&lt;/code> 에러가 발생합니다. 실수 타입인 &lt;code>Double&lt;/code>은 나머지 연산에 대한 동작이 정의되어 있지 않기 때문입니다. 단순히 정수 타입으로 동작하도록 확장해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">extension Double: Calculable {
static func %(lhs: Self, rhs: Self) -&amp;gt; Self {
return Double(Int(lhs) % Int(rhs))
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">class ModOperator: Operator {
func operate&amp;lt;Operand&amp;gt;(_ lhs: Operand, _ rhs: Operand) -&amp;gt; Operand where Operand : Calculable {
return lhs % rhs
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 나머지 연산에 대해서도 &lt;code>Double&lt;/code> 타입을 사용할 수 있게 되었고, &lt;code>Operator&lt;/code> 프로토콜을 준수하는 &lt;code>ModOperator&lt;/code> 클래스를 작성할 수 있게 되었습니다. (SPR. 단일 책임 원칙)&lt;/p>
&lt;h4 id="impl-calculator-class" class="flex items-center gap-3">Impl Calculator class &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl Calculator class" href="#impl-calculator-class"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>작성한 연산자를 언제든 사용할 수 있는 형태로 하여 Dictionary 형태로 외부에서 주입할 수 있도록 작성했습니다.&lt;/p>
&lt;p>&lt;code>_result&lt;/code>는 여태까지 연산한 결과를 갖고 있는 저장 프로퍼티이고, &lt;code>calculate&lt;/code> 메서드를 호출하여 연산을 수행합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">import Foundation
class Calculator&amp;lt;T: Calculable&amp;gt; {
private var _result: T
private var _operators: [String: Operator]
init(defaultValue: T? = nil, operators: [String: Operator] = [:]) {
_result = defaultValue ?? Calculator.zero()
_operators = operators
}
var result: T { _result }
var operators: [String] { Array(_operators.keys) }
@discardableResult
func calculate(_ operand: T, name: String) -&amp;gt; T {
guard let operation = _operators[name] else { return _result }
_result = operation.operate(_result, operand)
return _result
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let calculator = Calculator&amp;lt;Double&amp;gt;(
operators: [
&amp;#34;&amp;#43;&amp;#34;: AddOperator(),
&amp;#34;-&amp;#34;: SubOperator(),
&amp;#34;*&amp;#34;: MulOperator(),
&amp;#34;/&amp;#34;: DivOperator(),
&amp;#34;%&amp;#34;: ModOperator(),
]
)
calculator.calculate(10, name: &amp;#34;&amp;#43;&amp;#34;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 &lt;code>Calculator&lt;/code>는 구체적인 클래스가 아닌 추상화된 프로토콜에 의존합니다. (DIP. 의존성 역전 원칙)&lt;/p>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Trouble Shooting" href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;h4 id="1-0으로-초기화할-때-제네릭-타입으로-변환할-수-없는-문제" class="flex items-center gap-3">1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="1. 0으로 초기화할 때 제네릭 타입으로 변환할 수 없는 문제" href="#1-0%ec%9c%bc%eb%a1%9c-%ec%b4%88%ea%b8%b0%ed%99%94%ed%95%a0-%eb%95%8c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%eb%b3%80%ed%99%98%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%eb%ac%b8%ec%a0%9c"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>계산기이니 &lt;code>clear&lt;/code> 메서드를 작성했고, 이는 결과를 0으로 초기화하는 단순한 작업을 수행합니다. &lt;code>Int&lt;/code> 타입은 0으로 초기화하는 반면에 &lt;code>Double&lt;/code>은 0.0으로 초기화해야 했기 때문입니다. 제네릭 타입으로부터 이를 확인할 수 있는 방법은 없었지만, 0과 0.0 이외에 경우는 없다고 가정하고 nullish coalescing operator를 사용하여 해결했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">private static func zero() -&amp;gt; T {
return 0 as? T ?? 0.0 as! T
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;h4 id="2-첫-문자를-제외한-문자열-가져오기" class="flex items-center gap-3">2. 첫 문자를 제외한 문자열 가져오기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2. 첫 문자를 제외한 문자열 가져오기" href="#2-%ec%b2%ab-%eb%ac%b8%ec%9e%90%eb%a5%bc-%ec%a0%9c%ec%99%b8%ed%95%9c-%eb%ac%b8%ec%9e%90%ec%97%b4-%ea%b0%80%ec%a0%b8%ec%98%a4%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;p>Swift에서 문자열을 조작하기란 다른 언어에 비해 번거로운 점이 많았습니다&amp;hellip; index 또한 단순히 숫자가 아니라 String.Index를 생성하여 전달해야했고, 주어진 Index로부터 어느정도 떨어졌는지하는 방식으로 문자열을 가져와야했습니다.&lt;/p>
&lt;p>첫 문자를 제외하고 문자열을 가져오려면 다음 방식으로 가져와야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">let input: String = &amp;#34;Hello, World!&amp;#34;
input[input.index(input.startIndex, offsetBy: 1)...] // ello, World!&lt;/code>&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>input.index&lt;/code> 메서드를 호출하여 &lt;code>String.Index&lt;/code> 타입의 인덱스를 생성합니다. 이때, &lt;code>input.startIndex&lt;/code>를 기준으로 &lt;code>offsetBy&lt;/code> 만큼 떨어진 인덱스를 생성합니다.&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.apple.com/documentation/swift/partialrangefrom"
target="_blank" rel="noopener noreferrer nofollow"
>PartialRangeFrom&lt;/a
> 문법을 활용하여 해당 인덱스부터 문자열을 가져옵니다.&lt;/li>
&lt;/ol>
&lt;p>나중에 알게된 내용인데 단순하게 &lt;code>dropFirst&lt;/code> 메서드를 활용해도 됩니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>swift
&lt;/small>
&lt;pre>&lt;code class="hljs language-swift">input.dropFirst() // ello, World!&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>문자열 관련 메서드는 대개 &lt;code>Self.SubSequence&lt;/code> 타입을 반환합니다. 잘라낸 문자열을 저장하기 위헤 새로운 메모리 공간을 할당하는 것이 아닌 기존의 문자열에서 필요한 부분에 직접 접근하기 때문입니다. 따라서, 문자열로서 사용하고 싶다면 &lt;code>String&lt;/code>으로 변환해야 합니다.&lt;/p>
&lt;h3 id="retrospective" class="flex items-center gap-3">Retrospective &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Retrospective" href="#retrospective"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>객체 지향 프로그래밍의 5대 원칙 중 단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)을 적용하여 계산기를 구현해보았습니다. 원칙을 적용해보기 위해 프로토콜로 명세를 작성하고 이를 준수하는 클래스는 작성하는 작업을 진행하면서 코드의 중복을 제거하고 확장성 높은 프로그램을 작성할 수 있었습니다.&lt;/p>
&lt;p>앞으로 이외에도 적용할 수 있는 원칙을 찾아보고 적합한 디자인 패턴 및 기법을 추가로 학습하여 적용해보려고 합니다.&lt;/p></description></item><item><title>[내배캠] 첫번째 팀 프로젝트</title><link>https://jinyongp.dev/learn/nbcamp/2/</link><pubDate>Wed, Jul 19 01:27:06 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/2/</guid><description>&lt;p>사전캠프에서 학습한 Flutter를 활용하여 첫번째 팀 프로젝트를 진행했습니다.&lt;/p>
&lt;p>4일간 진행한 프로젝트로 목적은 앱 개발 전반의 과정을 익히기 위함이지만, 그보다 팀원분들과의 소통과 협업 관점에 비중으로 두고 프로젝트를 진행하였습니다.&lt;/p>
&lt;p>프로젝트의 주제는 팀과 팀원의 소개를 담은 앱을 작성하는 것으로, 각자 자신의 소개를 담은 상세 페이지를 작성하고 합치기로 결정하였습니다.
저는 상세 페이지와 더불어 메인 페이지와 각 상세 페이지에서 쓰일 댓글 관리 서비스를 맡았습니다.&lt;/p>
&lt;p>그 중에서도 댓글 관리 서비스를 어떻게 구현했는지 정리해보고자 합니다.&lt;/p>
&lt;h2 id="의존성-주입을-위해-인터페이스-적용하기" class="flex items-center gap-3">의존성 주입을 위해 인터페이스 적용하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="의존성 주입을 위해 인터페이스 적용하기" href="#%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a3%bc%ec%9e%85%ec%9d%84-%ec%9c%84%ed%95%b4-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%ec%a0%81%ec%9a%a9%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>사전캠프에서도 다뤘지만, Service 단에서 &lt;code>shared_preferences&lt;/code>를 사용하기 위해 서비스 파일 내에서 직접 불러와서 사용해주는 방식이 아니라 &lt;code>main.dart&lt;/code>에서 &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수를 주입해주는 방식으로 구현했었습니다.&lt;/p>
&lt;p>허나, 아래처럼 &lt;code>save&lt;/code> 혹은 &lt;code>load&lt;/code> 둘 다 구현해야하는 걸 강제할 수 없었습니다. 또한, &lt;code>shared_preferences&lt;/code>외에 다른 걸로 변경할 때도 번거롭습니다&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">void main() async {
WidgetsFlutterBinding.ensureInitialized();
SharedPreferences pref await SharedPreferences.getInstance();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; MemoService(
save: (String payload) async =&amp;gt; await pref.setString(&amp;#34;memo&amp;#34;, payload),
// load: () async =&amp;gt; pref.getString(&amp;#34;memo&amp;#34;), // 에러를 발생시키지 않음
),
),
],
child: const MyApp(),
));
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이를 해결하기 위해 &lt;code>IO&lt;/code> 인터페이스를 구현했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">abstract class IO {
Future&amp;lt;void&amp;gt; save(String payload);
Future&amp;lt;String?&amp;gt; load();
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>dart에서는 인터페이스를 생성하기 위해 &lt;code>abstract class&lt;/code> 키워드를 사용해야 합니다. &lt;code>IO&lt;/code> 인터페이스는 &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수에 대한 명세를 제공합니다. 이를 &lt;code>CommentService&lt;/code>에 적용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">class CommentService extends ChangeNotifier {
final Map&amp;lt;String, List&amp;lt;Comment&amp;gt;&amp;gt; _comments = {};
IO? io;
CommentService({this.io}) {
//
}
...
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이제 &lt;code>io&lt;/code> 인스턴스를 외부에서 주입해줄 수 있습니다. &lt;code>shared_preferences&lt;/code>를 사용할 예정이므로 &lt;code>SharedPreferencesIO&lt;/code> 클래스를 생성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">class SharedPreferencesIO implements IO {
late Future&amp;lt;SharedPreferences&amp;gt; pref;
SharedPreferencesIO() {
pref = SharedPreferences.getInstance();
}
@override
Future&amp;lt;String?&amp;gt; load() {
return pref.then((pref) =&amp;gt; pref.getString(&amp;#39;comments&amp;#39;));
}
@override
Future&amp;lt;void&amp;gt; save(String payload) async {
pref.then((pref) =&amp;gt; pref.setString(&amp;#39;comments&amp;#39;, payload));
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">void main() async {
WidgetsFlutterBinding.ensureInitialized();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; CommentService(
io: SharedPreferencesIO(),
),
),
],
child: MainApp(),
));
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>구현한 &lt;code>SharedPreferencesIO&lt;/code> 클래스를 &lt;code>main.dart&lt;/code>에서 &lt;code>CommentService&lt;/code>에 주입해줍니다.&lt;/p>
&lt;p>이로써, &lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 모두 구현해야 함을 강제할 수 있게 되었고, &lt;code>IO&lt;/code> 인터페이스를 상속하는 클래스를 여러 개 추가하여 상황에 따라 교체할 수 있어 확장성을 높였습니다.&lt;/p>
&lt;h2 id="데이터-송수신-로직-추상화하기" class="flex items-center gap-3">데이터 송수신 로직 추상화하기 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="데이터 송수신 로직 추상화하기" href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%86%a1%ec%88%98%ec%8b%a0-%eb%a1%9c%ec%a7%81-%ec%b6%94%ec%83%81%ed%99%94%ed%95%98%ea%b8%b0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;code>CommentService&lt;/code>에서 내부적으로 데이터를 저장하고 불러오는 &lt;code>_save&lt;/code>와 &lt;code>_load&lt;/code> 함수가 있었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">Future&amp;lt;void&amp;gt; _save() {
if (save == null) return Future.value();
String payload = jsonEncode(_memos.map((m) =&amp;gt; m.toJson()).toList());
return save!(payload);
}
Future&amp;lt;void&amp;gt; _load() async {
if (load == null) return;
String? payload = await load!();
if (payload == null) return;
_memos.clear();
_memos.addAll(jsonDecode(payload).map((e) =&amp;gt; Memo.fromJson(e)));
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>여기서 데이터를 String 타입의 payload로 만들거나, 반대로 payload를 데이터로 변환하는 작업을 수행했었습니다.
언뜻보면 null 체크를 하고 종료하는 부분이나 payload를 처리하는 부분은 중복된 부분이기에 별도의 함수로 분리하고 싶었습니다.&lt;/p>
&lt;p>그래서 &lt;code>DataHandler&lt;/code> 추상 클래스르 작성하였습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">mixin DataHandler {
IO? io;
Future&amp;lt;void&amp;gt; import(String payload);
Future&amp;lt;String&amp;gt; export();
Future&amp;lt;void&amp;gt; save() async {
if (io == null) return Future.value();
var payload = await export();
io?.save(payload);
}
Future&amp;lt;void&amp;gt; load() async {
if (io == null) return Future.value();
var payload = await io!.load();
if (payload == null) return;
import(payload);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>dart에서 mixin을 활용하여 추상 클래스를 작성할 수 있습니다.
&lt;code>save&lt;/code>와 &lt;code>load&lt;/code> 함수는 이미 구현되어 있어 동일한 작업을 수행하지만, &lt;code>import&lt;/code>와 &lt;code>export&lt;/code> 함수는 재정의가 필요합니다. 이를 &lt;code>CommentService&lt;/code>에 적용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">class UseState {
final List&amp;lt;Comment&amp;gt; comments;
final void Function(List&amp;lt;Comment&amp;gt; Function()) setState;
UseState({
required this.comments,
required this.setState,
});
}
class CommentService extends ChangeNotifier with DataHandler {
final Map&amp;lt;String, List&amp;lt;Comment&amp;gt;&amp;gt; _comments = {};
CommentService({IO? io}) {
this.io = io;
try {
load().then((_) =&amp;gt; notifyListeners());
} catch (error) {
// ignore
}
}
UseState useState(String name) {
return UseState(
comments: List.unmodifiable(_comments[name] ?? []),
setState: (newComments) {
_comments[name] = newComments();
notifyListeners();
save();
},
);
}
@override
Future&amp;lt;void&amp;gt; import(String payload) async {
jsonDecode(payload).forEach((key, values) {
if (values is! List) return;
_comments[key] = values.map((value) =&amp;gt; Comment.fromJson(value)).toList();
});
}
@override
Future&amp;lt;String&amp;gt; export() async {
return jsonEncode(
_comments.map(
(key, values) =&amp;gt; MapEntry(
key,
values.map((comment) =&amp;gt; comment.toJson()).toList(),
),
),
);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>mixin&lt;/code>을 상속하기 위해선 &lt;code>with&lt;/code> 키워드를 사용해야 합니다. &lt;code>DataHandler&lt;/code>를 상속하면서 &lt;code>CommentService&lt;/code>에서 구현해야 하는 함수들을 재정의합니다.
&lt;code>import&lt;/code>와 &lt;code>export&lt;/code> 함수는 단순히 JSON 형태의 stringify와 parse 작업을 수행합니다. 이로써 상속을 통해 중복 코드를 제거하고 함수의 역할을 분리할 수 있었습니다.&lt;/p></description></item><item><title>[내배캠] 사전캠프</title><link>https://jinyongp.dev/learn/nbcamp/1/</link><pubDate>Tue, Jun 27 11:16:56 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/learn/nbcamp/1/</guid><description>&lt;h2 id="table-of-contents" class="flex items-center gap-3">Table of Contents &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Table of Contents" href="#table-of-contents"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="#2023%eb%85%84-06%ec%9b%94-27%ec%9d%bc"
>2023년 06월 27일&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="#2023%eb%85%84-06%ec%9b%94-28%ec%9d%bc"
>2023년 06월 28일&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="#2023%eb%85%84-06%ec%9b%94-29%ec%9d%bc"
>2023년 06월 29일&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="#2023%eb%85%84-06%ec%9b%94-30%ec%9d%bc"
>2023년 06월 30일&lt;/a
>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2023년-06월-27일" class="flex items-center gap-3">2023년 06월 27일 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2023년 06월 27일" href="#2023%eb%85%84-06%ec%9b%94-27%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;a
class="underline-lsre"
href="https://nbcamp-android-ios-unity.oopy.io/0dc0a70c-49ca-499c-b2df-965a2828cca6"
target="_blank" rel="noopener noreferrer nofollow"
>내일배움캠프 iOS 과정&lt;/a
>을 본격적으로 시작하기에 앞서 앱 개발 전반의 이해를 위해 Dart와 Flutter를 학습했습니다.&lt;/p>
&lt;p>지원을 거의 막바지에 하게 되었는데 사전캠프가 이미 진행 도중이었습니다. 다른 분들보다 진도가 느릴까 걱정되었지만, 본 캠프는 9 to 9(&amp;hellip;) 과정이니만큼 사전캠프도 바쁘게 해보고자 최대한 빨리 나가고자 했습니다.&lt;/p>
&lt;p>강의는 스파르타코딩클럽의 &lt;a
class="underline-lsre"
href="https://spartacodingclub.kr/nb/app"
target="_blank" rel="noopener noreferrer nofollow"
>[왕초보] 플러터(Flutter)로 시작하는 앱개발 종합반&lt;/a
>으로 진행했습니다.&lt;/p>
&lt;h3 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Flutter는 크로스 플랫폼 개발을 위한 프레임워크로 Dart라는 언어로 작성합니다. 동일한 역할을 수행하는 React Native와 비교했을 때 등장 시기는 늦지만 등장부터 빠르게 치고 올라가 Github Star 수는 이미 압도적이라 할 수 있습니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="Star History Chart" src="https://api.star-history.com/svg?repos=flutter/flutter,facebook/react-native&amp;amp;type=Date" />
&lt;a
class="underline-lsre"
href="https://star-history.com/#flutter/flutter&amp;amp;facebook/react-native"
target="_blank" rel="noopener noreferrer nofollow"
>출처: Github Star History | Flutter vs. React Native&lt;/a
>&lt;/p>
&lt;p>공식 문서 정리에 유튜브 채널까지&amp;hellip;&lt;br>
심지어 성능 또한 네이티브 못지않게 빠르다고 하니 Flutter를 써보지 않을 이유가 없을 듯 합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://api.flutter.dev/"
target="_blank" rel="noopener noreferrer nofollow"
>Flutter Docs&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://www.youtube.com/@flutterdev/videos"
target="_blank" rel="noopener noreferrer nofollow"
>Youtube Flutter Channel&lt;/a
>&lt;/li>
&lt;/ul>
&lt;h3 id="installation" class="flex items-center gap-3">Installation &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Installation" href="#installation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>brew로 flutter를 설치해줍시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ brew install --cask flutter&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>설치 후 &lt;code>flutter&lt;/code> 명령어를 사용할 수 있습니다. &lt;code>doctor&lt;/code> 명령어로 정상적으로 설치됐는지 확인할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ flutter doctor -v
Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel stable, 3.10.5, on macOS 13.4.1 22F82 darwin-arm64, locale en-KR)
[!] Android toolchain - develop for Android devices (Android SDK version 34.0.0)
✗ cmdline-tools component is missing
Run `path/to/sdkmanager --install &amp;#34;cmdline-tools;latest&amp;#34;`
See https://developer.android.com/studio/command-line for more details.
✗ Android license status unknown.
Run `flutter doctor --android-licenses` to accept the SDK licenses.
See https://flutter.dev/docs/get-started/install/macos#android-setup for more details.
[✓] Xcode - develop for iOS and macOS (Xcode 14.3.1)
[✓] Chrome - develop for the web
[✓] Android Studio (version 2022.2)
[✓] VS Code (version 1.79.2)
[✓] Connected device (2 available)
[✓] Network resources
! Doctor found issues in 1 category.&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>문제없이 실행하기 위해 필요한 도구 중 없는 것을 알려줍니다. 구글에서 제작한 flutter에서 vscode 설치 여부를 확인하고 있는게 좀 당황스럽긴 하지만 그만큼 vscode를 대신할만한 에디터가 없다는거겠죠.&lt;/p>
&lt;p>Android에서 문제가 발생했지만 노트북 용량이 부족하니 그냥 넘어가줍니다.&lt;/p>
&lt;p>VSCode에서는 다음 두 가지 Extension을 설치합니다. Flutter extension을 설치하면 dart는 알아서 설치됩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code"
target="_blank" rel="noopener noreferrer nofollow"
>Dart-Code.dart-code&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter"
target="_blank" rel="noopener noreferrer nofollow"
>Dart-Code.flutter&lt;/a
>&lt;/li>
&lt;/ul>
&lt;p>Command Palette를 열고 &lt;code>Dart: Use Recommended Settings&lt;/code> 명령어를 수행합니다. 추천하는 다트 설정을 vscode 전역 설정에 추가되는데 전 그게 싫어서 Workspace에 &lt;code>.vscode/settings.json&lt;/code> 생성 후 옮겼습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ flutter create hello_flutter --empty
$ cd hello_flutter &amp;amp;&amp;amp; code .&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>위 명령어로 프로젝트를 생성한 뒤 flutter 프로젝트를 시작합니다.&lt;/p>
&lt;h3 id="practice" class="flex items-center gap-3">Practice &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Practice" href="#practice"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Flutter는 Widget이라고 불리는 가장 작은 단위의 모듈이 겹겹이 쌓여 전체 프로젝트를 구성합니다. 이를 위젯 트리라 부릅니다.&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets"
target="_blank" rel="noopener noreferrer nofollow"
>Widget Catalog&lt;/a
>에서 다양한 위젯을 제공합니다. &lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets/cupertino"
target="_blank" rel="noopener noreferrer nofollow"
>iOS 스타일의 Cupertino 위젯&lt;/a
>과 &lt;a
class="underline-lsre"
href="https://docs.flutter.dev/ui/widgets/material"
target="_blank" rel="noopener noreferrer nofollow"
>Android 스타일의 위젯&lt;/a
>을 활용하면 쉽게 네이티브 스타일을 구현할 수 있습니다.&lt;/p>
&lt;p>Command Palette에서 &lt;code>Flutter: Launch Emulator&lt;/code> 명령을 실행하여 에뮬레이터의 실행을 마친 뒤, &lt;code>lib/main.dart&lt;/code> 파일을 열고 &lt;code>main&lt;/code> 함수 상단에 &lt;code>Run&lt;/code>을 클릭하여 프로젝트를 실행합니다.&lt;/p>
&lt;p>첫 주차에선 다양한 위젯을 활용하여 로그인 페이지와 간단한 영화 리스트 페이지를 작성했습니다.&lt;/p>
&lt;h4 id="simple-login-page" class="flex items-center gap-3">Simple Login Page &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Simple Login Page" href="#simple-login-page"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=9b26d4ef17f9b7df5f125ccd9f3b976a&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;ul>
&lt;li>사용자가 입력하기 위해 입력폼을 클릭했을 때 올라오는 키보드에 입력폼이 가려지는 문제가 있습니다. &lt;code>ListView&lt;/code>와 같이 scrollable한 위젯에선 발생하지 않는 문제지만 스크롤이 없을 때 발생합니다. 스크롤이 없는 단일 페이지에서 해당 문제가 발생할 시 &lt;code>SingleChildScrollView&lt;/code> 위젯을 사용해야 합니다.&lt;/li>
&lt;/ul>
&lt;h4 id="simple-movie-list" class="flex items-center gap-3">Simple Movie List &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Simple Movie List" href="#simple-movie-list"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h4>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=a92d7ac36eae072383b19b8438df0a15&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;ul>
&lt;li>&lt;code>ListView.builder&lt;/code> 위젯으로 리스트를 그릴 수 있습니다. &lt;code>ListView&lt;/code>를 &lt;code>Column&lt;/code>가 내부에서 사용할 때 &lt;code>Vertical viewport was given unbounded height.&lt;/code> 에러가 발생할 수 있는데, &lt;code>ListView&lt;/code>가 항상 최대 공간을 차지하려는 성질이 있어 높이가 무한대로 계산되는 문제가 발생하기 때문입니다. &lt;code>Expanded&lt;/code> 위젯으로 감싸서 문제를 해결할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;h2 id="2023년-06월-28일" class="flex items-center gap-3">2023년 06월 28일 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2023년 06월 28일" href="#2023%eb%85%84-06%ec%9b%94-28%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>오늘은 간단하게 StatelessWidget과 StatefulWidget 그리고 Navigation에 대해 학습했습니다. (이번이 2주차 내용입니다.)&lt;/p>
&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=88bf678d41cdd472009b50585f45304b&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;h3 id="statelesswidget-vs-statefulwidget" class="flex items-center gap-3">StatelessWidget vs. StatefulWidget &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="StatelessWidget vs. StatefulWidget" href="#statelesswidget-vs-statefulwidget"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>StatelessWidget: 상태가 없는 위젯으로 처음에 한번만 &lt;code>build&lt;/code>를 호출합니다.&lt;/li>
&lt;li>StatefulWidget: 상태를 가진 위젯으로 상태가 변경될 때마다 &lt;code>build&lt;/code> 메서드를 호출하여 다시 그립니다.&lt;/li>
&lt;/ul>
&lt;p>위 두 위젯은 보통 상속하여 &lt;code>build&lt;/code> 메서드를 override하는 방식으로 사용합니다. StatefulWidget은 State를 변경하는 클래스가 별도로 필요합니다.&lt;/p>
&lt;h3 id="navigation" class="flex items-center gap-3">Navigation &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Navigation" href="#navigation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Navigation은 Route라고 불리는 페이지를 전환하는 것을 의미하고 &lt;code>Navigator&lt;/code> 위젯으로 수행합니다. &lt;code>push&lt;/code>로 페이지를 이동하고 &lt;code>pop&lt;/code>으로 이전 페이지로 이동할 수 있습니다.&lt;/p>
&lt;h3 id="당근마켓daangn-앱-클론" class="flex items-center gap-3">당근마켓(Daangn) 앱 클론 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="당근마켓(Daangn) 앱 클론" href="#%eb%8b%b9%ea%b7%bc%eb%a7%88%ec%bc%93daangn-%ec%95%b1-%ed%81%b4%eb%a1%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=2eef886fac601cbee5bceebdd320a255&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>Stateful한 Feed 위젯을 구현해보았고, 파일을 분리하여 작성해보았습니다. (dartpad는 파일 분리를 지원하지 않아 main.dart에 전부 있습니다&amp;hellip;. &lt;a
class="underline-lsre"
href="https://github.com/dart-lang/dart-pad/issues/2149"
target="_blank" rel="noopener noreferrer nofollow"
>22년도에 올라온 이슈인데...&lt;/a
>)&lt;/p>
&lt;p>여기서 놀랐던 점은 &lt;code>ListView.builder&lt;/code>에 &lt;code>itemCount&lt;/code>를 명시하지 않으면 리스트 요소를 무한히 만들어낸다는 점입니다. 예전에 Recycle Scrolling을 구현하면서 겪은 제한으로는 적어도 요소의 최소 크기가 결정되어 있어야 하고, 요소의 개수를 어느정도 알고 있어야 했는데 그런거 없이 무한정 그려낼 수 있다는 점이 놀라웠습니다.&lt;/p>
&lt;p>&lt;a
class="underline-lsre"
href="https://docs.flutter.dev/get-started/flutter-for/android-devs#how-do-i-update-listviews-dynamically"
target="_blank" rel="noopener noreferrer nofollow"
>해당 문서&lt;/a
>에서 &lt;code>ListView&lt;/code> 자체가 내부적으로 요소를 재활용(recycle)하는 동작으로 수행됨을 알 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>The recommended, efficient, and effective way to build a list uses a ListView.Builder. This method is great when you have a dynamic List or a List with very large amounts of data. This is essentially the equivalent of RecyclerView on Android, which automatically recycles list elements for you&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;h3 id="샤잠shazam-앱-클론" class="flex items-center gap-3">샤잠(Shazam) 앱 클론 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="샤잠(Shazam) 앱 클론" href="#%ec%83%a4%ec%9e%a0shazam-%ec%95%b1-%ed%81%b4%eb%a1%a0"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=252f87e790119799f8be13d1c7875a6d&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>사실 과제는 페이지 세 개 중 하나를 택해 수행하는 건데 그까이꺼 전부 클론해봤습니다. 리팩토링이 필요한 부분이 굉장히 많아보이긴 하지만&amp;hellip; 항상 언젠가 한다는 마음가짐으로&amp;hellip;&lt;/p>
&lt;p>탭 생성 및 이동 방법에 대해서 알게 되었고, 많고 많은 삽질을 하며 스크롤 요소를 어디에 어떻게 배치해야하는지 요령을 습득했습니다.&lt;/p>
&lt;p>가장 난해했던 부분&amp;hellip; overflow&amp;hellip; Scrollable하지 않은 페이지에서 요소가 화면을 벗어나면 &lt;code>A ListView A RenderFlex overflowed by &amp;lt;number&amp;gt; pixels on the bottom.&lt;/code> 에러가 발생합니다. Scrollable하게 만들어주기 위해 &lt;code>SingleChildScrollView&lt;/code>를 이용하거나 &lt;code>ListView&lt;/code>로 감싸줘야하고, &lt;code>Expanded&lt;/code>로 감싸야합니다.&lt;/p>
&lt;hr>
&lt;h2 id="2023년-06월-29일" class="flex items-center gap-3">2023년 06월 29일 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2023년 06월 29일" href="#2023%eb%85%84-06%ec%9b%94-29%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>오늘은 심플한 메모앱을 만들면서 CRUD 기능 구현과 함께 상태 관리 패키지인 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/provider"
target="_blank" rel="noopener noreferrer nofollow"
>Provider&lt;/a
> 그리고 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/shared_preferences"
target="_blank" rel="noopener noreferrer nofollow"
>shared_preferences&lt;/a
>를 이용하여 데이터를 기기에 저장하여 앱을 종료 후 다시 열어도 정보가 유지되도록 기능을 구현했습니다.&lt;/p>
&lt;p>flutter의 패키지는 &lt;a
class="underline-lsre"
href="https://pub.dev/"
target="_blank" rel="noopener noreferrer nofollow"
>pub.dev&lt;/a
>에서 조회할 수 있습니다. 패키지를 설치하기 위해서도 &lt;code>flutter pub&lt;/code> 명령어를 사용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>bash
&lt;/small>
&lt;pre>&lt;code class="hljs language-bash">$ flutter pub add provider shared_preferences&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="provider" class="flex items-center gap-3">Provider &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Provider" href="#provider"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Provider는 flutter의 상태 관리 패키지로 전역에서 데이터를 쥐고 제어할 수 있는 서비스를 관리해줍니다. &lt;code>Memo&lt;/code> 클래스와 함께 &lt;code>MemoService&lt;/code>를 추가해보았습니다. &lt;code>MemoService&lt;/code>는 메모 목록을 관리하고 CRUD 기능을 제공합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// lib/services/memo.dart
class Memo {
Memo({ required this.content });
String content;
}
class MemoService extends ChangeNotifier {
List&amp;lt;Memo&amp;gt; memos = [];
void create(String content) { ... }
void update(int index, String content) { ... }
void delete(int index) { ... }
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>main.dart&lt;/code>의 &lt;code>runApp&lt;/code>에 Provider를 통해 &lt;code>MemoService&lt;/code>를 등록해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// lib/main.dart
void main() {
runApp(
MultipleProvider(
providers: [
ChangeNotifierProvider(create: (_) =&amp;gt; MemoService()),
],
child: const MyApp(),
),
);
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이제 위젯트리 전체를 &lt;code>Consumer&amp;lt;MemoService&amp;gt;&lt;/code>로 감싸주면 &lt;code>MemoService&lt;/code> 내에서 &lt;code>notifyListeners()&lt;/code>가 호출될 때마다 전체 화면을 다시 그립니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">Widget build(BuildContext context) {
return Consumer&amp;lt;MemoService&amp;gt;(builder: (context, memoService, child) {
return Scaffold(
...
)
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>Consumer&lt;/code>는 전체 화면을 다시 그리지만, 화면 리렌더링 없이 &lt;code>MemoService&lt;/code>의 인스턴스를 가져오고 싶다면, &lt;code>context.read&amp;lt;MemoService&amp;gt;()&lt;/code>를 통해 가져올 수 있습니다.&lt;/p>
&lt;h3 id="shared_preferences" class="flex items-center gap-3">shared_preferences &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="shared_preferences" href="#shared_preferences"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>&lt;code>SharedPreferences&lt;/code>는 앱을 껐다 켜도 데이터를 유지할 수 있는 기능을 제공합니다. 다만 &lt;code>SharedPreferences&lt;/code>와 같이 데이터를 유지해줄 수 있는 방법은 다양하므로 언제든 교체할 수 있도록 외부에서 주입해주는 방식으로 구현했습니다.&lt;/p>
&lt;p>&lt;code>MemoService&lt;/code>에 데이터를 저장하고 불러오는 함수를 매개변수를 받을 수 있게끔 추가합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">class MemoService extends ChangeNotifier {
final List&amp;lt;Memo&amp;gt; _memos = [];
final Future&amp;lt;void&amp;gt; Function(String payload)? save;
final Future&amp;lt;String?&amp;gt; Function()? load;
MemoService({
this.save,
this.load,
}) {
...
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>main.dart&lt;/code>에서 &lt;code>SharedPreferences&lt;/code>의 인스턴스를 생성한 후 데이터를 저장하고 불러오는 함수를 전달합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">void main() async {
WidgetsFlutterBinding.ensureInitialized();
SharedPreferences pref = await SharedPreferences.getInstance();
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; MemoService(
save: (String payload) async =&amp;gt; await pref.setString(&amp;#34;memo&amp;#34;, payload),
load: () async =&amp;gt; pref.getString(&amp;#34;memo&amp;#34;),
),
),
],
child: const MyApp(),
));
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>MemoService&lt;/code>에서 이를 적절하게 저장하고 불러올 때 호출합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">String payload = jsonEncode(_memos.map((m) =&amp;gt; m.toJson()).toList());
return save!(payload);&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">String? payload = await load!();
if (payload == null) return;
_memos.clear();
_memos.addAll(jsonDecode(payload).map((e) =&amp;gt; Memo.fromJson(e)));&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이로써 데이터를 항시 유지할 수 있고, 언제든 &lt;code>main.dart&lt;/code>만 수정하여 데이터 유지 방식을 변경할 수 있습니다.&lt;/p>
&lt;h3 id="my-memo" class="flex items-center gap-3">My Memo &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="My Memo" href="#my-memo"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=beb656ed3cd6059afac59277a1d6ade8&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>구현한 앱은 다음의 기능을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>하단 &lt;code>+&lt;/code> 아이콘을 눌러 새로운 메모를 생성할 수 있습니다. (메모 작성 페이지로 이동합니다.)&lt;/li>
&lt;li>아무런 내용을 작성하지 않는다면 메모가 추가되지 않습니다.&lt;/li>
&lt;li>내용을 추가하고 뒤로 가기 버튼을 누르면 새로운 메모가 추가됩니다.&lt;/li>
&lt;li>메모를 클릭하여 내용을 수정할 수 있습니다.&lt;/li>
&lt;li>메모를 클릭하고 쓰레기통 아이콘을 눌러 삭제할 수 있습니다.&lt;/li>
&lt;li>변경일 내림차순으로 정렬됩니다. (가장 최근에 변경된 메모가 상단에 위치합니다.)&lt;/li>
&lt;li>고정한 메모를 상단으로 올립니다.&lt;/li>
&lt;li>메모 목록은 앱을 종료 후 재시작해도 유지됩니다.&lt;/li>
&lt;/ul>
&lt;h3 id="trouble-shooting" class="flex items-center gap-3">Trouble Shooting &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Trouble Shooting" href="#trouble-shooting"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://stackoverflow.com/a/69671156"
target="_blank" rel="noopener noreferrer nofollow"
>shared_preferences 때문에 프로젝트가 실행되지 않을 때 대처법&lt;/a
>&lt;/li>
&lt;li>&lt;code>SharedPreferences&lt;/code>의 인스턴스 변수를 전역에서 관리하는 것이 아닌, 데이터를 저장하고 불러오는 함수를 &lt;code>MemoService&lt;/code>에 주입하는 방식으로 리팩토링했습니다. (강의에선 아마 콜백함수에 대한 내용을 학습하지 않았으므로 전역에서 관리하도록 구현하신 것 같습니다.)&lt;/li>
&lt;li>웹에서는 &lt;code>SharedPreferences&lt;/code>의 인스턴스를 생성할 수 없습니다. &lt;code>shared_preferences_web&lt;/code>이 포함되어 있다는데 왜 동작을 안 하는지는 모르겠네요&amp;hellip; &lt;code>import 'package:flutter/foundation.dart' show kIsWeb;&lt;/code>를 불러와서 웹 환경이 아닐 때만 인스턴스를 생성하도록 수정했습니다.&lt;/li>
&lt;li>날짜 포맷팅을 위해 &lt;code>import 'package:intl/intl.dart';&lt;/code> 라이브러리를 추가로 활용했습니다.&lt;/li>
&lt;/ul>
&lt;p>전반으로 리액트나 뷰와 비슷한 느낌이라 기능 구현은 별로 어렵진 않았어서 다트 언어에 더 익숙해질 수 있는 시간이었네요.&lt;/p>
&lt;hr>
&lt;h2 id="2023년-06월-30일" class="flex items-center gap-3">2023년 06월 30일 &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="2023년 06월 30일" href="#2023%eb%85%84-06%ec%9b%94-30%ec%9d%bc"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>5주차 강의는 HTTP API 요청 방법을 익혔습니다. 다음주는 광고 붙이는건데&amp;hellip; 이번이 마지막일 듯 하네요.&lt;/p>
&lt;h3 id="requesting-network-data" class="flex items-center gap-3">Requesting Network Data &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Requesting Network Data" href="#requesting-network-data"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>HttpClient로는 &lt;a
class="underline-lsre"
href="https://pub.dev/packages/dio"
target="_blank" rel="noopener noreferrer nofollow"
>dio&lt;/a
> 패키지를 활용했습니다. &lt;br>
책 정보를 불러올 수 있는 Google API를 활용하여 Watcha Pedia 서비스를 구현했습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// main.dart
void main() async {
late SharedPreferences pref;
if (!kIsWeb) {
WidgetsFlutterBinding.ensureInitialized();
pref = await SharedPreferences.getInstance();
}
runApp(MultiProvider(
providers: [
ChangeNotifierProvider(
create: (_) =&amp;gt; BookService(
get: &amp;lt;T&amp;gt;(String query) async {
String url =
&amp;#39;https://www.googleapis.com/books/v1/volumes?q=$query&amp;amp;startIndex=0&amp;amp;maxResults=40&amp;#39;;
Response res = await Dio().get(url);
if (res.statusCode != 200) {
throw Exception(&amp;#39;http.get error: statusCode= ${res.statusCode}&amp;#39;);
}
return res.data[&amp;#39;items&amp;#39;];
},
save: (String payload) =&amp;gt; pref.setString(&amp;#39;likedBooks&amp;#39;, payload),
load: () =&amp;gt; pref.getString(&amp;#39;likedBooks&amp;#39;),
),
),
],
child: const MainApp(),
));
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// services/book.dart
final Future&amp;lt;T&amp;gt; Function&amp;lt;T&amp;gt;(String url) get;
final FutureOr Function(String payload)? save;
final FutureOr Function()? load;
BookService({required this.get, this.save, this.load}) {
_load().then((_) =&amp;gt; notifyListeners());
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>BookService&lt;/code> 클래스에서 책 정보를 가져오는 함수(&lt;code>get&lt;/code>)와 정보를 저장(&lt;code>save&lt;/code>)하고 불러오는(&lt;code>load&lt;/code>) 함수를 주입할 수 있도록 구현했습니다.&lt;/p>
&lt;h3 id="webview-page" class="flex items-center gap-3">WebView Page &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="WebView Page" href="#webview-page"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>앱 상에서 외부 웹 링크 페이지를 띄우기 위해선 &lt;code>webview_flutter&lt;/code> 패키지를 사용해야 합니다. &lt;br>
책 목록에서 책을 클릭하면 해당 책의 정보를 보여주는 페이지를 띄웁니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// screens/webview.dart
class WebViewScreen extends StatelessWidget {
WebViewScreen({
super.key,
required this.url,
});
String url;
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
backgroundColor: Colors.grey,
title: Text(url),
),
body: WebView(initialUrl: url),
);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>dart
&lt;/small>
&lt;pre>&lt;code class="hljs language-dart">// widgets/book_tile.dart
onTap: () {
Navigator.push(
context,
MaterialPageRoute(
builder: (_) =&amp;gt; WebViewScreen(
url: book.previewLink.replaceFirst(&amp;#39;http:&amp;#39;, &amp;#39;https:&amp;#39;)),
),
);
},&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="watcha-pedia" class="flex items-center gap-3">Watcha Pedia &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Watcha Pedia" href="#watcha-pedia"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;iframe src="https://dartpad.dev/embed-flutter.html?id=7a51cd7685929c94d82ca0b707f69516&amp;split=60&amp;theme=dark" style="width:100%; height: 500px;">&lt;/iframe>
&lt;p>| Dartpad에서 &lt;code>Image.network&lt;/code> 불러오기가 안 되는 문제가 있습니다. &lt;br>
| &lt;code>dio&lt;/code>가 동작하지 않아, &lt;code>http&lt;/code> 모듈로 대체했습니다. &lt;br>
| webview가 동작하지 않습니다.&lt;/p>
&lt;h3 id="project-structure" class="flex items-center gap-3">Project Structure &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Project Structure" href="#project-structure"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Dartpad에서는 확인할 수 없지만, 프로젝트 구조에 대해 고민해보았습니다.&lt;/p>
&lt;ul>
&lt;li>screens: 화면&lt;/li>
&lt;li>models: 데이터 모델 (자료구조)&lt;/li>
&lt;li>services: 서비스 (비즈니스 로직)&lt;/li>
&lt;li>widgets: 위젯 (컴포넌트)&lt;/li>
&lt;/ul>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>txt
&lt;/small>
&lt;pre>&lt;code class="hljs language-txt">lib/
├── models/
│ └── book.dart
├── screens/
│ ├── home.dart
│ ├── like.dart
│ ├── search.dart
│ └── webview.dart
├── services/
│ └── book.dart
├── widgets/
│ └── book_tile.dart
└── main.dart&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>[내일배움캠프] iOS 과정 부트캠프 시리즈 (7기)</title><link>https://jinyongp.dev/series/nbcamp/1/</link><pubDate>Mon, Jun 26 14:38:22 2023 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/nbcamp/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>2023년 7월 10일부터 11월 17일까지 4개월간 진행되는 &lt;a
class="underline-lsre"
href="https://nbcamp.spartacodingclub.kr/app"
target="_blank" rel="noopener noreferrer nofollow"
>내일배움캠프 iOS 과정&lt;/a
>(7기) 부트캠프에 합류하게 되었습니다. 본 시리즈에서는 iOS 과정 부트캠프에서 배우고 경험한 내용을 정리해보려고 합니다.&lt;/p>
&lt;h2 id="about-me" class="flex items-center gap-3">About Me &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="About Me" href="#about-me"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>코드스테이츠 웹 개발 부트캠프를 수료하고 1년 동안 웹 개발자로서 Vue 프레임워크를 활용한 웹/웹앱 서비스를 개발했습니다. 웹페이지를 AOS/iOS 모바일 환경에서 제공해야 했으며 여러 디바이스에서 구동되더라도 동일한 경험을 줄 수 있도록 반응형 스타일을 적용하거나 앱 환경에서도 최적의 성능을 제공하기 위해 다양한 최적화 기법을 적용해보면서 최대한 앱 환경과 비슷하게 구현하기 위해 노력했습니다.&lt;/p>
&lt;p>그 과정에서 최적의 성능과 유려한 UI/UX를 가진 네이티브 앱 개발에 관심을 가지게 되었습니다. 퇴사 이후 웹 말고 다른 분야를 경험해보고 싶었던 저는 운 좋게도 iOS 부트캠프 과정에 합류할 수 있게 되었습니다. 과거 웹 개발 부트캠프를 수료하며 겪은 경험과 고민, 고뇌, 후회를 발판 삼아 이번 부트캠프에서는 최대한 많이 배우고 경험해보기로 했습니다.&lt;/p>
&lt;h2 id="goals" class="flex items-center gap-3">Goals &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Goals" href="#goals"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>내일배움캠프 부트캠프 iOS 과정에서는 Swift 문법 관련 프로젝트 혹은 실전 앱 개발 프로젝트 등 다양한 개인 · 팀 프로젝트를 수행하게 됩니다. 매 프로젝트마다 임의로 편성되는 팀과 함께 진행하게 되는데, 저는 이번 기회에 모든 팀에서 팀장 역할을 수행해보고자 했습니다. 팀원의 의견을 모아 팀 규칙 및 일정을 결정하고, 프로젝트 및 일정을 관리하고, 팀원 개개인의 역량을 파악하고 예측하여 각 팀원의 학업 성취도에 맞게 작업을 적절히 분배하는 등 팀을 이끄는데 겪을 어려움을 경험해보고 싶었습니다. 리더 역할을 수행하면서 팀원과의 소통을 적극적으로 해보고 팀원 개개인의 역량을 고려하여 프로젝트를 성공적으로 마치고 팀원 모두의 성장을 도모하는 것이 목표입니다.&lt;/p>
&lt;h2 id="how-to-study" class="flex items-center gap-3">How to Study &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="How to Study" href="#how-to-study"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>부트캠프는 자기 주도 학습을 원칙으로 하는만큼 빠른 성장을 위해서는 자신만의 학습 방법과 함께 좋은 레퍼런스를 가지고 있어야 합니다. 지난 부트캠프를 수료하며 이러한 부분에 대해 부족함을 많이 느꼈었고, 나를 빠르게 성장시켜줄 수 있는 레퍼런스가 뭐가 있을까 고민하게 되었습니다. 그러던 중 우연히 지인으로부터 인프런의 &lt;a
class="underline-lsre"
href="https://www.inflearn.com/course/%ec%8a%a4%ec%9c%84%ed%94%84%ed%8a%b8-%eb%ac%b8%eb%b2%95-%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%8a%a4%ec%bf%a8"
target="_blank" rel="noopener noreferrer nofollow"
>앨런 Swift 문법 마스터 스쿨&lt;/a
> 강의에 대해 알게 되었습니다. 단순히 문법만 다루는 강의로 가격이 꽤 비싸긴 했지만, 기본을 단단히 다지기 위해 필요한 비용과 시간은 값에 상관없이 충분히 할애할 수 있었으므로 바로 23기 부트캠프에 참여했습니다. 해당 과정은 구매한 강의와 별개로 매주 실시간 세션을 통해 복습을 진행하며 Swift 문법을 시작적 자료와 함께 메모리 관점에서 아주 자세하게 설명해주는 식으로 기본에 충실한 내용을 담고 있어서 매우 만족스러웠습니다. 이를 통해 Swift 문법에 있어 아주 탄탄한 기본기와 깊은 이해를 가지고 부트캠프에서 제공하는 과제와 프로젝트에 적용해보려고 합니다.&lt;/p>
&lt;p>개발을 학습하는데 있어 하드 스킬도 못지 않게 중요하지만, 제가 생각하는 부트캠프에서 충분히 익혀야할 역량은 소프트 스킬이라고 봅니다. 다양한 개발자와 함께 학습하거나 협업하는 과정에서 겪을 수 있는 사람과 사람 사이의 문제를 소통을 통해 어떻게 슬기롭게 해결할 수 있을지 고민해보고 직접 부딪히며 경험해보는 것이 부트캠프에 참여해서 가져야할 가장 큰 목표라고 생각합니다. 그런 이유로 저는 항상 팀원과 소통하기 위해 노력하며 하드 스킬 못지 않게 뛰어난 소프트 스킬을 얻고자 합니다.&lt;/p></description></item><item><title>Refactoring for Performance (Canvas API)</title><link>https://jinyongp.dev/posts/d3js/4/</link><pubDate>Fri, Apr 22 14:18:15 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/4/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>저번 시리즈에서 필요한 기능은 전부 구현해보았지만, &lt;code>svg&lt;/code> 요소의 개수가 증가할수록 성능이 하락하는 모습을 확인했습니다. 50개의 &lt;code>nodes&lt;/code>에 대해 DevTools로 측정해본 결과, 렌더링 연산에 굉장히 많은 CPU, GPU 작업을 필요로 하고 있었습니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="SVG 50 Performance" src="https://jinyongp.dev/image/posts/d3js/4/d3-force-svg-50-performance.png" />
&lt;/p>
&lt;p>이를 해결하기 위해서 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API"
target="_blank" rel="noopener noreferrer nofollow"
>Canvas API&lt;/a
>를 이용할 수 있습니다. Canvas API를 이용하면 d3-selection을 다룰 일은 거의 없습니다. 특히나 이번처럼 단순히 원과 선만 그리면 되는 작업에서는 그리기 더욱 쉽습니다. 대신 zoom과 drag는 구현 방식에 차이가 있어 다소 어려운 점도 있습니다. 그럼 바로 코드와 함께 저번 시간에 작성한 내용을 Canvas API로 리팩토링해보도록 하겠습니다.&lt;/p>
&lt;p>이번 시리즈에선 저번 시리즈에서 완성했던 &lt;code>network&lt;/code> class를 이용합니다.&lt;/p>
&lt;hr>
&lt;h2 id="drawing-canvas" class="flex items-center gap-3">Drawing Canvas &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Drawing Canvas" href="#drawing-canvas"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Canvas API는 말 그대로 &lt;a
class="underline-lsre"
href="https://ko.wikipedia.org/wiki/%EC%BA%94%EB%B2%84%EC%8A%A4"
target="_blank" rel="noopener noreferrer nofollow"
>캔버스&lt;/a
>로 볼 수 있습니다. 그 위에 그림을 그리고 수정이 필요하다면 전부 지우고 다시 그리면 됩니다. 애니메이션이라면 매 프레임마다 지우고 그리기를 반복합니다. 이처럼 d3-force 또한 매 틱마다 반복하면 됩니다.&lt;/p>
&lt;blockquote>
&lt;p>d3.js에 대해서 중점적으로 다루는 프로젝트이므로 Canvas API에 대해 자세한 언급은 없습니다. 이에 대한 내용은 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API"
target="_blank" rel="noopener noreferrer nofollow"
>공식 문서&lt;/a
>를 참고 바랍니다.&lt;/p>
&lt;/blockquote>
&lt;p>Svg 방식에서는 &lt;code>svg&lt;/code> 요소를 생성하고 &lt;code>tick&lt;/code>에서 위치를 변경하는 방식으로 구현했습니다. Canvas 방식에선 그냥 그려주기만 하면 됩니다. 이를 위해 &lt;code>canvas&lt;/code>와 &lt;code>ctx&lt;/code>를 생성하고 &lt;code>tick&lt;/code> 이벤트를 등록해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas = d3.select(&amp;#34;body&amp;#34;)
.append(&amp;#34;canvas&amp;#34;)
.attr(&amp;#34;width&amp;#34;, this.size.w)
.attr(&amp;#34;height&amp;#34;, this.size.h)
.style(&amp;#34;display&amp;#34;, &amp;#34;block&amp;#34;);
this.ctx = this.canvas.node().getContext(&amp;#34;2d&amp;#34;);
this.nodeRadius = 8;
this.simulation = d3
.forceSimulation()
.on(&amp;#34;tick&amp;#34;, this.drawCanvas.bind(this));
}
drawCanvas() {
this.ctx.clearRect(0, 0, this.size.w, this.size.h);
this.ctx.save();
this.drawLinks();
this.drawNodes();
this.ctx.restore();
}
drawNodes() {
console.log(&amp;#34;Drawing Nodes!&amp;#34;);
}
drawLinks() {
console.log(&amp;#34;Drawing Links!&amp;#34;);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>drawCanvas()&lt;/code>, &lt;code>drawNodes()&lt;/code> 그리고 &lt;code>drawLinks()&lt;/code> 함수 내에선 이제 d3-selection 없이 &lt;code>ctx&lt;/code>만으로 그림을 그립니다. 먼저 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>ctx.clearRect()&lt;/code>&lt;/a
>로 &lt;code>canvas&lt;/code>를 전부 지워줍니다. 그리고 &lt;code>drawNodes()&lt;/code>와 &lt;code>drawLinks()&lt;/code>를 호출하여 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 그려줍니다. 이 때, &lt;code>links&lt;/code>를 먼저 그려줘야만 &lt;code>nodes&lt;/code> 뒤에 그려집니다.&lt;/p>
&lt;p>&lt;code>links&lt;/code>는 굉장히 간단하게 그릴 수 있습니다. &lt;code>links&lt;/code>를 순회하면서 선을 그려줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">drawLinks() {
this.links.forEach(({ source, target }) =&amp;gt; {
this.ctx.beginPath();
this.ctx.moveTo(source.x, source.y);
this.ctx.lineTo(target.x, target.y);
this.ctx.stroke();
});
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>nodes&lt;/code>는 저번 시리즈에서 그렸던 것처럼 원 중앙에 &lt;code>id&lt;/code>가 위치하도록 작성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">drawNodes() {
this.nodes.forEach(({ id, x, y }) =&amp;gt; {
this.ctx.beginPath();
this.ctx.arc(x, y, this.nodeRadius, 0, 2 * Math.PI);
this.ctx.lineWidth = 3;
this.ctx.strokeStyle = &amp;#34;blue&amp;#34;;
this.ctx.stroke();
this.ctx.fillStyle = &amp;#34;#fff&amp;#34;;
this.ctx.fill();
this.ctx.textAlign = &amp;#34;center&amp;#34;;
this.ctx.textBaseline = &amp;#34;middle&amp;#34;;
this.ctx.fillStyle = &amp;#34;#000&amp;#34;;
this.ctx.fillText(id, x, y);
});
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>d3-selection 없이 오로지 canvas만 이용하므로 쉽게 그릴 수 있습니다.&lt;/p>
&lt;hr>
&lt;h2 id="panning-and-zooming" class="flex items-center gap-3">Panning and Zooming &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Panning and Zooming" href="#panning-and-zooming"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom을 연결해서 화면을 이동하고 확대, 축소할 수 있도록 구현하겠습니다. Svg 방식에선 요소의 &lt;code>transform&lt;/code> 속성을 변경하여 직접 이동했다면, canvas 방식에선 전부 지우고 위치 이동 후 다시 그려주는 방식으로 구현합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.transform = d3.zoomIdentity;
this.zoom = d3.zoom()
.scaleExtent([0.1, 5])
.on(&amp;#39;zoom&amp;#39;, ({ transform }) =&amp;gt; {
this.transform = transform;
this.drawCanvas();
});
this.canvas.call(this.zoom);
}
drawCanvas() {
this.ctx.clearRect(0, 0, this.size.w, this.size.h);
this.ctx.save();
this.ctx.translate(this.transform.x, this.transform.y);
this.ctx.scale(this.transform.k, this.transform.k);
this.drawLinks();
this.drawNodes();
this.ctx.restore();
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoomIdentity"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>d3.zoomIdentity&lt;/code>&lt;/a
>는 &lt;code>{ k: 1, x: 0, y: 0 }&lt;/code>인 객체입니다. 이를 이용해 &lt;code>transform&lt;/code> 변수를 생성한 뒤, &lt;code>zoom&lt;/code> 이벤트로 얻은 &lt;code>transform&lt;/code>을 저장합니다. 그 후, &lt;code>drawCanvas()&lt;/code>를 호출하여 &lt;code>ctx.translate()&lt;/code>와 &lt;code>ctx.scale()&lt;/code> 함수를 이용해 변경한 위치에 그리도록 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="focusing" class="flex items-center gap-3">Focusing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Focusing" href="#focusing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>특정 요소를 클릭했을 때, 해당 요소를 포커싱하는 동작을 구현해보도록 하겠습니다. Canvas는 개별 요소를 선택할 수 없어서 요소에 커서 스타일을 적용하거나 클릭 이벤트를 적용하는데 어려움이 있습니다. 하지만, d3.js에서 제공하는 기능의 조합으로 쉽게 구현할 수 있습니다.&lt;/p>
&lt;p>개별 요소가 아닌 &lt;code>canvas&lt;/code> 자체에 클릭 이벤트를 등록합니다. 그렇게 얻은 &lt;code>event&lt;/code>로부터 클릭 좌표를 얻어 해당 위치에 존재하는 &lt;code>node&lt;/code>를 찾고, 해당 &lt;code>node&lt;/code>로 이동하고 확대합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas.on(&amp;#34;click&amp;#34;, ({ x, y }) =&amp;gt; {
const node = this.findNode(x, y);
if (!node) return;
this.canvas
.transition()
.duration(500)
.call(this.zoom.translateTo, node.x, node.y)
.transition()
.call(this.zoom.scaleTo, 3);
});
}
findNode(x, y) {
const [ix, iy] = this.transform.invert([x, y]);
return this.simulation.find(ix, iy, this.nodeRadius);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>canvas&lt;/code>에 &lt;code>click&lt;/code> 이벤트를 등록하여 &lt;code>event&lt;/code> 객체로부터 클릭한 위치인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표를 얻었습니다.&lt;/p>
&lt;p>&lt;code>findNode()&lt;/code> 메서드는 주어진 좌표에 &lt;code>node&lt;/code>가 존재하는지 확인하고 해당 &lt;code>node&lt;/code>를 반환합니다. &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#transform_invert"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>transform.invert()&lt;/code>&lt;/a
>는 주어진 절대 좌표에 현재 &lt;code>transform&lt;/code> 좌표값을 포함하여 계산하고 반환합니다. 이를 이용해야만 변경된 &lt;code>transform&lt;/code>을 적용한 좌표를 얻을 수 있습니다. &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_find"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.find()&lt;/code>&lt;/a
>는 주어진 좌표에서 가장 가까이에 위치한 &lt;code>node&lt;/code>를 검색하여 반환합니다. &lt;code>node&lt;/code>의 반지름을 제공하여 해당 요소를 클릭해야만 &lt;code>node&lt;/code>를 찾을 수 있도록 하였습니다.&lt;/p>
&lt;p>&lt;code>node&lt;/code>를 찾았다면, &lt;code>zoom.translate&lt;/code>로 해당 &lt;code>node&lt;/code> 위치로 이동한 후 확대합니다.&lt;/p>
&lt;hr>
&lt;h2 id="dragging" class="flex items-center gap-3">Dragging &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Dragging" href="#dragging"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-drag를 연결하여 요소를 드래그하는 기능을 추가해보도록 하겠습니다. Svg 방식에서는 &lt;code>circles&lt;/code>에 drag를 부착하여 모든 요소에 대해 이벤트를 등록했습니다. Canvas 방식에서는 그런 방법이 불가능하기 때문에, &lt;code>canvas&lt;/code>에 등록하면서 동시에 클릭한 요소를 검색하는 &lt;code>subject&lt;/code>를 설정해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.drag = d3
.drag()
.subject(({ x, y }) =&amp;gt; this.findNode(x, y))
.on(&amp;#34;start&amp;#34;, () =&amp;gt; {
this.canvas.style(&amp;#34;cursor&amp;#34;, &amp;#34;grabbing&amp;#34;);
this.simulation.alphaTarget(0.1).restart();
})
.on(&amp;#34;drag&amp;#34;, (event) =&amp;gt; {
const [x, y] = d3.pointer(event);
event.subject.fx = this.transform.invertX(x);
event.subject.fy = this.transform.invertY(y);
})
.on(&amp;#34;end&amp;#34;, ({ subject }) =&amp;gt; {
this.canvas.style(&amp;#34;cursor&amp;#34;, &amp;#34;default&amp;#34;);
this.simulation.alphaTarget(0);
subject.fx = null;
subject.fy = null;
});
this.canvas.call(this.drag);
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag#drag_subject"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>drag.subject()&lt;/code>&lt;/a
>는 드래그하려는 주체 &lt;code>node&lt;/code>를 선택할 때 이용합니다. &lt;code>findNode()&lt;/code> 함수로 검색한 &lt;code>node&lt;/code>를 &lt;code>subject&lt;/code>로 설정합니다. 설정 이후, &lt;code>event&lt;/code> 객체에서 &lt;code>subject&lt;/code> property에 선택한 &lt;code>node&lt;/code>가 등록됩니다.&lt;/p>
&lt;p>Drag 이벤트에 등록한 함수는 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag#drag-events"
target="_blank" rel="noopener noreferrer nofollow"
>첫 번째 인자로 &lt;code>event&lt;/code> 객체&lt;/a
>를 가집니다. Canvas 방식의 경우 개별 요소가 아닌 canvas에 등록되었기 때문에 &lt;code>event.x&lt;/code>와 &lt;code>event.y&lt;/code>의 값이 canvas 기준으로 생성됩니다. 클릭 위치 기반으로 좌표를 가져오기 위해 &lt;code>event.sourceEvent&lt;/code> 객체를 이용해야하므로 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection#pointer"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>d3.pointer()&lt;/code>를 이용&lt;/a
>해 좌표를 가져옵니다. 그리고 &lt;code>transform&lt;/code>을 적용하여 &lt;code>subject&lt;/code>의 고정 좌표를 변경합니다.&lt;/p>
&lt;p>&lt;code>start&lt;/code>와 &lt;code>end&lt;/code> 이벤트에서 &lt;code>cursor&lt;/code> 스타일을 변경해주고 있습니다. 다만, 요소에 마우스를 올렸을 때도 스타일을 변경해주기 위해 &lt;code>pointermove&lt;/code> 이벤트를 추가해주었습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">class network {
constructor() {
this.canvas.on(&amp;#34;pointermove&amp;#34;, ({ x, y, buttons }) =&amp;gt; {
if (buttons) return;
const node = this.findNode(x, y);
this.canvas.style(&amp;#34;cursor&amp;#34;, node ? &amp;#34;pointer&amp;#34; : &amp;#34;default&amp;#34;);
});
}
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>event.buttons&lt;/code>는 현재 마우스를 클릭한 상태인지 판별하여 드래그 중일 땐 무시하도록 합니다. &lt;code>node&lt;/code>가 위치하는 곳에서만 &lt;code>pointer&lt;/code> 스타일을 갖도록 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>저번 시리즈에서 작성한 코드를 Canvas로 작성해보았습니다. 이제 요소의 개수를 많이 추가하더라도 성능 하락의 모습을 보이지 않는 걸 확인할 수 있습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="qBpwbbR" data-editable="true" data-user="jinyongp" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/qBpwbbR">
D3 Force (w/ Canvas)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>성능 향상을 위해 여태까지 작업했던 내용을 Canvas API로 다시 작성해보았습니다. 단순히 그려보는 건 쉬웠지만 zoom과 drag 기능을 적용하는 건 여러 시행착오를 거쳐야했고 다양한 함수를 적용할 필요가 있어 svg 구현 방식보다 어려움을 겪었습니다.&lt;/p>
&lt;p>성능을 측정해보겠습니다. 50개의 &lt;code>node&lt;/code>를 테스트했던 svg 방식과 달리 200개의 &lt;code>node&lt;/code>를 생성하고 측정해봤음에도 굉장한 성능 향상을 보여줍니다. 대부분은 함수 실행 시간이고 랜더링 연산은 거의 영향을 미치지 않습니다.&lt;/p>
&lt;p>&lt;img class="mx-auto" alt="Canvas 200 Performance" src="https://jinyongp.dev/image/posts/d3js/4/d3-force-canvas-200-performance.png" />
&lt;/p>
&lt;p>지금까지 d3-force, selection, zoom, drag 등 다양한 d3.js 모듈을 사용해보았고 Canvas API로 작성해보며 성능 향상 또한 진행해보았습니다. d3.js에는 이 외에도 무수히 많은 모듈이 있습니다. 데이터를 시각화하는데 무궁무궁진 잠재력을 지닌만큼 더 다양하게 활용해보며 여러 프로젝트에서 활용해보시면 좋을 듯 싶습니다. 긴 글 읽어주셔서 감사합니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
target="_blank" rel="noopener noreferrer nofollow"
>MDN - CanvasRenderingContext2D&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Panning, Zooming and Dragging</title><link>https://jinyongp.dev/posts/d3js/3/</link><pubDate>Thu, Apr 21 11:16:27 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/3/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom"
target="_blank" rel="noopener noreferrer nofollow"
>d3-zoom&lt;/a
>과 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag"
target="_blank" rel="noopener noreferrer nofollow"
>d3-drag&lt;/a
>는 사용자가 마우스 클릭 혹은 터치로 화면을 제어하거나 요소를 이동하는 기능을 제공합니다.&lt;/p>
&lt;p>이번 시리즈 또한 마찬가지로 저번 시리즈에 구현했던 코드에 d3-zoom과 d3-drag를 결합하는 걸 목표로 하여 그에 필요한 부분만 다루도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="d3-zoom" class="flex items-center gap-3">d3-zoom &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="d3-zoom" href="#d3-zoom"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom은 사용자가 화면을 드래그 혹은 스크롤하여 현재 보는 범위를 이동, 확대, 축소하는 기능을 제공합니다. 혹은, 특정 요소를 선택했을 때 그 위치로 이동하면서 포커스하는 효과를 줄 수도 있습니다.&lt;/p>
&lt;h3 id="panning-and-zooming" class="flex items-center gap-3">Panning and Zooming &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Panning and Zooming" href="#panning-and-zooming"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>d3-zoom은 d3-selection과 연계하여 구현합니다. &lt;code>Selection&lt;/code> 객체에 zoom 기능을 제공하기 위해 &lt;code>d3.zoom()&lt;/code> 함수를 호출하여 전달합니다. 저번 시리즈에서 생성한 &lt;code>root&lt;/code> 요소를 가져와 zoom 기능을 추가해보겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const zoom = d3
.zoom()
.on(&amp;#39;zoom&amp;#39;, (event) =&amp;gt; {
console.log(&amp;#39;Zoom and Drag!&amp;#39;);
});
root.call(zoom);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>d3.zoom()&lt;/code> 함수는 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 생성하여 반환합니다. &lt;code>root.call(zoom)&lt;/code>을 호출함으로써 인자로 받은 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom/blob/1bccd3fd56ea24e9658bd7e7c24e9b89410c8967/src/zoom.js#L72-L83"
target="_blank" rel="noopener noreferrer nofollow"
>객체에 여러 property와 event를 등록&lt;/a
>하게 됩니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection#selection_call"
target="_blank" rel="noopener noreferrer nofollow"
>selection.call()&lt;/a
>은 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 인자로 받습니다. &lt;code>root.call(zoom)&lt;/code>은 다음 코드와 동일합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">zoom(root);&lt;/code>&lt;/pre>
&lt;/div>
&lt;/blockquote>
&lt;p>&lt;code>root&lt;/code> 요소를 드래그하거나 스크롤을 해보면 이벤트에 등록한 함수가 실행됩니다. &lt;code>zoom&lt;/code> 이벤트에 등록할 함수를 작성하여 요소를 이동시켜봅시다.&lt;/p>
&lt;p>전달한 함수는 &lt;code>event&lt;/code> 객체를 매개변수로 가집니다. 클릭 이동인지 스크롤인지에 따라 종류가 달라집니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">// MouseEvent
sourceEvent: MouseEvent {...}
target: ƒ y(t)
transform: Jx {k: x.xx, x: x.xx, y: x.xx}
type: &amp;#34;zoom&amp;#34;
// WheelEvent
sourceEvent: WheelEvent {...}
target: ƒ y(t)
transform: Jx {k: x.xx, x: x.xx, y: x.xx}
type: &amp;#34;zoom&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>이 중에서 scale factor인 &lt;code>k&lt;/code> 와 translation 값인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code>를 얻을 수 있는 &lt;code>transform&lt;/code> 객체를 이용합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">.on(&amp;#39;zoom&amp;#39;, ({ transform }) =&amp;gt; {
nodeGroup.attr(&amp;#39;transform&amp;#39;, transform);
linkGroup.attr(&amp;#39;transform&amp;#39;, transform);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>저번 시리즈에서 생성한 &lt;code>nodeGroup&lt;/code>과 &lt;code>linkGroup&lt;/code>은 &lt;code>svg&lt;/code> 요소를 가지는 &lt;code>Selection&lt;/code> 객체로 &lt;code>transform&lt;/code> 속성을 변경하여 위치와 크기를 조절할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>transform&lt;/code>은 객체인데 그대로 전달할 수 있는 이유는 적용될 때 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#transform_toString"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>transform.toString()&lt;/code>함수가 호출되어 &lt;code>&amp;quot;translate(x,y) scale(k)&amp;quot;&lt;/code> 형태의 문자열로 변환&lt;/a
>되기 때문입니다.&lt;/p>
&lt;/blockquote>
&lt;p>화면을 드래그하여 이동하고 스크롤하여 확대, 축소할 수 있습니다.&lt;/p>
&lt;h3 id="focusing" class="flex items-center gap-3">Focusing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Focusing" href="#focusing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>그럼 특정 요소를 클릭했을 때 해당 요소를 포커스하는 동작에 대해 구현해보겠습니다. 일단 &lt;code>Selection&lt;/code> 객체에 이벤트를 등록하기 위해선 &lt;code>selection.on()&lt;/code> 메서드를 호출합니다. 저번 시리즈에서 생성한 &lt;code>circles&lt;/code>를 가져오겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">circles.on(&amp;#39;click&amp;#39;, (event, node) =&amp;gt; {
console.log(&amp;#39;Click!&amp;#39;);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>click&lt;/code> 이벤트에 등록한 함수는 &lt;code>event&lt;/code>와 &lt;code>node&lt;/code> 객체를 매개변수로 가집니다. &lt;code>node&lt;/code>의 현재 위치 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표로 이동 및 확대해야 하므로 이를 이용합니다.&lt;/p>
&lt;p>사용자의 조작이 아닌 코드를 통해 특정 좌표로 이동하고 확대하기 위해선 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoom_translateTo"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>zoom.translateTo&lt;/code>&lt;/a
>와 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom#zoom_scaleTo"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>zoom.scaleTo&lt;/code>&lt;/a
> 함수를 이용합니다. 해당 함수는 첫 번째 인자로 &lt;code>Selection&lt;/code> 객체를 전달받으므로 &lt;code>selection.call()&lt;/code> 함수로 호출할 수 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">circles.on(&amp;#39;click&amp;#39;, (_, { x, y }) =&amp;gt; {
root
.transition()
.duration(500)
.call(zoom.translateTo, x, y)
.transition()
.call(zoom.scaleTo, 3);
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>circles&lt;/code> 요소를 클릭하면 클릭한 &lt;code>circle&lt;/code>의 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표를 가져옵니다. 그리고 &lt;code>zoom.translateTo&lt;/code>와 &lt;code>zoom.scaleTo&lt;/code>가 &lt;code>root&lt;/code> 요소의 zoom 상태를 변경합니다. &lt;code>transition&lt;/code>과 &lt;code>duration&lt;/code>은 zoom이 이동할 때 transition 효과를 주어 보다 자연스러운 움직임을 제공합니다.&lt;/p>
&lt;hr>
&lt;h2 id="d3-drag" class="flex items-center gap-3">d3-drag &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="d3-drag" href="#d3-drag"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-drag는 요소를 클릭하여 드래그하는 기능을 제공합니다.&lt;/p>
&lt;h3 id="dragging" class="flex items-center gap-3">Dragging &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Dragging" href="#dragging"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>d3-drag 또한 d3-selection에 기능을 제공합니다. &lt;code>d3.drag()&lt;/code> 함수는 &lt;code>Selection&lt;/code> 객체를 인자로 받는 함수를 생성하여 반환합니다. 추가로, 드래그하기 위해서 필요한 세 가지 이벤트를 등록해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const drag = d3
.drag()
.on(&amp;#34;start&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Drag Start!&amp;#39;);
})
.on(&amp;#34;drag&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Dragging!&amp;#39;);
})
.on(&amp;#34;end&amp;#34;, (event, node) =&amp;gt; {
console.log(&amp;#39;Drag End!&amp;#39;);
});
circles.call(drag);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>요소를 클릭하면 &lt;code>start&lt;/code> 이벤트가 발생하고, 클릭 후 드래그하면 &lt;code>drag&lt;/code> 이벤트 그리고 클릭을 떼면 &lt;code>end&lt;/code> 이벤트가 발생합니다. 이벤트에 등록한 모든 함수는 클릭 이벤트 객체와 클릭한 요소의 정보를 매개변수로 가집니다.&lt;/p>
&lt;p>요소를 클릭하여 드래그할 때 simulation은 계속 실행 중인 상태여야 합니다. d3-force 시리즈에서 언급한 내용으로 simulation을 종료하지 않고 계속 실행하려면 &lt;code>alphaTarget&lt;/code>을 이용해야 합니다.&lt;/p>
&lt;p>또한, 요소가 다른 요소와 상관없이 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_nodes"
target="_blank" rel="noopener noreferrer nofollow"
>특정 고정 좌표에 위치하도록 하려면 &lt;code>fx&lt;/code>와 &lt;code>fy&lt;/code> 값을 설정&lt;/a
>해야 합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const drag = d3
.drag()
.on(&amp;#39;start&amp;#39;, (event, node) =&amp;gt; {
nodeGroup.style(&amp;#39;cursor&amp;#39;, &amp;#39;grabbing&amp;#39;);
simulation.alphaTarget(0.1).restart();
})
.on(&amp;#39;drag&amp;#39;, (event, node) =&amp;gt; {
node.fx = event.x;
node.fy = event.y;
})
.on(&amp;#39;end&amp;#39;, (event, node) =&amp;gt; {
nodeGroup.style(&amp;#39;cursor&amp;#39;, &amp;#39;grab&amp;#39;);
simulation.alphaTarget(0);
node.fx = null;
node.fy = null;
});
circles.call(drag);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>클릭할 때 &lt;code>alphaTarget&lt;/code>을 &lt;code>alphaMin&lt;/code>보다 크게 설정하여 simulation이 절대 종료되지 않도록 합니다. &lt;code>alphaTarget&lt;/code> 값이 클수록 다른 요소의 움직임이 커집니다. 클릭을 종료하면 다시 되돌려놓습니다.&lt;/p>
&lt;p>클릭하여 드래그를 시작하면 &lt;code>fx&lt;/code>와 &lt;code>fy&lt;/code> 값을 현재 마우스의 위치로 설정합니다. 클릭을 종료하면 &lt;code>null&lt;/code>로 설정하여 고정 위치를 제거합니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom과 d3-drag를 추가해보았습니다. &lt;code>Network&lt;/code> class를 작성하여 코드를 정리했고 실시간으로 &lt;code>alpha&lt;/code>와 &lt;code>zoom&lt;/code> 상태를 확인하고 제어할 수 있도록 구현하였습니다. &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 추가할 수 있도록 구현하였습니다. 비어있는 채로 &lt;code>ADD&lt;/code>를 클릭하면 새로운 요소가 임의의 요소에 연결됩니다. 그리고 &lt;code>node&lt;/code>의 아이디를 DOM에 그려 &lt;code>node&lt;/code>의 데이터를 어떻게 DOM에 적용할 수 있는지 보여줬습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="mdpoWxa" data-user="jinyongp" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/mdpoWxa">
D3 Force, Zoom, Drag (w/ SVG)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-zoom과 d3-drag를 기존 프로젝트에 연결하는 코드를 작성해보면서 개념과 구현 방법에 대해 알아보았습니다. 여기서 사용해본 기능 말고도 d3는 정말 많은 기능을 제공합니다. 공식 문서에 예시가 살짝 아쉽긴 하지만, 직접 사용해보면서 그 유틸성을 확인해보았으면 합니다.&lt;/p>
&lt;p>&lt;code>ADD&lt;/code> 버튼을 눌러 계속 요소를 추가하다보면 점점 프레임이 떨어지면서 성능이 하락하는 모습을 볼 수 있습니다. 이 문제는 HTML5 Canvas API가 해결할 수 있습니다. 허나, 이 방법도 그리기엔 쉬울지 몰라도 오늘 적용한 zoom과 drag 기능을 추가하는데엔 어려움이 있습니다. 다음 시리즈는 지금까지 구현한 내용을 Canvas API로 리팩토링하면서 전부 알아보도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom"
target="_blank" rel="noopener noreferrer nofollow"
>d3-zoom&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag"
target="_blank" rel="noopener noreferrer nofollow"
>d3-drag&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-transition"
target="_blank" rel="noopener noreferrer nofollow"
>d3-transition&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Data Driven Transformation of DOM</title><link>https://jinyongp.dev/posts/d3js/2/</link><pubDate>Sat, Apr 16 02:47:11 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/2/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection"
target="_blank" rel="noopener noreferrer nofollow"
>d3-selection&lt;/a
>은 데이터를 기반으로 DOM을 조작할 수 있는 다양한 기능을 제공합니다.&lt;/p>
&lt;p>이번 시리즈는 d3-force와 연계하여 Github Follower, Following 관계망 그리기를 목표로 하고 있으므로 구현 과정에서 필요한 부분에 대해서만 다루도록 하겠습니다.&lt;/p>
&lt;p>들어가기 전에 &lt;code>Selection&lt;/code> 객체에 대해 알아봅시다. d3-selection으로 선택한 요소는 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection/blob/main/src/selection/index.js"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>groups&lt;/code>와 &lt;code>parents&lt;/code> property를 갖는 &lt;code>Selection&lt;/code> 객체&lt;/a
>를 생성합니다. &lt;code>Selection&lt;/code> 객체는 선택한 요소를 제어할 수 있는 다양한 메서드를 제공합니다.&lt;/p>
&lt;ul>
&lt;li>요소 선택: selection, select, selectAll, selectChild, selectChildren, filter, merge&lt;/li>
&lt;li>요소 변경: attr, classed, style, property, text, html, append, insert, remove, clone, sort, order, raise, lower&lt;/li>
&lt;li>데이터 연결: data, join, enter, exit, datum&lt;/li>
&lt;li>이벤트 핸들링: on, dispatch&lt;/li>
&lt;li>제어 흐름: each, call, empty, nodes, size, [Symbol.iterator]()&lt;/li>
&lt;/ul>
&lt;p>d3-selection을 이용하여 선택한 요소에 데이터를 연결하고 그 데이터를 기반으로 요소를 제어할 수 있습니다.&lt;/p>
&lt;p>이제 코드와 함께 d3-selection을 이용하여 간단한 그래프를 그려보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="creating-and-editing" class="flex items-center gap-3">Creating and Editing &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Creating and Editing" href="#creating-and-editing"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>관계망에 사용할 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 브라우저에 그려주기 위해 d3-selection으로 &lt;code>svg&lt;/code>를 생성하고 크기를 설정해줍니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const root = d3
.select(&amp;#39;body&amp;#39;) // === d3.select(document.body)
.append(&amp;#39;svg&amp;#39;)
.attr(&amp;#39;width&amp;#39;, &amp;#39;100%&amp;#39;)
.attr(&amp;#39;height&amp;#39;, &amp;#39;100%&amp;#39;)
.style(&amp;#39;display&amp;#39;, &amp;#39;block&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>body&lt;/code> 요소를 선택하고 하위에 &lt;code>svg&lt;/code> 요소를 추가했습니다. 그리고 &lt;code>attr&lt;/code> 메서드와 &lt;code>style&lt;/code> 메서드로 &lt;code>svg&lt;/code>의 속성과 스타일을 지정했습니다. &lt;code>root&lt;/code>엔 &lt;code>svg&lt;/code> 요소를 담고 있는 &lt;code>Selection&lt;/code> 객체가 할당됩니다.&lt;/p>
&lt;p>&lt;code>root&lt;/code> 아래 &lt;code>links&lt;/code>와 &lt;code>nodes&lt;/code>를 각각 묶을 &lt;code>g&lt;/code> 요소를 생성합니다. (&lt;code>linkGroup&lt;/code>을 먼저 생성해야 뒤에 배치됩니다.)&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const linkGroup = root.append(&amp;#39;g&amp;#39;).attr(&amp;#39;id&amp;#39;, &amp;#39;links&amp;#39;);
const nodeGroup = root.append(&amp;#39;g&amp;#39;).attr(&amp;#39;id&amp;#39;, &amp;#39;nodes&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>id&lt;/code>는 별 다른 역할 없이 식별을 위해 추가해주었습니다.&lt;/p>
&lt;hr>
&lt;h2 id="joining-data" class="flex items-center gap-3">Joining Data &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Joining Data" href="#joining-data"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>이제 DOM 요소에 데이터를 연결해봅시다. &lt;code>nodeGroup&lt;/code> 아래 &lt;code>circle&lt;/code>을 배치하고 &lt;code>nodes&lt;/code> 데이터를 연결합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const circles = nodeGroup
.selectAll(&amp;#39;circle&amp;#39;)
.data(nodes)
.join(&amp;#39;circle&amp;#39;)
.attr(&amp;#39;r&amp;#39;, 5)
.attr(&amp;#39;fill&amp;#39;, &amp;#39;blue&amp;#39;);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>얼핏 보면 말이 되는 듯하지만 아직 생성도 하지 않은 &lt;code>circle&lt;/code>을 왜 선택하고 있는지 의문이 생깁니다. 각 단계가 생성하는 &lt;code>Selection&lt;/code> 객체를 보고 흐름을 이해해봅시다.&lt;/p>
&lt;p>&lt;code>nodeGroup.selectAll('circle')&lt;/code>은 당연히 빈 &lt;code>Selection&lt;/code> 객체를 반환합니다.&lt;/p>
&lt;blockquote>
&lt;p>💡 당연히 비어있는 &lt;code>Selection&lt;/code> 객체를 받을건데 왜 &lt;code>selectAll&lt;/code>을 쓸까요?&lt;/p>
&lt;p>이후에 &lt;code>nodes&lt;/code>를 추가해야 할 상황이 생긴다면, 기존에 생성되었던 &lt;code>circle&lt;/code> 요소와 &lt;code>nodes&lt;/code>를 비교하여 추가된 &lt;code>node&lt;/code>의 개수만큼 &lt;code>circle&lt;/code> 요소를 추가합니다. 즉, 비교를 위해 선택하는 요소와 생성하는 요소는 동일해야 합니다.&lt;/p>
&lt;/blockquote>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: [NodeList(0)]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>.data(nodes)&lt;/code>는 빈 &lt;code>Selection&lt;/code> 객체에 &lt;code>nodes&lt;/code> 배열의 길이만큼 연결합니다. &lt;code>jt&lt;/code> 객체는 &lt;code>__data__&lt;/code> property에 &lt;code>node&lt;/code> 정보를 갖고 있습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_enter: [Array(5)]
0: (5) [jt, jt, jt, jt, jt]
_exit: [Array(0)]
0: []
_groups: [Array(5)]
0: (5) [empty × 5]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_enter: Array(1)
0: Array(5)
0: jt {...}
1: jt {...}
2: jt {...}
3: jt {...}
4: jt
namespaceURI: &amp;#34;http://www.w3.org/2000/svg&amp;#34;
ownerDocument: document
__data__: {id: 5, index: 4, x:...}
_exit: [Array(0)]
_groups: [Array(5)]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>.join('circle')&lt;/code>은 &lt;code>.enter().append('circle')&lt;/code>과 동일한 단축 표현입니다. &lt;code>.enter()&lt;/code>까지 실행한 결과는 아래와 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: (5) [jt, jt, jt, jt, jt]
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: Array(5)
0: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
1: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
2: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
3: jt {ownerDocument: document, namespaceURI: &amp;#39;http://www.w3.org/2000/svg&amp;#39;, ...}
4: jt
namespaceURI: &amp;#34;http://www.w3.org/2000/svg&amp;#34;
ownerDocument: document
__data__: {id: 5, index: 4, x: ...}
...
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>enter().append('circle')&lt;/code>까지 실행한 결과는 아래와 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">_groups: Array(1)
0: Array(5)
0: circle
1: circle
2: circle
3: circle
4: circle
__data__: {id: 5, index: 4, x:...}
...
_parents: [g#nodes]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>circle&lt;/code> 요소가 연결되었고 &lt;code>circle&lt;/code> 내부에 &lt;code>__data__&lt;/code>가 결합되었습니다.&lt;/p>
&lt;hr>
&lt;h2 id="impl" class="flex items-center gap-3">Impl. &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Impl." href="#impl"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>&lt;code>ticked&lt;/code> 함수 내부에서 DOM 요소와 결합한 &lt;code>node&lt;/code> 객체의 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 좌표 데이터를 이용해 요소를 화면 상에 그려보았습니다.&lt;/p>
&lt;p class="codepen" data-height="600" data-default-tab="result" data-slug-hash="MWrxgPB" data-user="jinyongp" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
&lt;span>See the Pen &lt;a href="https://codepen.io/jinyongp/pen/MWrxgPB">
D3 Force (w/ SVG)&lt;/a> by Park, Jinyong (&lt;a href="https://codepen.io/jinyongp">@jinyongp&lt;/a>)
on &lt;a href="https://codepen.io">CodePen&lt;/a>.&lt;/span>
&lt;/p>
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js">&lt;/script>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-selection의 개념과 데이터 결합 방법과 흐름에 대해 살펴보았습니다. 저번과 달리 많은 개념에 대해 알아보진 않았지만, 요소를 선택하고 속성을 변경하고 데이터를 결합하는 정말 필요한 내용만 다루면서 d3-force와 연동하여 간단한 그래프를 그려볼 수 있었습니다.&lt;/p>
&lt;p>&lt;code>node&lt;/code>의 데이터가 많아질수록 d3-selection을 더욱 적극적으로 이용할 예정이므로, 그 때를 위해 이번엔 이 정도로 하고 다음 시리즈에선 d3-zoom과 d3-drag를 이용하여 상호작용하는 방법에 대해 알아보겠습니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection"
target="_blank" rel="noopener noreferrer nofollow"
>d3-selection&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://bost.ocks.org/mike/join/"
target="_blank" rel="noopener noreferrer nofollow"
>Thinking with Joins&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://lucidar.me/en/d3.js/part-07-data-binding"
target="_blank" rel="noopener noreferrer nofollow"
>D3.js Tutorial - Data Binding&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>D3.js Network Simulation In Depth</title><link>https://jinyongp.dev/series/d3js/1/</link><pubDate>Thu, Apr 14 14:31:09 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/series/d3js/1/</guid><description>&lt;h2 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>원티드 프리온보딩에서 주어진 과제 중 하나인 &lt;a
class="underline-lsre"
href="https://github.com/Pre-Onboarding-FE-Team07/wanted-codestates-project-7-7-2"
target="_blank" rel="noopener noreferrer nofollow"
>D3.js를 이용한 Github Starred Repo 관계망 그리기 프로젝트&lt;/a
>를 진행하면서 d3.js에 큰 흥미를 가지게 되었습니다. 처음 다뤄보는 시각화 라이브러리이라 기능 하나를 추가할 때마다 많은 자료와 문서를 찾아봐야 했습니다. 어찌어찌하긴 해내긴 했지만 코드와 동작을 보며 느껴지는 부족함에 아쉬움이 생겼습니다. 아무래도 짧은 시간 내에 구현해내느라 이해하는데 어려움이 있었기 때문에, 그 어려움을 극복하고자 문서를 톺아보며 살펴보고 정리해보고자 합니다.&lt;/p>
&lt;p>사용하는 라이브러리는 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3"
target="_blank" rel="noopener noreferrer nofollow"
>d3.js&lt;/a
>입니다. d3가 가진 수많은 라이브러리 중에서도 &lt;code>d3-force&lt;/code>, &lt;code>d3-zoom&lt;/code>, &lt;code>d3-selection&lt;/code>, &lt;code>d3-drag&lt;/code> 등 추가로 필요한 모듈이라면 전부 활용해볼 예정이고 성능 향상을 위해 Canvas API로 구현해보려고 합니다.&lt;/p>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force"
target="_blank" rel="noopener noreferrer nofollow"
>d3-force&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-zoom"
target="_blank" rel="noopener noreferrer nofollow"
>d3-zoom&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-selection"
target="_blank" rel="noopener noreferrer nofollow"
>d3-selection&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-drag"
target="_blank" rel="noopener noreferrer nofollow"
>d3-drag&lt;/a
>&lt;/li>
&lt;/ul></description></item><item><title>Simulating Physical Forces</title><link>https://jinyongp.dev/posts/d3js/1/</link><pubDate>Thu, Apr 14 14:20:46 2022 +0000</pubDate><author>dev.jinyongp@gmail.com (Jinyong Park)</author><guid>https://jinyongp.dev/posts/d3js/1/</guid><description>&lt;h1 id="introduction" class="flex items-center gap-3">Introduction &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Introduction" href="#introduction"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h1>&lt;p>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force"
target="_blank" rel="noopener noreferrer nofollow"
>d3-force&lt;/a
>는 입자(&lt;code>nodes&lt;/code>) 간에 가해지는 물리적 힘(forces)을 simulation하여 입자의 좌표값을 계산하고 제공합니다.&lt;/p>
&lt;p>코드와 함께 &lt;a
class="underline-lsre"
href="#simulation"
>Simulation&lt;/a
>과 &lt;a
class="underline-lsre"
href="#forces"
>Forces&lt;/a
>에 대해 이해해봅시다.&lt;/p>
&lt;hr>
&lt;h2 id="simulationhttpsgithubcomd3d3-forcesimulation" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation"
target="_blank" rel="noopener noreferrer nofollow"
>Simulation&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Simulation" href="#simulationhttpsgithubcomd3d3-forcesimulation"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Simulation은 &lt;code>nodes&lt;/code>에 가해지는 물리적 힘을 계산합니다. &lt;code>d3.forceSimulation()&lt;/code> 함수로 simulation을 생성합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const simulation = d3.forceSimulation();&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation에 그래프의 정점 목록인 &lt;code>nodes&lt;/code>와 간선 목록인 &lt;code>links&lt;/code>를 등록할 수 있습니다.&lt;/p>
&lt;h3 id="nodes" class="flex items-center gap-3">Nodes &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Nodes" href="#nodes"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>먼저 &lt;code>nodes&lt;/code>에 대해 알아봅시다. Simulation은 입력한 &lt;code>node&lt;/code> 객체에 계산 결과값을 추가합니다. &lt;code>nodes&lt;/code> 배열에서 각 &lt;code>node&lt;/code>를 인덱스로 관리해도 되지만, 보기 어려우므로 고유 식별자 &lt;code>id&lt;/code>를 추가하겠습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const nodes = [...Array(5)].map((_, i) =&amp;gt; ({ id: i &amp;#43; 1 }));
// [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }]
simulation.nodes(nodes);
// nodes [
// {
// id: 1,
// index: 0,
// vx: x.xx,
// vy: x.xx,
// x: x.xx,
// y: x.xx,
// }
// , ...
// ]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation은 &lt;code>node&lt;/code>에 &lt;code>index&lt;/code>와 함께 좌표값인 &lt;code>x&lt;/code>, &lt;code>y&lt;/code> 그리고 속도값인 &lt;code>vx&lt;/code>, &lt;code>vy&lt;/code>를 추가합니다. 원본 &lt;code>node&lt;/code> 객체 자체를 수정해야하므로 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"
target="_blank" rel="noopener noreferrer nofollow"
>non-extensible한 객체&lt;/a
>는 사용할 수 없습니다. 만약 불변성 유지가 필요하다면 객체를 복사하여 전달해야 합니다.&lt;/p>
&lt;h3 id="links" class="flex items-center gap-3">Links &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Links" href="#links"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>그럼 이제 &lt;code>links&lt;/code>를 등록해봅시다. d3-force에서 &lt;code>link&lt;/code> 객체는 방향성을 지닌 간선이므로 &lt;code>source&lt;/code>와 &lt;code>target&lt;/code>을 가진 객체로 선언합니다. &lt;code>nodes&lt;/code>와 달리 각 property는 객체가 아닌 &lt;code>node&lt;/code>를 식별할 &lt;code>id&lt;/code>를 갖습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const links = [
{ source: 1, target: 4 },
{ source: 3, target: 4 },
{ source: 2, target: 5 },
{ source: 4, target: 1 },
{ source: 5, target: 4 },
];
simulation.force(&amp;#39;link&amp;#39;, d3.forceLink(links).id(({ id }) =&amp;gt; id));
// links [
// {
// index: 1,
// source: {
// id: 3
// index: 2
// vx: x.xx,
// vy: x.xx,
// x: x.xx,
// y: x.xx,
// },
// target: {
// ...
// },
// }, ...
// ]&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>나중에 &lt;a
class="underline-lsre"
href="#forces"
>Forces&lt;/a
> 챕터에서 다시 만나겠지만, &lt;code>links&lt;/code>는 &lt;code>nodes&lt;/code>에 작용할 힘을 제공하므로 &lt;code>force&lt;/code>로 추가합니다. &lt;code>links&lt;/code>를 simulation에 추가하면 &lt;code>source&lt;/code>, &lt;code>target&lt;/code>에 설정된 &lt;code>id&lt;/code>를 동일한 &lt;code>id&lt;/code>를 가진 &lt;code>node&lt;/code> 객체로 대체합니다. (코드에 나와 있듯 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#link_id"
target="_blank" rel="noopener noreferrer nofollow"
>link.id()&lt;/a
> 함수로 지정해야 합니다.)&lt;/p>
&lt;h3 id="tick" class="flex items-center gap-3">Tick &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Tick" href="#tick"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Simulation에 &lt;code>nodes&lt;/code>와 &lt;code>links&lt;/code>를 등록해봤습니다. &lt;code>tick&lt;/code> 이벤트에 핸들러 함수를 등록하여 매 &lt;code>tick&lt;/code>마다 실행할 코드를 작성할 수 있습니다. Simulation은 생성 직후 곧바로 실행됩니다. 필요하다면 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_stop"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.stop()&lt;/code>&lt;/a
> 함수로 정지하거나 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#simulation_restart"
target="_blank" rel="noopener noreferrer nofollow"
>&lt;code>simulation.restart()&lt;/code>&lt;/a
>로 재시작할 수 있습니다.&lt;/p>
&lt;p>&lt;code>tick&lt;/code> 이벤트 핸들러를 등록하여 &lt;code>node&lt;/code>에 저장된 결과값을 확인해봅시다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(nodes[0]);
});
// 첫 번째 tick: {id: 1, index: 0, x: 5.826695986913618, y: -4.292216192303559, vy: -4.292216192303559, …}
// 두 번째 tick: {id: 1, index: 0, x: 4.820993020602418, y: -8.04960224695047, vy: -3.7573860546469113, …}
// 세 번째 tick: {id: 1, index: 0, x: 4.188865598751164, y: -10.465829270778734, vy: -2.4162270238282635, …}
// 네 번째 tick: {id: 1, index: 0, x: 3.823314491169919, y: -11.82585404923582, vy: -1.3600247784570867, …}
// ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Simulation은 &lt;code>tick&lt;/code> 단위마다 좌표값을 계산합니다. 우린 simulation에 의해 &lt;code>tick&lt;/code>마다 계산된 절대 좌표값(x, y)를 화면에 그려주기만 하면 됩니다. 그리는 건 나중에 d3-selection과 함께 알아보겠습니다.&lt;/p>
&lt;h3 id="alpha" class="flex items-center gap-3">Alpha &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Alpha" href="#alpha"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Simulation을 얼마나 진행할 지 결정하는 &lt;code>alpha&lt;/code>, &lt;code>alphaMin&lt;/code>, &lt;code>alphaDecay&lt;/code>, &lt;code>alphaTarget&lt;/code>, &lt;code>velocityDecay&lt;/code> 속성에 대해 알아보겠습니다. 문서에 주어진 &lt;code>alpha&lt;/code>의 정의는 설명도 부실하고 이해하기 꽤 어려우니 &lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force/blob/main/src/simulation.js"
target="_blank" rel="noopener noreferrer nofollow"
>구현 코드&lt;/a
>를 보며 동작 방식을 알아봅시다. 주어진 속성의 초기값은 다음과 같습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">var simulation,
alpha = 1,
alphaMin = 0.001,
alphaDecay = 1 - Math.pow(alphaMin, 1 / 300) // 0.02276277904418933
alphaTarget = 0,
velocityDecay = 0.6,
// ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alpha&lt;/code>는 매 &lt;code>tick&lt;/code>마다 &lt;code>alpha += (alphaTarget - alpha) * alphaDecay&lt;/code>로 계산되어 감소합니다. 또한, 매 &lt;code>tick&lt;/code>마다 &lt;code>alpha&lt;/code>와 &lt;code>alphaMin&lt;/code>를 비교합니다. &lt;code>alpha&lt;/code>가 &lt;code>alphaMin&lt;/code>보다 작아질 때까지 simulation을 실행합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9772372209558107 = 1 &amp;#43; (0 - 1) * 0.02276277904418933;
// 002: 0.9549925860214359 = alpha &amp;#43; (alphaTarget - alpha) * alphaDecay
// ...
// 300: 0.0009999999999999966 종료: alphaMin(0.001) 미만
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alphaTarget&lt;/code>은 &lt;code>alpha&lt;/code>의 도달 목표입니다. &lt;code>alpha&lt;/code>는 &lt;code>alphaTarget&lt;/code>에 도달할 때까지 감소합니다. &lt;code>alphaTarget&lt;/code>이 &lt;code>alphaMin&lt;/code>보다 크다면 &lt;code>alpha&lt;/code>가 &lt;code>alphaMin&lt;/code>에 도달할 수 없으므로 simulation은 종료되지 않고 계속 실행됩니다. 나중에 d3-drag를 적용할 때 이용할 수 있습니다.&lt;/p>
&lt;p>아래 코드에서 &lt;code>alphaTarget&lt;/code>으로 &lt;code>alpha&lt;/code>가 &lt;code>1&lt;/code>부터 &lt;code>0.5&lt;/code>까지 감소하도록 설정했습니다. 하지만 &lt;code>alpha&lt;/code>가 &lt;code>0.6&lt;/code> 미만으로 감소했을 때 simulation이 종료되므로 &lt;code>0.5&lt;/code>까지 감소할 일은 없습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.alphaMin(0.6).alphaTarget(0.5);
simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9886186104779053
// 002: 0.9774962930107179
// ...
// 070: 0.5997631157484438 종료: alphaMin(0.6) 미만
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>아래 코드에선 &lt;code>alpha&lt;/code>가 &lt;code>0.4&lt;/code> 이하로 감소해야만 종료됩니다. 하지만, &lt;code>alphaTarget&lt;/code>에 의해 &lt;code>0.4&lt;/code>보다 작아질 수 없습니다. 고로, simulation이 종료되지 않습니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">simulation.alphaMin(0.4).alphaTarget(0.5);
simulation.on(&amp;#39;tick&amp;#39;, () =&amp;gt; {
console.log(simulation.alpha());
// 001: 0.9886186104779053
// 002: 0.9774962930107179
// ...
// 300: 0.5005000000000002
// 301: 진행 중...
});&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>alphaDecay&lt;/code>는 &lt;code>alpha&lt;/code>의 감소량입니다. 수가 클수록 &lt;code>alpha&lt;/code>는 &lt;code>alphaMin&lt;/code>에 빠르게 도달합니다.&lt;/p>
&lt;p>&lt;code>velocityDecay&lt;/code>는 &lt;code>node.vx&lt;/code>, &lt;code>node.vy&lt;/code> 값의 감소량입니다. 구현 코드에선 &lt;code>node.x += node.vx *= velocityDecay;&lt;/code>로 작성되어 있는데, &lt;code>node.vx *= velocityDecay&lt;/code>를 먼저 연산하고 &lt;code>node.x += node.vx&lt;/code>를 연산합니다. &lt;code>0&lt;/code>으로 설정하면 simulation이 종료될 때까지 속도를 계속 유지합니다.&lt;/p>
&lt;hr>
&lt;h2 id="forceshttpsgithubcomd3d3-forceforces" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#forces"
target="_blank" rel="noopener noreferrer nofollow"
>Forces&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Forces" href="#forceshttpsgithubcomd3d3-forceforces"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>Forces는 simulation에서 &lt;code>node&lt;/code>에 적용할 물리적 힘입니다. 척력 혹은 인력을 적용하거나, 일정 거리를 유지하게끔 합니다. 몇가지 모듈을 이용해 force를 적용할 수 있습니다. Links, many-body, centering, collision, positioning에 대해 알아봅시다.&lt;/p>
&lt;h3 id="linkshttpsgithubcomd3d3-forcelinks" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#links"
target="_blank" rel="noopener noreferrer nofollow"
>Links&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Links" href="#linkshttpsgithubcomd3d3-forcelinks"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Link force는 &lt;code>node&lt;/code>를 연결하고 일정 거리를 유지하는 힘입니다. 위에서 언급했듯 &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceLink()&lt;/code>로 생성합니다. 이 과정에서 &lt;code>distance&lt;/code>와 &lt;code>strength&lt;/code>를 이용해 거리와 거리를 유지할 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceLink = d3
.forceLink(links)
.id(({ id }) =&amp;gt; id)
.distance(100)
.strength(1);
simulation.force(&amp;#39;link&amp;#39;, forceLink);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>strength&lt;/code>는 &lt;code>distance&lt;/code>로 설정한 일정 거리를 유지하는 힘입니다. &lt;code>0&lt;/code>부터 &lt;code>1&lt;/code> 사이를 추천합니다&lt;/p>
&lt;h3 id="many-bodyhttpsgithubcomd3d3-forcemany-body" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#many-body"
target="_blank" rel="noopener noreferrer nofollow"
>Many-Body&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Many-Body" href="#many-bodyhttpsgithubcomd3d3-forcemany-body"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Many Body force는 &lt;code>nodes&lt;/code>에 척력 혹은 인력을 적용합니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceManyBody()&lt;/code>로 생성합니다. 이 또한, &lt;code>strength&lt;/code>로 적용할 힘을 결정합니다. 전달한 수가 양수라면 인력, 음수라면 척력입니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceManyBody = d3
.forceManyBody()
.strength(-300);
simulation.force(&amp;#39;manyBody&amp;#39;, forceManyBody);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>참고로 많은 예시에서 &lt;code>force('manyBody', forceManyBody)&lt;/code>가 아닌 &lt;code>force('charge', forceCharge)&lt;/code>로 되어있지만 이름은 전혀 중요하지 않습니다. 단순히 식별자 역할을 수행하므로 다른 force와 구분만 가능하면 됩니다.&lt;/p>
&lt;h3 id="centeringhttpsgithubcomd3d3-forcecentering" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#centering"
target="_blank" rel="noopener noreferrer nofollow"
>Centering&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Centering" href="#centeringhttpsgithubcomd3d3-forcecentering"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Centering force는 &lt;code>nodes&lt;/code>의 중심이 지정한 좌표(x, y)에 위치하도록 합니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceCenter()&lt;/code>로 생성합니다. Viewport 상에서 정중앙에 위치해야 할 때 적용합니다. &lt;code>strength&lt;/code>를 이용하면 부드러운 움직임이 가능합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceCenter = d3
.forceCenter(width / 2, height / 2)
.strength(0.1);
simulation.force(&amp;#39;center&amp;#39;, forceCenter);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>resize&lt;/code> 이벤트 혹은 &lt;a
class="underline-lsre"
href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"
target="_blank" rel="noopener noreferrer nofollow"
>ResizeObserver&lt;/a
>로 크기 변경을 감지하고 &lt;code>nodes&lt;/code>가 항상 중앙에 위치하도록 할 수 있습니다.&lt;/p>
&lt;h3 id="collisionhttpsgithubcomd3d3-forcecollision" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#collision"
target="_blank" rel="noopener noreferrer nofollow"
>Collision&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Collision" href="#collisionhttpsgithubcomd3d3-forcecollision"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Collision force는 &lt;code>nodes&lt;/code>가 서로 겹치는 것을 방지하는 힘입니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceCollide()&lt;/code>로 생성합니다. &lt;code>node&lt;/code>를 점이 아닌 원으로 취급하여 충돌 여부를 확인하고 &lt;code>radius&lt;/code>로 원의 반지름을 결정합니다. &lt;code>strength&lt;/code>로 겹칠 때 서로 밀어낼 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceCollide = d3
.forceCollide()
.radius(5)
.strength(0.8);
simulation.force(&amp;#39;collide&amp;#39;, forceCollide);&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="positioninghttpsgithubcomd3d3-forcepositioning" class="flex items-center gap-3">&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force#positioning"
target="_blank" rel="noopener noreferrer nofollow"
>Positioning&lt;/a
> &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Positioning" href="#positioninghttpsgithubcomd3d3-forcepositioning"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h3>&lt;p>Positioning force는 지정한 좌표(x, y)로 &lt;code>nodes&lt;/code>를 밀어내는 힘입니다. &lt;code>simulation.force()&lt;/code>와 &lt;code>d3.forceX()&lt;/code> 그리고 &lt;code>d3.forceY()&lt;/code>로 생성합니다. &lt;code>strength&lt;/code>로 밀어내는 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceX = d3.forceX().strength(1);
const forceY = d3.forceY(height / 2);
simulation.force(&amp;#39;x&amp;#39;, forceX).force(&amp;#39;y&amp;#39;, forceY);&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>d3.forceRadial()&lt;/code> 함수는 원형을 기준으로 밀어내는 힘을 생성합니다. &lt;code>strength&lt;/code>로 밀어내는 힘을 결정합니다.&lt;/p>
&lt;div class="relative rounded-md overflow-hidden my-4 group">
&lt;small
class="absolute top-0 right-0 bg-black/30 capitalize font-black text-xs text-white rounded-bl-md px-2 py-1 transition-opacity opacity-0 group-hover:opacity-100"
>
&lt;span class="sr-only">Language:&lt;/span>javascript
&lt;/small>
&lt;pre>&lt;code class="hljs language-javascript">const forceRadial = d3
.forceRadial(100, width / 2, height / 2)
.strength(0.5);
simulation.force(&amp;#39;radial&amp;#39;, forceRadial);&lt;/code>&lt;/pre>
&lt;/div>
&lt;hr>
&lt;h2 id="conclusion" class="flex items-center gap-3">Conclusion &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="Conclusion" href="#conclusion"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;p>d3-force의 개념과 동작 방식을 코드와 함께 살펴보았습니다. d3-force의 simulation, tick을 조절할 수 있는 alpha 그리고 force의 종류에 대해서 알아봤습니다. 처음 볼 땐 어려워보일 수 있겠지만 알아야 할 개념이 그리 많지 않고 이해하기 쉬운 코드와 패턴으로 금방 익힐 수 있었습니다.&lt;/p>
&lt;p>아직 d3-selection를 다루지 않아 계산 결과값으로 그래프를 그려보진 않았습니다만, 다음 시간에 d3-selection을 학습하면서 SVG로 그래프를 그려보고 이후 d3-zoom과 d3-drag를 적용해보도록 하겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="references" class="flex items-center gap-3">References &lt;i
class="transition opacity-10 hover:opacity-100 text-[0.8em] scale-90 hover:scale-100 -rotate-45 hover:-rotate-90"
>&lt;a title="References" href="#references"
>
&lt;i class="">
&lt;svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
&lt;path
d="M0 160v96C0 379.7 100.3 480 224 480s224-100.3 224-224V160H320v96c0 53-43 96-96 96s-96-43-96-96V160H0zm0-32H128V64c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64zm320 0H448V64c0-17.7-14.3-32-32-32H352c-17.7 0-32 14.3-32 32v64z"
/>
&lt;/svg>
&lt;/i>
&lt;/a
>&lt;/i
>&lt;/h2>&lt;ul>
&lt;li>&lt;a
class="underline-lsre"
href="https://github.com/d3/d3-force"
target="_blank" rel="noopener noreferrer nofollow"
>d3-force&lt;/a
>&lt;/li>
&lt;li>&lt;a
class="underline-lsre"
href="https://stackoverflow.com/q/46426072/9735184"
target="_blank" rel="noopener noreferrer nofollow"
>What is the difference between alphaTarget and alphaMin?&lt;/a
>&lt;/li>
&lt;/ul></description></item></channel></rss>