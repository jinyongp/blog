---
title: 케어닥 프로젝트
slug: 케어닥-프로젝트
description:
author: jinyongp
date: 2022-04-09T14:30:22.146Z
lastmod: 2019-08-22T15:20:28.000Z
draft: true
tags: []
categories: []
---

### 구현 내용

```js
// api/sms.js
import axios from 'axios';
import crypto from 'crypto';
import 'dotenv/config';

const SERVICE_ID = process.env.NAVER_SERVICE_ID;
const ACCESS_KEY = process.env.NAVER_ACCESS_KEY;
const SECRET_KEY = process.env.NAVER_SECRET_KEY;
const SENDER = process.env.NAVER_PHONE_NUMBER;
const URL1 = `https://sens.apigw.ntruss.com/sms/v2/services/${SERVICE_ID}/messages`;
const URL2 = `/sms/v2/services/${SERVICE_ID}/messages`;

const signature = () => {
  const method = 'POST';
  const space = ' ';
  const newLine = '\n';
  const timestamp = Date.now().toString();

  const hmac = crypto.createHmac('sha256', SECRET_KEY);
  const message = [method, space, URL2, newLine, timestamp, newLine, ACCESS_KEY].join('');
  return hmac.update(message).digest('base64').toString();
};

export default async function handler(req, res) {
  res.status(400);
  try {
    const { to, content } = req.body;
    if (!to) return res.send({ ok: false, reason: '송신 번호를 입력하세요.' });
    if (!content) return res.send({ ok: false, reason: '전송 내용을 입력하세요.' });

    const {
      data: { statusCode },
    } = await axios({
      method: 'POST',
      json: true,
      url: URL1,
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
        'x-ncp-iam-access-key': ACCESS_KEY,
        'x-ncp-apigw-timestamp': Date.now().toString(),
        'x-ncp-apigw-signature-v2': signature(),
      },
      data: {
        type: 'SMS',
        contentType: 'COMM',
        countryCode: '82',
        from: SENDER,
        content,
        messages: [{ to }],
      },
    });

    res.status(statusCode);
    return /^20\d$/.test(statusCode)
      ? res.send(JSON.stringify({ ok: true }))
      : res.send(JSON.stringify({ ok: false, reason: `요청 실패 (Code: ${statusCode})` }));
  } catch (error) {
    // console.error(error);
    return res
      .status(500)
      .send(JSON.stringify({ ok: false, reason: 'API 요청이 거부되었습니다.' }));
  }
}
```

```js
// src/pages/StepApplymentBrief.jsx 일부
useEffect(() => {
  setActiveNext(isAuthorized);
}, [isAuthorized, setActiveNext]);

const sendAuthMessage = async (phoneNumber) => {
  authCode.current = getRandomString(PHONE_AUTH_CODE_LENGTH);
  setIsSending(true);
  setIsSendingFailed(false);
  const res = await axios.post('/api/sms', {
    to: phoneNumber,
    content: `인증번호 [${authCode.current}]를 정확히 입력해주세요.`,
  });
  setIsSending(false);
  if (res.data.ok) {
    console.log(`테스트 코드: ${authCode.current}`);
    setIsRequested(true);
  } else {
    authCode.current = null;
    setIsSendingFailed(true);
    setErrorMessage(res.data.reason);
  }
};

const verifyCode = (code) => {
  if (authCode.current === code.toUpperCase()) {
    setIsAuthorized(true);
    setIsWrongCode(false);
  } else {
    setIsWrongCode(true);
  }
};
```


### 구현한 방법

[제출한 PR 목록](https://github.com/Pre-Onboarding-FE-Team07/wanted-codestates-project-7-6/pulls?q=is%3Apr+sort%3Aupdated-desc+is%3Aclosed+author%3Ajinyongp)

- 최종 작성한 결과를 확인하고, 휴대폰 인증 기능을 포함한 [`StepApplymentBrief`](./src/pages/StepApplymentBrief.jsx) 페이지를 구현했습니다. 이미 피그마로 작성되어 있어 공통으로 사용되는 컴포넌트는 [별도의 파일로 분리](src/components/Text.js)하여 관리했습니다.

- [Naver SENS API](https://www.ncloud.com/product/applicationService/sens)를 이용해 휴대폰 인증을 구현했습니다. Vercel에서 제공하는 [Vercel Serverless Functions](https://vercel.com/docs/concepts/functions/serverless-functions) 기능을 이용하여 별도의 API 서버를 구축했습니다. API 요청과 응답은 다음과 같습니다.

```
Method: Post
URL: `/api/sms`
Body: {
  to: 수신번호,
  content: 메시지 내용
}

Success
202 {
  ok: true
}

Fail
40X {
  ok: false,
  reason: 에러 내용
}

Error
500 {
  ok: false,
  reason: API 요청이 거부되었습니다.
}
```

- Naver SENS API를 이용하기 위해선 인증키를 생성하고 [Signature를 생성하는 helper 함수](https://api.ncloud-docs.com/docs/common-ncpapi#authparams)를 작성할 필요가 있었습니다. 문서를 통해 해당 helper 함수를 분석하였고, `crypto` 라이브러리를 통해 문서에서 제공하는 코드보다 [더 간결하게 작성해보았습니다.](api/sms.js#L12)

```js
const signature = () => {
  const method = 'POST';
  const space = ' ';
  const newLine = '\n';
  const timestamp = Date.now().toString();

  const hmac = crypto.createHmac('sha256', SECRET_KEY);
  const message = [method, space, URL2, newLine, timestamp, newLine, ACCESS_KEY].join('');
  return hmac.update(message).digest('base64').toString();
};
```

- `/api/sms` 주소로 POST 요청을 보내 작성한 휴대폰 번호로 5자리 인증 코드를 보냅니다. 인증 코드의 경우, UI 상에 보여줄 데이터가 아니므로 state가 아닌 ref 값으로 관리했습니다. 동일한 인증 코드를 작성하여 다음 화면으로 넘어갈 수 있습니다.

- 인증 코드 전송이 요청되었는지, 메시지를 전송 중인지, 요청 과정에서 잘못된 응답이 왔는지, 인증이 제대로 되었는지 등에 따라 버튼 내용를 변경하거나 안내 메시지를 출력해 사용자가 현재 상태를 확실히 알 수 있도록 하는데 중점을 뒀습니다.

  - 단계는 요청 단계와 인증 단계로 나뉩니다.

  - 요청 단계

    - 처음 요청 단계에서 인증 코드 요청 버튼의 내용은 `인증 요청`입니다.
    - `인증 요청` 버튼을 클릭하면 요청 중임을 알리기 위해 버튼 내용이 `요청 중...`으로 변경됩니다.
    - 요청이 완료되면 버튼 내용이 `요청 완료`로 변경됩니다.
    - 인증이 안료되면 버튼 내용이 `인증 완료`로 변경됩니다.
    - `요청 중...` 상태와 `인증 완료` 상태에서는 전송을 못하도록 버튼이 비활성화됩니다. 그 외에 상황엔 재전송 요청을 할 수 있습니다.
    - 요청이 완료되면 `인증 코드 5자리를 전송했습니다. 아래 입력칸에 작성해주세요.`라는 안내 메시지가 출력됩니다. 요청에 실패하면 `전송에 실패했습니다.` 메시지와 함께 에러 내용을 출력합니다.

  - 인증 단계

    - 초기 전송 요청이 없다면 입력창과 버튼 모두 비활성화되어 있습니다. 전송이 성공적으로 이뤄져야 활성화됩니다.

    - 인증 번호를 입력하여 인증에 성공한다면 아래의 동작이 이뤄집니다.

      - `인증 확인` 버튼의 내용이 `인증 완료`로 변경됩니다.
      - 모든 안내 메시지가 지워집니다.
      - 모든 입력창과 버튼이 비활성화됩니다.
      - 다음 페이지로 넘어갈 수 있는 버튼이 활성화됩니다.

    - 인증에 실패한다면 `잘못된 코드를 입력했습니다. 다시 한 번 확인해주세요.` 메시지를 출력합니다.

- [`FinalPage`](src/pages/FinalPage.jsx)를 구현했습니다. 피그마에서 작성된 버튼 컴포넌트가 variant에 따라 구분되어 있는 것을 확인하고 이를 따로 [Button 컴포넌트](src/components/Button.jsx)로 구현하여 `variant` prop을 통해 스타일을 지정할 수 있도록 하였습니다.

- Vercel과 원격 저장소를 연결하여 배포를 완료했습니다.

### 어려웠던 점 (에러 핸들링)

- 처음엔 휴대폰 인증 기능을 위해 [Twilio SMS API를 이용](https://github.com/Pre-Onboarding-FE-Team07/wanted-codestates-project-7-6/pull/14/files#diff-5a7199d2a2bdf785ff2c6ab51aed32997b544943845727a74f608eb5fb009cf7)했습니다. Twilio SMS API를 이용하기 위해 제공되는 [twilio 모듈](https://www.npmjs.com/package/twilio)이 [server-side만 지원하여](https://www.twilio.com/docs/libraries/node#server-side-only-not-front-end) 간단한 node 서버가 필요했습니다. 하나의 API만 필요하므로 serverless를 구축해 인증 기능을 구현하기로 했습니다. 허나, Twilio API는 메시지를 인증된 번호로만 전송 가능했고 trial 버전의 한계가 있어 Naver SENS API로 변경했습니다.

- API 변경 후 serverless를 이용할 필요는 없었으나 다음의 이점으로 그대로 유지했습니다.
  - 역할에 맞게 코드를 분리해 유지보수에 용이합니다.
  - 클라이언트에서 바로 API를 호출한다면 요청 headers의 Authorization에 전달하는 API 키가 노출되는 문제가 있는데, 서버를 한 번 경유함으로서 이를 해결할 수 있습니다.
